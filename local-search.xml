<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用开发原则</title>
    <link href="/2023/02/25/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/"/>
    <url>/2023/02/25/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="常用开发原则"><a href="#常用开发原则" class="headerlink" title="常用开发原则"></a>常用开发原则</h2><h3 id="1-单一职责原则（Single-Responsibility-Principle，SRP）"><a href="#1-单一职责原则（Single-Responsibility-Principle，SRP）" class="headerlink" title="1. 单一职责原则（Single Responsibility Principle，SRP）"></a>1. 单一职责原则（Single Responsibility Principle，SRP）</h3><p>单一职责原则（Single Responsibility Principle，SRP）是面向对象设计中的一项基本原则，它指出一个类或模块应该只有一个职责或责任，即一个类或模块应该只负责一种功能或行为。</p><p>单一职责原则的目的是将复杂的系统分解为多个简单的组件，每个组件都只关注一个特定的功能或职责，从而使系统更加灵活、可扩展和易于维护。当一个类或模块承担了多种职责时，它就变得复杂、难以维护和扩展，因为修改其中一个职责可能会影响到其他职责。</p><p>单一职责原则常用来解决以下问题：</p><ul><li>类或模块过于庞大，难以维护和理解；</li><li>类或模块承担了过多的职责，难以扩展和重用；</li><li>修改一个职责会影响到其他职责，导致系统出现不稳定的行为。</li></ul><p>下面是一个使用 Swift 5 实现单一职责原则的示例。我们有一个 <strong><code>Order</code></strong> 类，用于表示客户订单，其中包含了订单的详细信息以及订单的处理方法。我们可以将 <strong><code>Order</code></strong> 类拆分成两个类，一个用于表示订单信息，另一个用于处理订单，从而使其符合单一职责原则。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 订单信息类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderInfo</span> &#123;<br>    <span class="hljs-keyword">let</span> orderId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> customerName: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> orderDate: <span class="hljs-type">Date</span><br>    <span class="hljs-keyword">let</span> orderItems: [<span class="hljs-type">OrderItem</span>]<br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">orderId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">customerName</span>: <span class="hljs-type">String</span>, <span class="hljs-params">orderDate</span>: <span class="hljs-type">Date</span>, <span class="hljs-params">orderItems</span>: [<span class="hljs-type">OrderItem</span>]) &#123;<br>        <span class="hljs-keyword">self</span>.orderId <span class="hljs-operator">=</span> orderId<br>        <span class="hljs-keyword">self</span>.customerName <span class="hljs-operator">=</span> customerName<br>        <span class="hljs-keyword">self</span>.orderDate <span class="hljs-operator">=</span> orderDate<br>        <span class="hljs-keyword">self</span>.orderItems <span class="hljs-operator">=</span> orderItems<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 订单处理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">order</span>: <span class="hljs-type">OrderInfo</span>) &#123;<br>        <span class="hljs-comment">// 处理订单逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们将 <strong><code>Order</code></strong> 类拆分成了 <strong><code>OrderInfo</code></strong> 和 <strong><code>OrderProcessor</code></strong> 两个类。**<code>OrderInfo</code>** 类用于表示订单的详细信息，包括订单编号、客户名称、下单日期和订单项；**<code>OrderProcessor</code>** 类用于处理订单，包括处理订单的逻辑和实现。</p><p>通过将 <strong><code>Order</code></strong> 类拆分成多个类，我们遵守了单一职责原则，使每个类只关注一种特定的功能或职责。这样，如果我们需要修改订单处理逻辑，就不会影响到订单信息的表示和存储，从而使系统更加稳定和易于维护。</p><h3 id="2-开放封闭原则（Open-x2F-Closed-Principle，OCP）"><a href="#2-开放封闭原则（Open-x2F-Closed-Principle，OCP）" class="headerlink" title="2. 开放封闭原则（Open&#x2F;Closed Principle，OCP）"></a>2. 开放封闭原则（Open&#x2F;Closed Principle，OCP）</h3><p>开放封闭原则（Open&#x2F;Closed Principle，OCP）是面向对象设计中的一项基本原则，它指出一个软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着在不修改原有代码的情况下，可以通过扩展代码的行为来实现新的功能。</p><p>开放封闭原则的目的是保持系统的稳定性和可维护性。当系统需要修改现有代码来添加新的功能时，可能会导致系统出现不稳定的行为和意外的副作用。通过遵守开放封闭原则，我们可以避免这些问题，同时使系统更加灵活和易于扩展。</p><p>开放封闭原则常用来解决以下问题：</p><ul><li>当需要添加新的功能时，不希望修改现有的代码；</li><li>当需要修改现有的代码时，不希望影响到系统的稳定性和可维护性。</li></ul><p>下面是一个使用 Swift 5 实现开放封闭原则的示例。我们有一个 <strong><code>OrderProcessor</code></strong> 类，用于处理客户订单，其中包含了订单的详细信息以及订单的处理方法。我们希望能够通过添加新的支付方式来扩展订单处理逻辑，同时不影响现有的代码。为了实现这个目标，我们可以将支付逻辑封装到一个单独的类中，从而使其可以独立扩展和修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 订单信息类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderInfo</span> &#123;<br>    <span class="hljs-keyword">let</span> orderId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> customerName: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> orderDate: <span class="hljs-type">Date</span><br>    <span class="hljs-keyword">let</span> orderItems: [<span class="hljs-type">OrderItem</span>]<br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">orderId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">customerName</span>: <span class="hljs-type">String</span>, <span class="hljs-params">orderDate</span>: <span class="hljs-type">Date</span>, <span class="hljs-params">orderItems</span>: [<span class="hljs-type">OrderItem</span>]) &#123;<br>        <span class="hljs-keyword">self</span>.orderId <span class="hljs-operator">=</span> orderId<br>        <span class="hljs-keyword">self</span>.customerName <span class="hljs-operator">=</span> customerName<br>        <span class="hljs-keyword">self</span>.orderDate <span class="hljs-operator">=</span> orderDate<br>        <span class="hljs-keyword">self</span>.orderItems <span class="hljs-operator">=</span> orderItems<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 支付接口</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>)<br>&#125;<br><br><span class="hljs-comment">// 现金支付类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPayment</span>: <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-comment">// 现金支付逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 支付宝支付类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayPayment</span>: <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-comment">// 支付宝支付逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 订单处理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> payment: <span class="hljs-type">Payment</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">payment</span>: <span class="hljs-type">Payment</span>) &#123;<br>        <span class="hljs-keyword">self</span>.payment <span class="hljs-operator">=</span> payment<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">order</span>: <span class="hljs-type">OrderInfo</span>) &#123;<br>        <span class="hljs-comment">// 处理订单逻辑</span><br><br>        <span class="hljs-comment">// 支付订单</span><br>        payment.pay(amount: order.totalAmount)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们将支付逻辑封装到了 <strong><code>Payment</code></strong> 接口中，并实现了两个具体的支付类 <strong><code>CashPayment</code></strong> 和 **<code>AlipayPayment</code>**。我们还将支付逻辑注入到了 <strong><code>OrderProcessor</code></strong> 类中，通过传递不同的支付类实现订单处理的扩展和修改。</p><p>通过将支付逻辑封装到一个单独的类中，我们可以在不影响现有代码的情况下，添加新的支付方式和修改支付逻辑，从而实现了开放封闭原则。当需要添加新的支付方式时，我们只需要实现一个新的支付类并注入到 <strong><code>OrderProcessor</code></strong> 中即可，不需要修改现有的代码。</p><p>下面是一个示例代码，用于创建一个现金支付订单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> order <span class="hljs-operator">=</span> <span class="hljs-type">OrderInfo</span>(orderId: <span class="hljs-string">&quot;123456&quot;</span>, customerName: <span class="hljs-string">&quot;张三&quot;</span>, orderDate: <span class="hljs-type">Date</span>(), orderItems: [item1, item2])<br><span class="hljs-keyword">let</span> cashPayment <span class="hljs-operator">=</span> <span class="hljs-type">CashPayment</span>()<br><span class="hljs-keyword">let</span> orderProcessor <span class="hljs-operator">=</span> <span class="hljs-type">OrderProcessor</span>(payment: cashPayment)<br>orderProcessor.process(order: order)<br></code></pre></td></tr></table></figure><p>我们还可以创建一个支付宝支付订单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> order <span class="hljs-operator">=</span> <span class="hljs-type">OrderInfo</span>(orderId: <span class="hljs-string">&quot;123456&quot;</span>, customerName: <span class="hljs-string">&quot;张三&quot;</span>, orderDate: <span class="hljs-type">Date</span>(), orderItems: [item1, item2])<br><span class="hljs-keyword">let</span> alipayPayment <span class="hljs-operator">=</span> <span class="hljs-type">AlipayPayment</span>()<br><span class="hljs-keyword">let</span> orderProcessor <span class="hljs-operator">=</span> <span class="hljs-type">OrderProcessor</span>(payment: alipayPayment)<br>orderProcessor.process(order: order)<br></code></pre></td></tr></table></figure><p>通过实现开放封闭原则，我们使系统更加灵活和易于扩展，同时保持了系统的稳定性和可维护性。</p><h3 id="3-里式替换原则（Liskov-Substitution-Principle，LSP）"><a href="#3-里式替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="3. 里式替换原则（Liskov Substitution Principle，LSP）"></a>3. 里式替换原则（Liskov Substitution Principle，LSP）</h3><p>里式替换原则（Liskov Substitution Principle，LSP）是面向对象设计中的一个重要原则，它指出：子类对象应该能够替换掉父类对象并且仍能保持程序的正确性。</p><p>这个原则的核心思想是：子类不应该破坏父类的封装和抽象，即子类中新增的方法和属性不应该影响到父类的行为。LSP可以帮助我们确保代码的正确性和可扩展性，同时也可以避免出现一些难以调试的问题。</p><p>下面，我们以一个简单的 Swift 示例来说明 LSP 的应用。假设我们有一个图形库，其中包含 <strong><code>Shape</code></strong> 基类和两个子类 <strong><code>Rectangle</code></strong> 和 <strong><code>Circle</code><strong>。</strong><code>Shape</code></strong> 类有一个计算面积的方法 <strong><code>calculateArea()</code><strong>，</strong><code>Rectangle</code></strong> 和 <strong><code>Circle</code></strong> 分别实现了这个方法。我们可以使用这些类来创建不同的图形，并计算它们的面积。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">var</span> width: <span class="hljs-type">Double</span><br>    <span class="hljs-keyword">var</span> height: <span class="hljs-type">Double</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">width</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">height</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.width <span class="hljs-operator">=</span> width<br>        <span class="hljs-keyword">self</span>.height <span class="hljs-operator">=</span> height<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">return</span> width <span class="hljs-operator">*</span> height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Double</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.radius <span class="hljs-operator">=</span> radius<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>.pi <span class="hljs-operator">*</span> radius <span class="hljs-operator">*</span> radius<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们希望在图形库中添加一个新的图形类 **<code>Square</code>**，它是 <strong><code>Rectangle</code></strong> 的一个特例，即它的宽和高相等。按照 LSP 的原则，我们应该可以将 <strong><code>Square</code></strong> 对象替换为 <strong><code>Rectangle</code></strong> 对象而不会影响程序的正确性。</p><p>我们可以创建一个 <strong><code>Square</code></strong> 类继承自 **<code>Rectangle</code>**，并重写父类的初始化方法，确保 <strong><code>width</code></strong> 和 <strong><code>height</code></strong> 始终相等：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>: <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">side</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(width: side, height: side)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以在创建图形时使用 <strong><code>Square</code></strong> 替换 <strong><code>Rectangle</code></strong> 对象，并调用 <strong><code>calculateArea()</code></strong> 方法计算面积：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> rectangle <span class="hljs-operator">=</span> <span class="hljs-type">Rectangle</span>(width: <span class="hljs-number">4</span>, height: <span class="hljs-number">5</span>)<br><span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(radius: <span class="hljs-number">3</span>)<br><span class="hljs-keyword">let</span> square <span class="hljs-operator">=</span> <span class="hljs-type">Square</span>(side: <span class="hljs-number">4</span>)<br><br><span class="hljs-keyword">let</span> shapes: [<span class="hljs-type">Shape</span>] <span class="hljs-operator">=</span> [rectangle, circle, square]<br><br><span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Area of <span class="hljs-subst">\(<span class="hljs-built_in">type</span>(of: shape))</span> is <span class="hljs-subst">\(shape.calculateArea())</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">输出结果如下：</code></pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Area</span> of <span class="hljs-type">Rectangle</span> <span class="hljs-keyword">is</span> <span class="hljs-number">20.0</span><br><span class="hljs-type">Area</span> of <span class="hljs-type">Circle</span> <span class="hljs-keyword">is</span> <span class="hljs-number">28.274333882308138</span><br><span class="hljs-type">Area</span> of <span class="hljs-type">Square</span> <span class="hljs-keyword">is</span> <span class="hljs-number">16.0</span><br></code></pre></td></tr></table></figure><p>由于 <strong><code>Square</code></strong> 对象是 <strong><code>Rectangle</code></strong> 的特例，我们可以使用 <strong><code>Square</code></strong> 对象替换 <strong><code>Rectangle</code></strong> 对象而不影响程序的正确性。这就是 LSP 的应用途，通过使用 LSP，我们可以创建更加灵活的代码，可以轻松地添加新的子类，并在不破坏现有代码的情况下进行修改和扩展。</p><p>在实际开发中，为了遵循 LSP 原则，我们需要遵循以下几个准则：</p><ul><li>子类必须实现父类的所有方法，并且方法的输入输出参数类型与父类一致或者更加宽松。</li><li>子类新增的方法和属性不应该影响到父类的行为。</li><li>子类的前置条件（输入参数）不能强于父类的前置条件。</li><li>子类的后置条件（输出参数）不能弱于父类的后置条件。</li></ul><p>下面，我们再以一个 Swift 示例来说明 LSP 的应用。假设我们有一个计算器应用，其中包含一个 <strong><code>Calculator</code></strong> 基类和两个子类 <strong><code>SimpleCalculator</code></strong> 和 <strong><code>ScientificCalculator</code><strong>。</strong><code>Calculator</code></strong> 类有一个计算方法 <strong><code>calculate(_:)</code><strong>，</strong><code>SimpleCalculator</code></strong> 和 <strong><code>ScientificCalculator</code></strong> 分别实现了这个方法。我们可以使用这些类来进行简单的数学计算。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-comment">// 简单计算逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScientificCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-comment">// 科学计算逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们希望添加一个新的子类 **<code>GraphingCalculator</code>**，它可以将计算结果以图表的形式展示出来。按照 LSP 的原则，我们应该可以将 <strong><code>GraphingCalculator</code></strong> 对象替换为 <strong><code>SimpleCalculator</code></strong> 或 <strong><code>ScientificCalculator</code></strong> 对象而不会影响程序的正确性。</p><p>我们可以创建一个 <strong><code>GraphingCalculator</code></strong> 类，它继承自 **<code>Calculator</code>**，并实现 <strong><code>calculate(_:)</code></strong> 方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphingCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">super</span>.calculate(expression)<br>        <span class="hljs-comment">// 将计算结果以图表的形式展示出来</span><br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以使用 <strong><code>GraphingCalculator</code></strong> 对象来进行数学计算，并将计算结果以图表的形式展示出来：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> simpleCalculator <span class="hljs-operator">=</span> <span class="hljs-type">SimpleCalculator</span>()<br><span class="hljs-keyword">let</span> scientificCalculator <span class="hljs-operator">=</span> <span class="hljs-type">ScientificCalculator</span>()<br><span class="hljs-keyword">let</span> graphingCalculator <span class="hljs-operator">=</span> <span class="hljs-type">GraphingCalculator</span>()<br><br><span class="hljs-keyword">let</span> expressions <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;2 + 2&quot;</span>, <span class="hljs-string">&quot;sin(45)&quot;</span>, <span class="hljs-string">&quot;log(10)&quot;</span>]<br><br><span class="hljs-keyword">for</span> expression <span class="hljs-keyword">in</span> expressions &#123;<br>    <span class="hljs-keyword">let</span> simpleResult <span class="hljs-operator">=</span> simpleCalculator.calculate(expression)<br>    <span class="hljs-keyword">let</span> scientificResult <span class="hljs-operator">=</span> scientificCalculator.calculate(expression)<br>    <span class="hljs-keyword">let</span> graphingResult <span class="hljs-operator">=</span> graphingCalculator.calculate(expression)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Simple: <span class="hljs-subst">\(simpleResult)</span>, Scientific: <span class="hljs-subst">\(scientificResult)</span>, Graphing: <span class="hljs-subst">\(graphingResult)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Simple</span>: <span class="hljs-number">4.0</span>, <span class="hljs-type">Scientific</span>: <span class="hljs-number">0.8509035245341184</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">4.0</span><br><span class="hljs-type">Simple</span>: <span class="hljs-number">0.8509035245341184</span>,<span class="hljs-type">Scientific</span>: <span class="hljs-number">0.8509035245341184</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">0.8509035245341184</span><br><span class="hljs-type">Simple</span>: <span class="hljs-number">2.302585092994046</span>, <span class="hljs-type">Scientific</span>: <span class="hljs-number">2.302585092994046</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">2.302585092994046</span><br></code></pre></td></tr></table></figure><p>可以看到，我们成功地将 <code>GraphingCalculator</code> 对象替换为 <code>SimpleCalculator</code> 和 <code>ScientificCalculator</code> 对象，而不会影响程序的正确性。这就是 LSP 的优势。</p><p>总之，LSP 是一个非常重要的面向对象编程原则，它可以帮助我们创建灵活、可扩展、易于维护的代码。为了遵循 LSP，我们需要在设计类的时候遵循一些基本的规则，并保证子类可以完全替换父类，而不会影响程序的正确性。</p><h3 id="4-接口隔离原则（Interface-Segregation-Principle，ISP）"><a href="#4-接口隔离原则（Interface-Segregation-Principle，ISP）" class="headerlink" title="4. 接口隔离原则（Interface Segregation Principle，ISP）"></a>4. 接口隔离原则（Interface Segregation Principle，ISP）</h3><p>接口隔离原则（Interface Segregation Principle，ISP）是面向对象编程中的一条原则，它指出“客户端不应该被迫依赖于它不使用的方法”。换句话说，如果一个接口的方法过于冗杂，一个类可能不得不实现一些它并不需要的方法。这不仅浪费了时间和资源，而且会导致代码的复杂性和脆弱性。</p><p>ISP 的主要目的是分离接口，将大型、复杂的接口分解为更小、更简单的接口，以便客户端只需知道与其相关的方法。这样，客户端就不必担心不需要的方法，而只需要专注于与其相关的方法。</p><p>为了遵循 ISP，我们需要在设计接口时考虑到客户端的需要，并将其分解为更小、更简单的接口。这样，客户端只需要依赖它们需要的接口，而不必依赖于整个接口。</p><p>下面是一个使用 ISP 的例子。假设我们正在设计一个图形编辑器，其中有多种形状（如矩形、圆形、三角形等）。每个形状都可以绘制、移动、调整大小等。我们可以将这些操作定义在一个大型的 <strong><code>Shape</code></strong> 接口中，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>()<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">to</span> <span class="hljs-params">point</span>: <span class="hljs-type">CGPoint</span>)<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">to</span> <span class="hljs-params">size</span>: <span class="hljs-type">CGSize</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，如果我们这样设计，那么所有的形状都必须实现所有的方法，即使它们并不需要某些方法。这显然不符合 ISP。为了解决这个问题，我们可以将这个大型接口拆分为多个更小、更专业的接口，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Drawable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>()<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Movable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">to</span> <span class="hljs-params">point</span>: <span class="hljs-type">CGPoint</span>)<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Resizable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">to</span> <span class="hljs-params">size</span>: <span class="hljs-type">CGSize</span>)<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Shape</span>: <span class="hljs-title class_">Drawable</span>, <span class="hljs-title class_">Movable</span>, <span class="hljs-title class_">Resizable</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>现在，我们的每个形状只需要实现与其相关的方法。例如，圆形只需要实现 <strong><code>Drawable</code></strong> 和 <strong><code>Resizable</code></strong> 接口，而不需要实现 <strong><code>Movable</code></strong> 接口。这样，我们的代码就更加灵活，易于扩展和维护了。</p><p>总之，ISP 是一个非常重要的面向对象编程原则，它可以帮助我们创建灵活、可扩展、易于维护的代码。为了遵循 ISP，我们需要在设计接口时考虑客户端的需要，并将其拆分为更小、更简单的接口。</p><h3 id="5-迪米特法则（Law-of-Demeter，LoD）"><a href="#5-迪米特法则（Law-of-Demeter，LoD）" class="headerlink" title="5. 迪米特法则（Law of Demeter，LoD）"></a>5. 迪米特法则（Law of Demeter，LoD）</h3><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Principle of Least Knowledge），是面向对象编程中的一条设计原则，它强调一个对象应该尽可能少地了解其他对象，并且只和它们的直接朋友（成员变量、方法参数等）通信，而不与非直接朋友进行通信。</p><p>迪米特法则的目的是减少类之间的耦合度，提高系统的稳定性、可维护性和可扩展性。当一个类依赖的其他类太多时，如果这些依赖的类发生了改变，就会对该类产生较大的影响，从而导致代码的复杂度增加。因此，遵循迪米特法则可以使得类之间的耦合度降低，从而使得代码更加模块化、易于维护和重构。</p><p>下面以 Swift 5 代码举例，展示如何使用迪米特法则来减少类之间的耦合度。假设我们有一个订单类，它需要依赖客户类和商品类来进行处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">var</span> customerId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> productId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> quantity: <span class="hljs-type">Int</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">productId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">quantity</span>: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">self</span>.customerId <span class="hljs-operator">=</span> customerId<br>        <span class="hljs-keyword">self</span>.productId <span class="hljs-operator">=</span> productId<br>        <span class="hljs-keyword">self</span>.quantity <span class="hljs-operator">=</span> quantity<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateTotal</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">let</span> customer <span class="hljs-operator">=</span> <span class="hljs-type">Customer</span>.getCustomerById(customerId: customerId)<br>        <span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> <span class="hljs-type">Product</span>.getProductById(productId: productId)<br>        <span class="hljs-keyword">let</span> totalPrice <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(quantity) <span class="hljs-operator">*</span> product.price<br>        <span class="hljs-keyword">return</span> totalPrice<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span> &#123;<br>        <span class="hljs-comment">// 模拟获取客户对象的过程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Customer</span>(id: customerId, name: <span class="hljs-string">&quot;&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span> &#123;<br>        <span class="hljs-comment">// 模拟获取商品对象的过程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Product</span>(id: productId, name: <span class="hljs-string">&quot;&quot;</span>, price: <span class="hljs-number">0.0</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，订单类依赖了客户类和商品类的静态方法，通过这些静态方法获取了客户对象和商品对象。这种方式违反了迪米特法则，因为订单类不仅需要了解客户类和商品类的接口，还需要了解它们的具体实现细节。</p><p>为了遵循迪米特法则，我们可以通过依赖注入的方式，来减少订单类对客户类和商品类的依赖。下面是修改后的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">CustomerProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerService</span>: <span class="hljs-title class_">CustomerProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span> &#123;<br>        <span class="hljs-comment">// 模拟获取客户对象的过程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Customer</span>(id: customerId, name: <span class="hljs-string">&quot;&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">ProductProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span>: <span class="hljs-title class_">ProductProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span> &#123;<br>        <span class="hljs-comment">// 模拟获取商品对象的过程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Product</span>(id: productId, name: <span class="hljs-string">&quot;&quot;</span>, price: <span class="hljs-number">0.0</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">var</span> customerId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> productId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> quantity: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> customerService: <span class="hljs-type">CustomerProtocol</span><br>    <span class="hljs-keyword">var</span> productService: <span class="hljs-type">ProductProtocol</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">productId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">quantity</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">customerService</span>: <span class="hljs-type">CustomerProtocol</span>, <span class="hljs-params">productService</span>: <span class="hljs-type">ProductProtocol</span>) &#123;<br>        <span class="hljs-keyword">self</span>.customerId <span class="hljs-operator">=</span> customerId<br>        <span class="hljs-keyword">self</span>.productId <span class="hljs-operator">=</span> productId<br>        <span class="hljs-keyword">self</span>.quantity <span class="hljs-operator">=</span> quantity<br>        <span class="hljs-keyword">self</span>.customerService <span class="hljs-operator">=</span> customerService<br>        <span class="hljs-keyword">self</span>.productService <span class="hljs-operator">=</span> productService<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateTotal</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">let</span> customer <span class="hljs-operator">=</span> customerService.getCustomerById(customerId: customerId)<br>        <span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> productService.getProductById(productId: productId)<br>        <span class="hljs-keyword">let</span> totalPrice <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(quantity) <span class="hljs-operator">*</span> product.price<br>        <span class="hljs-keyword">return</span> totalPrice<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们使用协议和依赖注入的方式来降低订单类对客户类和商品类的耦合度。具体来说，我们定义了两个协议 <code>CustomerProtocol</code> 和 <code>ProductProtocol</code>，分别包含了获取客户对象和商品对象的方法。然后我们实现了两个具体的服务类 <code>CustomerService</code> 和 <code>ProductService</code>，它们分别实现了上述协议中定义的方法，用于提供客户对象和商品对象的获取功能。</p><p>接下来，我们修改了订单类的构造函数，将客户服务对象和商品服务对象作为参数传入。在 calculateTotal 方法中，我们不再直接调用客户类和商品类的静态方法，而是通过客户服务对象和商品服务对象来获取客户对象和商品对象。这样一来，订单类只依赖了客户服务类和商品服务类的接口，而不再依赖它们的具体实现细节，这就遵循了迪米特法则。</p><p>总之，迪米特法则是一条重要的设计原则，它可以帮助我们减少类之间的耦合度，提高系统的稳定性、可维护性和可扩展性。在编写代码时，我们应该尽可能地遵循这个原则，尽量减少类之间的交互，使得每个类的职责更加清晰，代码结构更加简单易懂，从而使得代码更加健壮和可维护。</p><p>需要注意的是，在实际开发中，迪米特法则并不是一个银弹，它并不能解决所有的问题，也不能被简单地应用到所有的场景中。在某些情况下，迪米特法则可能会导致类之间的通信变得复杂，从而降低系统的效率和性能。因此，在应用迪米特法则时，我们需要根据具体的情况来灵活运用，综合考虑各种因素，找到最合适的设计方案。</p><p>“银弹”是一个编程界中的术语，指的是一种能够解决所有问题的神奇解决方案。因此，“迪米特法则并不是一个银弹”意味着迪米特法则并不能解决所有问题，我们需要根据具体情况进行灵活应用和综合考虑。</p><h3 id="6-依赖倒置原则（Dependency-Inversion-Principle，DIP）"><a href="#6-依赖倒置原则（Dependency-Inversion-Principle，DIP）" class="headerlink" title="6. 依赖倒置原则（Dependency Inversion Principle，DIP）"></a>6. 依赖倒置原则（Dependency Inversion Principle，DIP）</h3><p>依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它强调高层模块不应该依赖低层模块，它们都应该依赖于抽象；而抽象不应该依赖于细节，细节应该依赖于抽象。简单来说，就是要面向接口编程，而不是面向实现编程。</p><p>依赖倒置原则的作用是降低模块之间的耦合度，提高代码的灵活性、可扩展性和可维护性。它可以避免在修改一个模块时，对其他模块造成影响，同时也能够方便地进行单元测试和模块重用。</p><p>下面是使用 Swift 5 实现依赖倒置原则的一个示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 定义一个协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>()<br>&#125;<br><br><span class="hljs-comment">// 实现两个类，它们都遵循了 Animal 协议</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>: <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Meow&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Woof&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个高层模块，它依赖于 Animal 协议</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalShelter</span> &#123;<br>    <span class="hljs-keyword">var</span> animals: [<span class="hljs-type">Animal</span>] <span class="hljs-operator">=</span> []<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addAnimal</span>(<span class="hljs-params">animal</span>: <span class="hljs-type">Animal</span>) &#123;<br>        animals.append(animal)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeAllAnimalsSound</span>() &#123;<br>        <span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals &#123;<br>            animal.makeSound()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在客户端代码中，可以通过向 AnimalShelter 添加不同的 Animal 来实现不同的行为</span><br><span class="hljs-keyword">let</span> animalShelter <span class="hljs-operator">=</span> <span class="hljs-type">AnimalShelter</span>()<br>animalShelter.addAnimal(animal: <span class="hljs-type">Cat</span>())<br>animalShelter.addAnimal(animal: <span class="hljs-type">Dog</span>())<br>animalShelter.makeAllAnimalsSound()<br></code></pre></td></tr></table></figure><p>在上面的示例中，Animal 是一个抽象的概念，Cat 和 Dog 是具体的实现类。AnimalShelter 是一个高层模块，它不依赖于具体的实现类，而是依赖于 Animal 协议。在客户端代码中，可以通过向 AnimalShelter 添加不同的 Animal 来实现不同的行为，而不需要修改 AnimalShelter 类的代码。</p><p>这就是依赖倒置原则的一个实现，它通过引入抽象的概念，降低了 AnimalShelter 和具体实现类之间的耦合度，提高了代码的可扩展性和可维护性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/2023/02/25/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/25/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式是一种创建型设计模式，允许客户端创建一系列相关对象而无需指定其具体类。这种模式提供了一种封装一组具有共同主题的单独工厂而不指定其具体类的方法。</p><p>在 Swift 5 中，我们可以通过定义协议并用其实现类来实现抽象工厂模式。以下是一个基于抽象工厂模式的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 定义抽象工厂协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createButton</span>() -&gt; <span class="hljs-type">Button</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createTextField</span>() -&gt; <span class="hljs-type">TextField</span><br>&#125;<br><br><span class="hljs-comment">// 定义具体工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory1</span>: <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createButton</span>() -&gt; <span class="hljs-type">Button</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ConcreteButton1</span>()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createTextField</span>() -&gt; <span class="hljs-type">TextField</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ConcreteTextField1</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory2</span>: <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createButton</span>() -&gt; <span class="hljs-type">Button</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ConcreteButton2</span>()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createTextField</span>() -&gt; <span class="hljs-type">TextField</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ConcreteTextField2</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义抽象产品协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>()<br>&#125;<br><br><span class="hljs-comment">// 定义具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteButton1</span>: <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is Button 1&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteButton2</span>: <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is Button 2&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义抽象产品协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">TextField</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>()<br>&#125;<br><br><span class="hljs-comment">// 定义具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteTextField1</span>: <span class="hljs-title class_">TextField</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is Text Field 1&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteTextField2</span>: <span class="hljs-title class_">TextField</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is Text Field 2&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用抽象工厂模式创建对象</span><br><span class="hljs-keyword">let</span> factory1 <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteFactory1</span>()<br><span class="hljs-keyword">let</span> factory2 <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteFactory2</span>()<br><br><span class="hljs-keyword">let</span> button1 <span class="hljs-operator">=</span> factory1.createButton()<br><span class="hljs-keyword">let</span> textField1 <span class="hljs-operator">=</span> factory1.createTextField()<br><br><span class="hljs-keyword">let</span> button2 <span class="hljs-operator">=</span> factory2.createButton()<br><span class="hljs-keyword">let</span> textField2 <span class="hljs-operator">=</span> factory2.createTextField()<br><br>button1.display() <span class="hljs-comment">// Output: This is Button 1</span><br>textField1.display() <span class="hljs-comment">// Output: This is Text Field 1</span><br><br>button2.display() <span class="hljs-comment">// Output: This is Button 2</span><br>textField2.display() <span class="hljs-comment">// Output: This is Text Field 2</span><br><br></code></pre></td></tr></table></figure><p>在上述代码中，我们定义了一个抽象工厂协议 <code>AbstractFactory</code>，并用其实现类 <code>ConcreteFactory1</code> 和 <code>ConcreteFactory2</code> 来创建一系列相关对象。具体产品类 <code>ConcreteButton1</code>、<code>ConcreteButton2</code>、<code>ConcreteTextField1</code> 和 <code>ConcreteTextField2</code> 实现了抽象产品协议 <code>Button</code> 和 <code>TextField</code>，并在具体工厂类中被实例化。通过使用具体工厂类创建产品对象，我们可以无需指定其具体类，从而实现了抽象工厂模式的特性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/25/hello-world/"/>
    <url>/2023/02/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
