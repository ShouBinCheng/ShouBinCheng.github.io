<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>24 种设计模式-3 (Swift 5版)</title>
    <link href="/2023/02/25/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-Swift-5%E7%89%88/"/>
    <url>/2023/02/25/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-Swift-5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h2><h3 id="1-模板方法模式（Template-Method-Pattern）"><a href="#1-模板方法模式（Template-Method-Pattern）" class="headerlink" title="1. 模板方法模式（Template Method Pattern）"></a>1. 模板方法模式（Template Method Pattern）</h3><p>模板方法模式是一种行为设计模式，其目的是定义一个算法的骨架，而将一些步骤延迟到子类中实现。在模板方法模式中，一个抽象类公开定义了执行它的方法的方式&#x2F;步骤，但是没有实现这些步骤，这些步骤由子类实现。</p><p>常用来解决的问题是在一个算法中保持不变的部分在父类中实现，而可变的部分在子类中实现，这样可以避免重复的代码，并且方便扩展。</p><p>下面是一个使用 Swift 5 实现模板方法模式的示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">prepareRecipe</span>() &#123;<br>        boilWater()<br>        brew()<br>        pourInCup()<br>        addCondiments()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">boilWater</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Boiling water&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pourInCup</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Pouring into cup&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">brew</span>() &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCondiments</span>() &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeWithSugar</span>: <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">brew</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Brewing coffee&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCondiments</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Adding sugar&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeWithMilk</span>: <span class="hljs-title class_">Coffee</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">brew</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Brewing coffee&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCondiments</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Adding milk&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，Coffee 是抽象类，定义了 prepareRecipe() 方法的骨架，以及 boilWater() 和 pourInCup() 这两个步骤的具体实现。其中，brew() 和 addCondiments() 方法都是抽象的，需要在子类中实现。</p><p>CoffeeWithSugar 和 CoffeeWithMilk 是两个具体的子类，分别实现了 brew() 和 addCondiments() 方法。这样，通过调用 CoffeeWithSugar 和 CoffeeWithMilk 的 prepareRecipe() 方法，就可以制作出带糖和带牛奶的咖啡了。</p><p>下面是示例代码的运行结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> coffeeWithSugar <span class="hljs-operator">=</span> <span class="hljs-type">CoffeeWithSugar</span>()<br>coffeeWithSugar.prepareRecipe()<br><br><span class="hljs-keyword">let</span> coffeeWithMilk <span class="hljs-operator">=</span> <span class="hljs-type">CoffeeWithMilk</span>()<br>coffeeWithMilk.prepareRecipe()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Boiling</span> water<br><span class="hljs-type">Brewing</span> coffee<br><span class="hljs-type">Pouring</span> into cup<br><span class="hljs-type">Adding</span> sugar<br><br><span class="hljs-type">Boiling</span> water<br><span class="hljs-type">Brewing</span> coffee<br><span class="hljs-type">Pouring</span> into cup<br><span class="hljs-type">Adding</span> milk<br></code></pre></td></tr></table></figure><h3 id="2-策略模式（Strategy-Pattern）"><a href="#2-策略模式（Strategy-Pattern）" class="headerlink" title="2. 策略模式（Strategy Pattern）"></a>2. 策略模式（Strategy Pattern）</h3><p>策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时动态地选择算法或行为，以解决相似问题的多种解决方案。</p><p>通常，当我们需要实现某种算法或行为，但可能有多种实现方式时，策略模式就非常有用了。使用该模式可以在运行时根据需求选择不同的算法或行为，而不必在代码中硬编码。</p><p>下面是一个使用 Swift 5 实现策略模式的示例，假设我们有一个飞行器接口 **<code>Flyable</code>**，我们需要实现不同的飞行策略，包括直升飞机、固定翼飞机和火箭。</p><ul><li><p>Swift Code</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 飞行器接口</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>()<br>&#125;<br><br><span class="hljs-comment">// 直升飞机策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelicopterStrategy</span>: <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;直升飞机在空中盘旋。&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 固定翼飞机策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirplaneStrategy</span>: <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;固定翼飞机在天空中飞行。&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 火箭策略</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RocketStrategy</span>: <span class="hljs-title class_">Flyable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;火箭在太空中飞行。&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 飞行器类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Aircraft</span> &#123;<br>    <span class="hljs-keyword">var</span> flyStrategy: <span class="hljs-type">Flyable</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">strategy</span>: <span class="hljs-type">Flyable</span>) &#123;<br>        <span class="hljs-keyword">self</span>.flyStrategy <span class="hljs-operator">=</span> strategy<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;<br>        <span class="hljs-keyword">self</span>.flyStrategy.fly()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">let</span> helicopter <span class="hljs-operator">=</span> <span class="hljs-type">Aircraft</span>(strategy: <span class="hljs-type">HelicopterStrategy</span>())<br>helicopter.fly()  <span class="hljs-comment">// 输出: 直升飞机在空中盘旋。</span><br><br><span class="hljs-keyword">let</span> airplane <span class="hljs-operator">=</span> <span class="hljs-type">Aircraft</span>(strategy: <span class="hljs-type">AirplaneStrategy</span>())<br>airplane.fly()  <span class="hljs-comment">// 输出: 固定翼飞机在天空中飞行。</span><br><br><span class="hljs-keyword">let</span> rocket <span class="hljs-operator">=</span> <span class="hljs-type">Aircraft</span>(strategy: <span class="hljs-type">RocketStrategy</span>())<br>rocket.fly()  <span class="hljs-comment">// 输出: 火箭在太空中飞行。</span><br></code></pre></td></tr></table></figure></li></ul><p>在上面的代码中，我们定义了一个 <strong><code>Flyable</code></strong> 接口，表示飞行器的行为。然后，我们创建了三个不同的飞行策略类 <strong><code>HelicopterStrategy</code><strong>、</strong><code>AirplaneStrategy</code></strong> 和 **<code>RocketStrategy</code>**，它们分别实现了 <strong><code>Flyable</code></strong> 接口。</p><p>接着，我们创建了 <strong><code>Aircraft</code></strong> 类，其中包含一个 <strong><code>flyStrategy</code></strong> 属性，该属性用于存储具体的飞行策略对象。**<code>Aircraft</code>** 类的 <strong><code>fly()</code></strong> 方法使用 <strong><code>flyStrategy</code></strong> 属性来调用相应的飞行行为。</p><p>最后，我们创建了三个不同的 <strong><code>Aircraft</code></strong> 实例，并分别传入不同的飞行策略对象，以达到动态选择飞行策略的效果。</p><h3 id="3-观察者模式（Observer-Pattern）"><a href="#3-观察者模式（Observer-Pattern）" class="headerlink" title="3. 观察者模式（Observer Pattern）"></a>3. 观察者模式（Observer Pattern）</h3><p>观察者模式（Observer Pattern）是一种行为型设计模式，它允许一个对象（主题）维护一系列依赖于它的对象（观察者），当主题发生变化时，自动通知观察者进行相应的更新操作。</p><p>通常，当我们需要实现对象之间的松耦合时，观察者模式就非常有用了。使用该模式可以使得主题对象和观察者对象相互独立，只需要定义好接口，就可以在运行时动态地添加或删除观察者。</p><p>下面是一个使用 Swift 5 实现观察者模式的示例，假设我们有一个主题 **<code>Subject</code>**，需要通知多个观察者 **<code>Observer</code>**，以实现一个简单的文本编辑器，当用户输入文本时，通知所有观察者进行相应的更新。</p><ul><li><p>Swift Code</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 主题协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">registerObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>)<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>)<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">notifyObservers</span>()<br>&#125;<br><br><span class="hljs-comment">// 观察者协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>()<br>&#125;<br><br><span class="hljs-comment">// 文本编辑器主题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span>: <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-keyword">var</span> text: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">var</span> observers: [<span class="hljs-type">Observer</span>] <span class="hljs-operator">=</span> []<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">registerObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>) &#123;<br>        <span class="hljs-keyword">self</span>.observers.append(observer)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.observers.firstIndex(where: &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">===</span> observer &#125;) &#123;<br>            <span class="hljs-keyword">self</span>.observers.remove(at: index)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">notifyObservers</span>() &#123;<br>        <span class="hljs-keyword">for</span> observer <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.observers &#123;<br>            observer.update()<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setText</span>(<span class="hljs-params">text</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.text <span class="hljs-operator">=</span> text<br>        <span class="hljs-keyword">self</span>.notifyObservers()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 文本长度观察者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextLengthObserver</span>: <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">var</span> textEditor: <span class="hljs-type">TextEditor</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">textEditor</span>: <span class="hljs-type">TextEditor</span>) &#123;<br>        <span class="hljs-keyword">self</span>.textEditor <span class="hljs-operator">=</span> textEditor<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文本长度为：<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.textEditor.text.count)</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 大写字母观察者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UppercaseObserver</span>: <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">var</span> textEditor: <span class="hljs-type">TextEditor</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">textEditor</span>: <span class="hljs-type">TextEditor</span>) &#123;<br>        <span class="hljs-keyword">self</span>.textEditor <span class="hljs-operator">=</span> textEditor<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;大写字母为：<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.textEditor.text.filter &#123; <span class="hljs-variable">$0</span>.isUppercase &#125;)</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-keyword">let</span> textEditor <span class="hljs-operator">=</span> <span class="hljs-type">TextEditor</span>()<br><span class="hljs-keyword">let</span> lengthObserver <span class="hljs-operator">=</span> <span class="hljs-type">TextLengthObserver</span>(textEditor: textEditor)<br><span class="hljs-keyword">let</span> uppercaseObserver <span class="hljs-operator">=</span> <span class="hljs-type">UppercaseObserver</span>(textEditor: textEditor)<br><br>textEditor.registerObserver(observer: lengthObserver)<br>textEditor.registerObserver(observer: uppercaseObserver)<br><br>textEditor.setText(text: <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br><span class="hljs-comment">// 输出：文本长度为：13</span><br><span class="hljs-comment">//      大写字母为：HW</span><br><br>textEditor.removeObserver(observer: uppercaseObserver)<br>textEditor.setText(text: <span class="hljs-string">&quot;Welcome to the world of programming!&quot;</span>)<br><span class="hljs-comment">// 输出：文本长度为：35</span><br></code></pre></td></tr></table></figure></li></ul><p>在上面的代码中，我们定义了一个 <strong><code>Subject</code></strong> 协议，表示主题对象的行为。主题对象可以注册、移除和通知观察者，这些行为在协议中被定义</p><p>我们还定义了一个 <strong><code>Observer</code></strong> 协议，表示观察者对象的行为。观察者需要实现 <strong><code>update()</code></strong> 方法，在被通知时执行相应的更新操作。</p><p>接下来，我们定义了一个文本编辑器主题 **<code>TextEditor</code>**，它实现了 <strong><code>Subject</code></strong> 协议中定义的行为。主题对象维护了一个观察者数组，用于保存所有的观察者，当主题对象状态发生变化时，会遍历观察者数组并调用每个观察者的 <strong><code>update()</code></strong> 方法进行相应的更新操作。</p><p>我们还定义了两个观察者 <strong><code>TextLengthObserver</code></strong> 和 <strong><code>UppercaseObserver</code><strong>，它们都实现了 <strong><code>Observer</code></strong> 协议中定义的行为。</strong><code>TextLengthObserver</code></strong> 用于在主题对象的文本发生变化时打印文本长度，**<code>UppercaseObserver</code>** 用于在主题对象的文本发生变化时打印大写字母。</p><p>在最后的使用示例中，我们创建了一个文本编辑器主题对象 **<code>textEditor</code>**，并创建了两个观察者对象 <strong><code>lengthObserver</code></strong> 和 **<code>uppercaseObserver</code>**，并将它们注册到主题对象中。随后，我们通过 <strong><code>textEditor.setText(text:)</code></strong> 方法改变了主题对象的状态，从而触发了两个观察者的更新操作，最终输出了相应的结果。</p><p>总的来说，观察者模式使得主题对象和观察者对象之间的耦合度更低，主题对象只需要维护一个观察者列表，并通知观察者对象即可。这种方式可以方便地添加、删除或修改观察者对象，而无需修改主题对象的代码。</p><h3 id="4-迭代器模式（Iterator-Pattern）"><a href="#4-迭代器模式（Iterator-Pattern）" class="headerlink" title="4. 迭代器模式（Iterator Pattern）"></a>4. 迭代器模式（Iterator Pattern）</h3><p>迭代器模式是一种行为型设计模式，它允许我们按照特定的顺序遍历集合中的每个元素，而无需暴露集合的内部表示。该模式定义了一种迭代器接口，该接口提供了遍历集合的方法，而不需要了解集合的内部结构。</p><p>迭代器模式的核心在于将集合和遍历分离开来。这样，我们就可以遍历一个聚合对象，而无需了解聚合对象的内部结构。这种分离有助于提高代码的可重用性，并使代码更易于维护。</p><p>在 Swift 中，标准库已经提供了 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 两个协议，用于实现迭代器模式。如果需要遍历自定义类型的对象，我们可以让该类型实现 <strong><code>Sequence</code></strong> 协议，并在该协议中实现 <strong><code>makeIterator()</code></strong> 方法，返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象。</p><p>下面是一个使用 Swift 标准库提供的协议实现迭代器模式的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MySequence</span>: <span class="hljs-title class_">Sequence</span> &#123;<br>    <span class="hljs-keyword">let</span> values: [<span class="hljs-type">Int</span>]<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">IndexingIterator</span>&lt;[<span class="hljs-type">Int</span>]&gt; &#123;<br>        <span class="hljs-keyword">return</span> values.makeIterator()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> sequence <span class="hljs-operator">=</span> <span class="hljs-type">MySequence</span>(values: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> sequence &#123;<br>    <span class="hljs-built_in">print</span>(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们定义了一个名为 <strong><code>MySequence</code></strong> 的结构体，实现了 <strong><code>Sequence</code></strong> 协议，并在其中实现了 <strong><code>makeIterator()</code></strong> 方法，返回了一个 <strong><code>IndexingIterator&lt;[Int]&gt;</code></strong> 类型的迭代器对象。</p><p>接着，我们创建了一个 <strong><code>MySequence</code></strong> 对象，并使用 <strong><code>for...in</code></strong> 循环遍历了该对象中的所有元素，并输出了每个元素的值。</p><p>需要注意的是，Swift 标准库中提供的 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议已经实现了很多迭代器模式的细节，因此在实现自定义类型的迭代器时，可以直接使用标准库提供的协议。</p><p>Swift 标准库中实现 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的原理是利用了 Swift 的生成器和闭包特性。</p><p>在 Swift 中，生成器是一种特殊的函数，可以在需要时逐个返回值，而不是一次性返回所有值。生成器函数使用 <strong><code>yield</code></strong> 关键字来返回值，并且每次返回值时，函数的状态会被保存下来，以便下一次调用该函数时可以从上次离开的地方继续执行。</p><p><strong><code>IteratorProtocol</code></strong> 协议定义了一个 <strong><code>next()</code></strong> 方法，用于返回序列中的下一个元素。在 Swift 标准库中，**<code>IteratorProtocol</code>** 协议通常由生成器函数来实现，也就是说，**<code>next()</code>** 方法的实现使用了生成器函数的特性，可以在需要时逐个返回序列中的元素，并且在返回元素时保存状态，以便下一次调用 <strong><code>next()</code></strong> 方法时可以从上次离开的地方继续执行。</p><p><strong><code>Sequence</code></strong> 协议定义了一个 <strong><code>makeIterator()</code></strong> 方法，用于返回符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象。在 Swift 标准库中，**<code>Sequence</code>** 协议通常由数组、字典、集合等数据结构来实现。当一个序列对象调用 <strong><code>makeIterator()</code></strong> 方法时，该方法会返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象，该迭代器对象实际上就是由序列对象中的生成器函数来实现的。</p><p>以下是 Swift 标准库中 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的部分实现代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IteratorProtocol</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span><br><br>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Element</span>?<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> &#123;<br>    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Iterator</span>: <span class="hljs-type">IteratorProtocol</span><br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexingIterator</span>&lt;<span class="hljs-title class_">C</span>: <span class="hljs-title class_">Collection</span>&gt;: <span class="hljs-title class_">IteratorProtocol</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">C</span>.<span class="hljs-type">Element</span>? &#123;<br>        <span class="hljs-keyword">if</span> _position <span class="hljs-operator">==</span> _elements.endIndex &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>        &#125;<br>        _elements.formIndex(after: <span class="hljs-operator">&amp;</span>_position)<br>        <span class="hljs-keyword">return</span> _elements[_position]<br>    &#125;<br>    <span class="hljs-keyword">var</span> _elements: <span class="hljs-type">C</span><br>    <span class="hljs-keyword">var</span> _position: <span class="hljs-type">C</span>.<span class="hljs-type">Index</span><br>&#125;<br><br><span class="hljs-keyword">extension</span> <span class="hljs-title class_">Collection</span> &#123;<br>    <span class="hljs-keyword">public</span> __consuming <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">IndexingIterator</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">IndexingIterator</span>(_elements: <span class="hljs-keyword">self</span>, _position: startIndex)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，**<code>IteratorProtocol</code>** 协议定义了一个 <strong><code>next()</code></strong> 方法，返回一个关联类型 <strong><code>Element</code><strong>。</strong><code>Sequence</code></strong> 协议定义了一个关联类型 <strong><code>Iterator</code><strong>，并且定义了一个 <strong><code>makeIterator()</code></strong> 方法，返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象。</strong><code>IndexingIterator</code></strong> 结构体实现了 <strong><code>IteratorProtocol</code></strong> 协议，并使用泛型参数 <strong><code>C</code></strong> 限定了 <strong><code>next()</code></strong> 方法返回值的类型。在 <strong><code>IndexingIterator</code></strong> 结构体中，**<code>next()</code>** 方法的实现使用了 Swift 的集合（Collection）特性，可以逐个返回集合中的元素。在 <strong><code>Collection</code></strong> 扩展中，**<code>makeIterator()</code>** 方法的实现返回了一个 <strong><code>IndexingIterator</code></strong> 类型的迭代器对象。</p><p>总的来说，Swift 标准库中实现 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的原理是利用了 Swift 的生成器和闭包特性。生成器函数可以逐个返回序列中的元素，并在返回元素时保存状态，以便下一次调用 <strong><code>next()</code></strong> 方法时可以从上次离开的地方继续执行。序列对象调用 <strong><code>makeIterator()</code></strong> 方法时，该方法会返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象，该迭代器对象实际上就是由序列对象中的生成器函数来实现的。</p><p>由于 Swift 的生成器函数和闭包特性，实现迭代器非常简单，而且非常灵活。开发者可以根据自己的需求来编写生成器函数，实现自定义的迭代器。同时，Swift 标准库中提供了很多符合 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的数据结构，如数组、字典、集合等，可以直接使用这些数据结构提供的迭代器，方便开发者的编程工作。</p><h3 id="5-职责链模式（Chain-of-Responsibility-Pattern）"><a href="#5-职责链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="5. 职责链模式（Chain of Responsibility Pattern）"></a>5. 职责链模式（Chain of Responsibility Pattern）</h3><p>职责链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它将多个对象组成一条链，依次处理某个请求，直到请求被处理完成为止。</p><p>职责链模式常用于处理多个对象之间的协作关系，例如在一个复杂的系统中，需要处理多种请求，每种请求都需要经过多个处理步骤才能最终得到处理结果。这时候，可以将这些处理步骤封装到不同的对象中，组成一条职责链，每个对象只负责处理自己能够处理的请求，并将请求传递给下一个对象，直到请求被处理完成为止。</p><p>下面是一个使用 Swift 5 实现职责链模式的例子。假设有一个购买请求需要经过三个处理步骤才能最终得到处理结果，其中第一个处理步骤可以处理最低价格的购买请求，第二个处理步骤可以处理大于 100 元的购买请求，第三个处理步骤可以处理任意购买请求。</p><p>首先，我们定义一个请求类型 **<code>PurchaseRequest</code>**，用于表示购买请求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PurchaseRequest</span> &#123;<br>    <span class="hljs-keyword">let</span> amount: <span class="hljs-type">Double</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们定义一个抽象处理器 **<code>PurchaseHandler</code>**，用于表示购买请求处理器，该处理器包含一个指向下一个处理器的引用，并且提供一个处理请求的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">PurchaseHandler</span> &#123;<br>    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>? &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们实现具体的处理器。首先是第一个处理步骤的处理器，用于处理最低价格的购买请求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowestPriceHandler</span>: <span class="hljs-title class_">PurchaseHandler</span> &#123;<br>    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>?<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>) &#123;<br>        <span class="hljs-keyword">if</span> request.amount <span class="hljs-operator">&lt;=</span> <span class="hljs-number">10</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LowestPriceHandler: Purchase request for $<span class="hljs-subst">\(request.amount)</span> approved&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nextHandler<span class="hljs-operator">?</span>.handle(request: request)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是第二个处理步骤的处理器，用于处理大于 100 元的购买请求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighPriceHandler</span>: <span class="hljs-title class_">PurchaseHandler</span> &#123;<br>    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>?<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>) &#123;<br>        <span class="hljs-keyword">if</span> request.amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> &#123;<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;HighPriceHandler: Purchase request for $<span class="hljs-subst">\(request.amount)</span> approved&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nextHandler<span class="hljs-operator">?</span>.handle(request: request)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是第三个处理步骤的处理器，用于处理任意购买请求：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneralPriceHandler</span>: <span class="hljs-title class_">PurchaseHandler</span> &#123;<br>    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>?<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;GeneralPriceHandler: Purchase request for $<span class="hljs-subst">\(request.amount)</span> approved&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以将这三个处理器组成一条职责链：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> lowestPriceHandler <span class="hljs-operator">=</span> <span class="hljs-type">LowestPriceHandler</span>()<br><span class="hljs-keyword">let</span> highPriceHandler <span class="hljs-operator">=</span> <span class="hljs-type">HighPriceHandler</span>()<br><span class="hljs-keyword">let</span> generalPriceHandler <span class="hljs-operator">=</span> <span class="hljs-type">GeneralPriceHandler</span>()<br><br>lowestPriceHandler.nextHandler <span class="hljs-operator">=</span> highPriceHandler<br>highPriceHandler.nextHandler <span class="hljs-operator">=</span> generalPriceHandler<br></code></pre></td></tr></table></figure><p>这样，当有一个购买请求时，我们只需要将其传递给第一个处理器即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> purchaseRequest <span class="hljs-operator">=</span> <span class="hljs-type">PurchaseRequest</span>(amount: <span class="hljs-number">5</span>)<br>lowestPriceHandler.handle(request: purchaseRequest)<br><br><span class="hljs-keyword">let</span> purchaseRequest2 <span class="hljs-operator">=</span> <span class="hljs-type">PurchaseRequest</span>(amount: <span class="hljs-number">50</span>)<br>lowestPriceHandler.handle(request: purchaseRequest2)<br><br><span class="hljs-keyword">let</span> purchaseRequest3 <span class="hljs-operator">=</span> <span class="hljs-type">PurchaseRequest</span>(amount: <span class="hljs-number">200</span>)<br>lowestPriceHandler.handle(request: purchaseRequest3)<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">LowestPriceHandler</span>: <span class="hljs-type">Purchase</span> request <span class="hljs-keyword">for</span> <span class="hljs-variable">$5</span>.<span class="hljs-number">0</span> approved<br><span class="hljs-type">LowestPriceHandler</span>: <span class="hljs-type">Purchase</span> request <span class="hljs-keyword">for</span> <span class="hljs-variable">$50</span>.<span class="hljs-number">0</span> approved<br><span class="hljs-type">HighPriceHandler</span>: <span class="hljs-type">Purchase</span> request <span class="hljs-keyword">for</span> <span class="hljs-variable">$200</span>.<span class="hljs-number">0</span> approved<br></code></pre></td></tr></table></figure><p>可以看到，购买请求被依次传递给了职责链中的处理器，并且最终得到了处理结果。</p><p>在这个例子中，职责链模式将多个处理步骤组合成一条链，使得每个处理步骤只需要关注自己能够处理的请求，而不需要关注整个处理过程，从而提高了代码的可扩展性和可维护性。</p><h3 id="6-命令模式（Command-Pattern）"><a href="#6-命令模式（Command-Pattern）" class="headerlink" title="6. 命令模式（Command Pattern）"></a>6. 命令模式（Command Pattern）</h3><p>命令模式是一种行为设计模式，它将请求和接收者封装在独立的对象中，从而使你能够将请求参数化、将请求放入队列或记录请求日志，以及支持可撤销的操作。</p><p>命令模式常用来解决在软件开发中，需要对一些对象进行一系列复杂的操作，或者需要在不同的时间对对象进行不同的操作。此时，我们可以将这些操作封装成不同的命令对象，使得操作可以灵活组合，易于扩展和维护。</p><p>下面是一个使用 Swift 5 实现命令模式的简单示例，假设有一个家庭影院，我们需要对其进行一系列操作，包括打开灯光、打开投影仪、打开音响、调整音量等等：</p><ul><li><p>Swift Code</p>  <figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 接收者（Receiver）：家庭影院</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeTheater</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOnLights</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Lights are on&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOffLights</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Lights are off&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOnProjector</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Projector is on&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOffProjector</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Projector is off&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOnStereo</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stereo is on&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOffStereo</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stereo is off&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setVolume</span>(<span class="hljs-params">volume</span>: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Volume is set to <span class="hljs-subst">\(volume)</span>&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 命令（Command）：抽象类</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>()<br>&#125;<br><br><span class="hljs-comment">// 具体命令（ConcreteCommand）：打开灯光</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnLightsCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;<br>        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        homeTheater.turnOnLights()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体命令（ConcreteCommand）：关闭灯光</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOffLightsCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;<br>        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        homeTheater.turnOffLights()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体命令（ConcreteCommand）：打开投影仪</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnProjectorCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;<br>        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        homeTheater.turnOnProjector()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体命令（ConcreteCommand）：关闭投影仪</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOffProjectorCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;<br>        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        homeTheater.turnOffProjector()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 具体命令（ConcreteCommand）：打开音响</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnStereoCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;<br>        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater<br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>homeTheater.turnOnStereo()<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 具体命令（ConcreteCommand）：关闭音响</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOffStereoCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;<br>        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater<br>&#125;<br><br><span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>homeTheater.turnOffStereo()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>当我们使用命令模式时，我们通常会实现一个命令接口来封装每个具体的命令，这个命令接口通常至少包括一个 <strong><code>execute()</code></strong> 方法来执行命令。</p><p>下面是一个使用命令模式的示例，假设我们有一个简单的文本编辑器，用户可以执行一些基本的操作，例如打开文件、保存文件、撤销操作、重做操作等。我们可以使用命令模式来实现这些操作：</p><p>首先，我们定义一个 <strong><code>Command</code></strong> 接口，用于封装所有的命令：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们定义几个具体的命令，例如 <strong><code>OpenFileCommand</code><strong>、</strong><code>SaveFileCommand</code><strong>、</strong><code>UndoCommand</code></strong> 和 **<code>RedoCommand</code>**：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenFileCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行打开文件操作&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveFileCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行保存文件操作&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UndoCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行撤销操作&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedoCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行重做操作&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以将这些命令封装到一个文本编辑器中：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;<br>    <span class="hljs-keyword">var</span> openFileCommand: <span class="hljs-type">Command</span><br>    <span class="hljs-keyword">var</span> saveFileCommand: <span class="hljs-type">Command</span><br>    <span class="hljs-keyword">var</span> undoCommand: <span class="hljs-type">Command</span><br>    <span class="hljs-keyword">var</span> redoCommand: <span class="hljs-type">Command</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">openFileCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">saveFileCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">undoCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">redoCommand</span>: <span class="hljs-type">Command</span>) &#123;<br>        <span class="hljs-keyword">self</span>.openFileCommand <span class="hljs-operator">=</span> openFileCommand<br>        <span class="hljs-keyword">self</span>.saveFileCommand <span class="hljs-operator">=</span> saveFileCommand<br>        <span class="hljs-keyword">self</span>.undoCommand <span class="hljs-operator">=</span> undoCommand<br>        <span class="hljs-keyword">self</span>.redoCommand <span class="hljs-operator">=</span> redoCommand<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">openFile</span>() &#123;<br>        openFileCommand.execute()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveFile</span>() &#123;<br>        saveFileCommand.execute()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>() &#123;<br>        undoCommand.execute()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">redo</span>() &#123;<br>        redoCommand.execute()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们可以使用命令模式来执行这些操作。首先，我们实例化每个具体的命令：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> openFileCommand <span class="hljs-operator">=</span> <span class="hljs-type">OpenFileCommand</span>()<br><span class="hljs-keyword">let</span> saveFileCommand <span class="hljs-operator">=</span> <span class="hljs-type">SaveFileCommand</span>()<br><span class="hljs-keyword">let</span> undoCommand <span class="hljs-operator">=</span> <span class="hljs-type">UndoCommand</span>()<br><span class="hljs-keyword">let</span> redoCommand <span class="hljs-operator">=</span> <span class="hljs-type">RedoCommand</span>()<br></code></pre></td></tr></table></figure><p>然后，我们可以将这些命令传递给一个文本编辑器实例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> textEditor <span class="hljs-operator">=</span> <span class="hljs-type">TextEditor</span>(openFileCommand: openFileCommand, saveFileCommand: saveFileCommand, undoCommand: undoCommand, redoCommand: redoCommand)<br></code></pre></td></tr></table></figure><p>现在，我们可以调用文本编辑器的方法来执行这些操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift">textEditor.openFile()  <span class="hljs-comment">// 输出：执行打开文件操作</span><br>textEditor.saveFile()  <span class="hljs-comment">// 输出：执行保存文件操作</span><br>textEditor.undo()      <span class="hljs-comment">// 输出：执行撤销操作</span><br>textEditor.redo()      <span class="hljs-comment">// 输出：执行重做操作</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们使用命令模式来封装每个操作，并将它们传递给一个文本编辑器实例。这样，我们可以轻松地添加、修改或删除命令，而不需要修改文本编辑</p><p>当调用 <strong><code>execute()</code></strong> 方法时，会调用 <strong><code>receiver</code></strong> 对象的相应方法完成具体的操作。同时，可以通过 <strong><code>undo()</code></strong> 方法实现撤销操作，即撤销 <strong><code>receiver</code></strong> 对象的相应方法的操作。</p><p>下面是一个简单的示例，使用命令模式来实现一个遥控器控制灯的开关。首先，我们定义一个 <strong><code>Light</code></strong> 类来表示灯，并提供开灯和关灯的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">on</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Light is on&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">off</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Light is off&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后，我们定义一个 <strong><code>Command</code></strong> 协议来表示命令：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>()<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们实现具体的命令类，这里有开灯命令和关灯命令：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">let</span> light: <span class="hljs-type">Light</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">light</span>: <span class="hljs-type">Light</span>) &#123;<br>        <span class="hljs-keyword">self</span>.light <span class="hljs-operator">=</span> light<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        light.on()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>() &#123;<br>        light.off()<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOffCommand</span>: <span class="hljs-title class_">Command</span> &#123;<br>    <span class="hljs-keyword">let</span> light: <span class="hljs-type">Light</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">light</span>: <span class="hljs-type">Light</span>) &#123;<br>        <span class="hljs-keyword">self</span>.light <span class="hljs-operator">=</span> light<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;<br>        light.off()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>() &#123;<br>        light.on()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，**<code>LightOnCommand</code>** 和 <strong><code>LightOffCommand</code></strong> 分别实现了 <strong><code>Command</code></strong> 协议，并在 <strong><code>execute()</code></strong> 和 <strong><code>undo()</code></strong> 方法中分别调用了 <strong><code>Light</code></strong> 对象的开灯和关灯方法。</p><p>接下来，我们定义遥控器类，它有四个插槽，每个插槽都可以存放一个命令：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteControl</span> &#123;<br>    <span class="hljs-keyword">var</span> onCommands: [<span class="hljs-type">Command</span>] <span class="hljs-operator">=</span> []<br>    <span class="hljs-keyword">var</span> offCommands: [<span class="hljs-type">Command</span>] <span class="hljs-operator">=</span> []<br><br>    <span class="hljs-keyword">init</span>() &#123;<br>        <span class="hljs-keyword">let</span> noCommand <span class="hljs-operator">=</span> <span class="hljs-type">NoCommand</span>()<br>        <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">4</span> &#123;<br>            onCommands.append(noCommand)<br>            offCommands.append(noCommand)<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setCommand</span>(<span class="hljs-params">slot</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">onCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">offCommand</span>: <span class="hljs-type">Command</span>) &#123;<br>        onCommands[slot] <span class="hljs-operator">=</span> onCommand<br>        offCommands[slot] <span class="hljs-operator">=</span> offCommand<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pressOnButton</span>(<span class="hljs-params">slot</span>: <span class="hljs-type">Int</span>) &#123;<br>        onCommands[slot].execute()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pressOffButton</span>(<span class="hljs-params">slot</span>: <span class="hljs-type">Int</span>) &#123;<br>        offCommands[slot].execute()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pressUndoButton</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Undo button pressed&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，我们使用 <strong><code>NoCommand</code></strong> 类来初始化所有插槽。**<code>setCommand()</code>** 方法用于设置插槽中的命令，**<code>pressOnButton()</code>** 和 <strong><code>pressOffButton()</code></strong> 方法分别用于按下开灯和关灯按钮，**<code>pressUndoButton()</code>** 方法用于实现撤销操作，这里先简单地输出一个信息。</p><p>最后，我们可以测试遥控器了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> remoteControl <span class="hljs-operator">=</span> <span class="hljs-type">RemoteControl</span>()<br><br><span class="hljs-keyword">let</span> livingRoomLight <span class="hljs-operator">=</span> <span class="hljs-type">Light</span>()<br><span class="hljs-keyword">let</span> livingRoomLightOnCommand <span class="hljs-operator">=</span> <span class="hljs-type">LightOnCommand</span>(light: livingRoomLight)<br><span class="hljs-keyword">let</span> livingRoomLightOffCommand <span class="hljs-operator">=</span> <span class="hljs-type">LightOffCommand</span>(light: livingRoomLight)<br><br>remoteControl.setCommand(slot: <span class="hljs-number">0</span>, onCommand: livingRoomLightOnCommand, offCommand:livingRoomLightOffCommand)<br>remoteControl.pressOnButton(slot:<span class="hljs-number">0</span>)<br>remoteControl.pressOffButton(slot:<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>在上面的实现中，我们创建了三个具体命令 <strong><code>LightOnCommand</code><strong>、</strong><code>LightOffCommand</code></strong> 和 **<code>StereoOnWithCDCommand</code>**。每个命令对象都持有了一个接收者对象，并实现了 <strong><code>Command</code></strong> 协议的 <strong><code>execute</code></strong> 方法。这个 <strong><code>execute</code></strong> 方法会调用接收者的相关方法来实现具体的命令操作。</p><p>我们还创建了一个遥控器对象 **<code>RemoteControl</code>**，这个遥控器对象持有了一系列的命令对象。通过 <strong><code>setCommand</code></strong> 方法，我们可以给遥控器设置不同的命令，同时通过 <strong><code>buttonWasPressed</code></strong> 方法，我们可以执行遥控器当前所持有的命令对象。</p><p>这样，在实际的应用场景中，我们可以通过遥控器对象将具体的命令对象和执行命令的对象进行解耦，从而实现更加灵活的命令操作。</p><h3 id="7-备忘录模式（Memento-Pattern）"><a href="#7-备忘录模式（Memento-Pattern）" class="headerlink" title="7. 备忘录模式（Memento Pattern）"></a>7. 备忘录模式（Memento Pattern）</h3><p>备忘录模式（Memento Pattern）是一种行为设计模式，它允许将对象的状态保存到备忘录中，并在需要时将其还原到先前的状态。备忘录模式的核心思想是提供一个快照对象，用于保存一个对象的内部状态，并将该对象恢复到该状态。</p><p>备忘录模式通常用于以下两种情况中：</p><ol><li>当需要保存和恢复对象状态以进行撤销、重做或历史记录时。</li><li>当直接访问对象的成员变量可能违反封装原则时，备忘录模式可以提供一个间接的访问方式。</li></ol><p>下面是使用 Swift 5 实现备忘录模式的一个例子：</p><p>首先，我们定义一个备忘录类，用于保存需要恢复的对象的状态。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;<br>    <span class="hljs-keyword">let</span> state: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">state</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getState</span>() -&gt; <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> state<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，我们定义一个原始对象类，该类拥有一个状态变量，并且可以将其状态保存到备忘录中。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">state</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveStateToMemento</span>() -&gt; <span class="hljs-type">Memento</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Memento</span>(state: state)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getStateFromMemento</span>(<span class="hljs-params">memento</span>: <span class="hljs-type">Memento</span>) &#123;<br>        state <span class="hljs-operator">=</span> memento.getState()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，我们定义一个管理器类，该类用于保存备忘录列表并提供对它们的访问。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CareTaker</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mementoList: [<span class="hljs-type">Memento</span>] <span class="hljs-operator">=</span> []<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addMemento</span>(<span class="hljs-params">memento</span>: <span class="hljs-type">Memento</span>) &#123;<br>        mementoList.append(memento)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getMemento</span>(<span class="hljs-params">index</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Memento</span> &#123;<br>        <span class="hljs-keyword">return</span> mementoList[index]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个简单的使用备忘录模式的示例，其中我们将对象状态保存到备忘录中，并在需要时将其还原。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 创建一个原始对象</span><br><span class="hljs-keyword">var</span> originator <span class="hljs-operator">=</span> <span class="hljs-type">Originator</span>(state: <span class="hljs-string">&quot;State1&quot;</span>)<br><br><span class="hljs-comment">// 创建一个管理器对象</span><br><span class="hljs-keyword">var</span> careTaker <span class="hljs-operator">=</span> <span class="hljs-type">CareTaker</span>()<br><br><span class="hljs-comment">// 将原始对象的状态保存到备忘录中</span><br>careTaker.addMemento(memento: originator.saveStateToMemento())<br><br><span class="hljs-comment">// 修改原始对象的状态</span><br>originator.setState(state: <span class="hljs-string">&quot;State2&quot;</span>)<br><br><span class="hljs-comment">// 从备忘录中恢复原始对象的状态</span><br>originator.getStateFromMemento(memento: careTaker.getMemento(index: <span class="hljs-number">0</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Current State: <span class="hljs-subst">\(originator.getState())</span>&quot;</span>) <span class="hljs-comment">// 输出 &quot;Current State: State1&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用备忘录模式将原始对象的状态保存到备忘录中，并在需要时将其还原。这样，我们就可以轻松地实现撤销、重做或历史记录等功能。</p><h3 id="8-状态模式（State-Pattern）"><a href="#8-状态模式（State-Pattern）" class="headerlink" title="8. 状态模式（State Pattern）"></a>8. 状态模式（State Pattern）</h3><p>状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变其行为。该模式主要解决对象状态转换的问题，使得在状态发生改变时，对象可以自动改变行为。</p><p>状态模式包含三个主要角色：上下文（Context）、抽象状态（State）和具体状态（Concrete State）。上下文负责维护状态，并将请求转发给当前状态对象，而抽象状态定义一个接口，用于表示状态，并在状态发生改变时通知上下文，具体状态则实现抽象状态定义的接口，并处理上下文发来的请求。</p><p>使用状态模式可以使代码更加可维护和可扩展，因为状态转换的逻辑被封装在状态类中，而不是分散在上下文中，从而使得状态类可以独立变化而不会影响到上下文。</p><p>下面是一个使用 Swift 5 实现状态模式的示例代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 定义抽象状态</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义具体状态 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateA</span>: <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前状态是 A&quot;</span>)<br>        context.setState(state: <span class="hljs-type">ConcreteStateB</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体状态 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateB</span>: <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前状态是 B&quot;</span>)<br>        context.setState(state: <span class="hljs-type">ConcreteStateA</span>())<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义上下文</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">state</span>: <span class="hljs-type">State</span>) &#123;<br>        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>: <span class="hljs-type">State</span>) &#123;<br>        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">request</span>() &#123;<br>        state.handle(context: <span class="hljs-keyword">self</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">let</span> context <span class="hljs-operator">=</span> <span class="hljs-type">Context</span>(state: <span class="hljs-type">ConcreteStateA</span>())<br>context.request()<br>context.request()<br>context.request()<br></code></pre></td></tr></table></figure><p>在上面的代码中，抽象状态被定义为 <strong><code>State</code></strong> 协议，其中包含一个 <strong><code>handle</code></strong> 方法用于处理请求并改变上下文状态。具体状态 <strong><code>ConcreteStateA</code></strong> 和 <strong><code>ConcreteStateB</code></strong> 实现了 <strong><code>State</code></strong> 协议，并分别处理不同的请求，并将上下文状态设置为另一个具体状态。上下文类 <strong><code>Context</code></strong> 维护当前状态并将请求转发给当前状态来处理。最后，在测试代码中，上下文被初始化为 **<code>ConcreteStateA</code>**，并连续进行了三次请求，每次请求后状态都会发生改变。</p><h3 id="9-访问者模式（Visitor-Pattern）"><a href="#9-访问者模式（Visitor-Pattern）" class="headerlink" title="9. 访问者模式（Visitor Pattern）"></a>9. 访问者模式（Visitor Pattern）</h3><p>访问者模式（Visitor Pattern）是一种行为型设计模式，用于将算法与对象结构分离。该模式将算法定义在访问者中，让访问者能够访问并处理对象结构中的各个元素，而不需要修改这些元素的类定义。因此，该模式可以使得算法与对象结构相互独立，并且可以轻松添加新的算法而不会影响对象结构。</p><p>访问者模式包含四个主要角色：访问者（Visitor）、具体访问者（Concrete Visitor）、元素（Element）和具体元素（Concrete Element）。访问者定义了访问元素的方法，具体访问者实现了访问方法，并包含了针对不同元素的具体算法，元素定义了接受访问者访问的方法，具体元素实现了元素的特定行为，并在接受访问者访问时调用访问者的方法。</p><p>使用访问者模式可以将算法与对象结构分离，从而使得算法可以更容易地扩展和变化，并且可以方便地添加新的算法，而不需要修改对象结构。访问者模式通常用于解决对象结构比较稳定，但是需要频繁变化的算法的问题。</p><p>下面是一个使用 Swift 5 实现访问者模式的示例代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 定义元素接口</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>: <span class="hljs-type">Visitor</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义具体元素 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementA</span>: <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>: <span class="hljs-type">Visitor</span>) &#123;<br>        visitor.visit(element: <span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationA</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteElementA operationA&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体元素 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementB</span>: <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>: <span class="hljs-type">Visitor</span>) &#123;<br>        visitor.visit(element: <span class="hljs-keyword">self</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationB</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteElementB operationB&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义访问者接口</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementA</span>)<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementB</span>)<br>&#125;<br><br><span class="hljs-comment">// 定义具体访问者 A</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitorA</span>: <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementA</span>) &#123;<br>        element.operationA()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementB</span>) &#123;<br>        element.operationB()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体访问者 B</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitorB</span>: <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementA</span>) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteVisitorB visit ConcreteElementA&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementB</span>) &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteVisitorB visit ConcreteElementB&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 测试代码</span><br><span class="hljs-keyword">let</span> elements: [<span class="hljs-type">Element</span>] <span class="hljs-operator">=</span> [<span class="hljs-type">ConcreteElementA</span>(), <span class="hljs-type">ConcreteElementB</span>()]<br><span class="hljs-keyword">let</span> visitorA <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteVisitorA</span>()<br><span class="hljs-keyword">let</span> visitorB <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteVisitorB</span>()<br><br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> elements &#123;<br>    element.accept(visitor: visitorA)<br>    element.accept(visitor: visitorB)<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，元素被定义为 <strong><code>Element</code></strong> 协议，其中包含一个接受访问者访问方法。具体元素 <strong><code>ConcreteElementA</code></strong> 和 <strong><code>ConcreteElementB</code></strong> 实现了 <strong><code>Element</code></strong> 接口，并在接受访问者访问时调用访问者的访问方法。</p><p>访问者被定义为 <strong><code>Visitor</code></strong> 接口，其中包含针对具体元素的访问方法。具体访问者 <strong><code>ConcreteVisitorA</code></strong> 和 <strong><code>ConcreteVisitorB</code></strong> 实现了 <strong><code>Visitor</code></strong> 接口，并分别实现了访问具体元素的具体算法。</p><p>在测试代码中，创建了两个具体访问者 <strong><code>visitorA</code></strong> 和 **<code>visitorB</code>**，以及两个元素 <strong><code>ConcreteElementA</code></strong> 和 **<code>ConcreteElementB</code>**。遍历元素数组，分别调用元素的 <strong><code>accept</code></strong> 方法，接受访问者的访问。在访问过程中，具体元素会调用访问者的访问方法，从而实现了算法与对象结构的分离。</p><p>总的来说，访问者模式可以让算法与对象结构相互独立，并且可以轻松添加新的算法而不会影响对象结构。该模式通常用于解决对象结构比较稳定，但是需要频繁变化的算法的问题。</p><h3 id="10-中介者模式（Mediator-Pattern）"><a href="#10-中介者模式（Mediator-Pattern）" class="headerlink" title="10. 中介者模式（Mediator Pattern）"></a>10. 中介者模式（Mediator Pattern）</h3><p>中介者模式是一种行为型设计模式，它可以通过将对象之间的通信转移给一个中介者对象来降低对象之间的耦合度。中介者模式有时也被称为调停者模式，因为中介者在协调对象之间的交互时，就像一个调停者一样。</p><p>中介者模式通常用于以下场景：</p><ul><li>当一个对象需要与许多其他对象进行通信时，如果这些对象之间的交互非常复杂，那么每个对象都需要了解所有其他对象的细节，这会导致非常复杂和难以维护的代码。使用中介者模式可以将这些交互转移到中介者对象中，从而简化每个对象的职责。</li><li>当多个对象之间的交互会导致复杂的循环依赖关系时，使用中介者模式可以打破这些循环依赖，从而使代码更加可维护和可扩展。</li><li>当一个对象的改变需要通知其他对象时，如果每个对象都需要了解其他对象的细节，那么这种通知机制也会变得非常复杂。使用中介者模式可以将这种通知机制转移到中介者对象中，从而简化代码。</li></ul><p>下面是一个简单的 Swift 5 代码示例，演示了如何使用中介者模式协调多个组件之间的交互。假设我们有一个窗口组件（Window）、一个按钮组件（Button）和一个文本框组件（TextBox），它们都需要与彼此交互。我们可以创建一个中介者对象（Mediator）来协调它们之间的交互，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 中介者</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> window: <span class="hljs-type">Window</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> button: <span class="hljs-type">Button</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> textBox: <span class="hljs-type">TextBox</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">window</span>: <span class="hljs-type">Window</span>, <span class="hljs-params">button</span>: <span class="hljs-type">Button</span>, <span class="hljs-params">textBox</span>: <span class="hljs-type">TextBox</span>) &#123;<br>        <span class="hljs-keyword">self</span>.window <span class="hljs-operator">=</span> window<br>        <span class="hljs-keyword">self</span>.button <span class="hljs-operator">=</span> button<br>        <span class="hljs-keyword">self</span>.textBox <span class="hljs-operator">=</span> textBox<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">buttonClicked</span>() &#123;<br>        textBox.setText(<span class="hljs-string">&quot;Button clicked&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">textBoxChanged</span>() &#123;<br>        <span class="hljs-keyword">if</span> textBox.getText() <span class="hljs-operator">==</span> <span class="hljs-string">&quot;open&quot;</span> &#123;<br>            window.open()<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> textBox.getText() <span class="hljs-operator">==</span> <span class="hljs-string">&quot;close&quot;</span> &#123;<br>            window.close()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 窗口组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">open</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Window opened&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">close</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Window closed&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 按钮组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mediator: <span class="hljs-type">Mediator</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">mediator</span>: <span class="hljs-type">Mediator</span>) &#123;<br>        <span class="hljs-keyword">self</span>.mediator <span class="hljs-operator">=</span> mediator<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">click</span>() &#123;<br>        mediator.buttonClicked()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 文本框组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBox</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mediator: <span class="hljs-type">Mediator</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> text: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">mediator</span>: <span class="hljs-type">Mediator</span>) &#123;<br>        <span class="hljs-keyword">self</span>.mediator <span class="hljs-operator">=</span> mediator<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setText</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">text</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.text <span class="hljs-operator">=</span> text<br>        mediator.textBoxChanged()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getText</span>() -&gt; <span class="hljs-type">String</span> &#123;<br>        <span class="hljs-keyword">return</span> text<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，中介者对象包含对窗口、按钮和文本框对象的引用。当按钮被点击时，它会调用中介者对象的 <strong><code>buttonClicked()</code></strong> 方法，中介者对象在收到这个消息后会将文本框的文本设置为“Button clicked”。当文本框的文本改变时，它会调用中介者对象的 <strong><code>textBoxChanged()</code></strong> 方法，中介者对象根据文本框的内容来打开或关闭窗口。</p><p>按钮和文本框对象都包含对中介者对象的引用。当按钮被点击时，它会调用中介者对象的 <strong><code>buttonClicked()</code></strong> 方法，从而触发文本框的文本改变。当文本框的文本改变时，它会调用中介者对象的 <strong><code>textBoxChanged()</code></strong> 方法，从而打开或关闭窗口。</p><p>这个例子演示了如何使用中介者模式来协调多个组件之间的交互，从而降低它们之间的耦合度。中介者模式可以帮助我们编写更加模块化、可维护和可扩展的代码。</p><h3 id="11-解释器模式（Interpreter-Pattern）"><a href="#11-解释器模式（Interpreter-Pattern）" class="headerlink" title="11. 解释器模式（Interpreter Pattern）"></a>11. 解释器模式（Interpreter Pattern）</h3><p>解释器模式是一种行为型设计模式，它定义了一种语言，用于表示特定问题领域的语法规则，并提供了一种方式来解释这种语言中的语句。通过使用解释器模式，我们可以将一个问题转换为一个表达式，然后使用这个表达式来解决问题。</p><p>解释器模式通常用于以下场景：</p><ul><li>当我们需要解决某个特定领域的问题时，比如数学、逻辑、日期等，可以使用解释器模式来定义这个领域的语法规则，并提供一种方式来解释这些规则。</li><li>当我们需要实现一种简单的语言解释器时，可以使用解释器模式来定义这个语言的语法规则，并提供一种方式来解释这些规则。</li><li>当我们需要根据特定的规则生成表达式时，可以使用解释器模式来实现这个功能。</li></ul><p>下面是一个简单的 Swift 5 代码示例，演示了如何使用解释器模式来解释简单的数学表达式。假设我们有一些简单的数学表达式，比如“1 + 2 + 3”，“1 - 2 + 3”等，我们可以定义一个解释器对象（Interpreter），来解释这些表达式，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 解释器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Interpreter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> expression: <span class="hljs-type">Expression</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">expression</span>: <span class="hljs-type">Expression</span>) &#123;<br>        <span class="hljs-keyword">self</span>.expression <span class="hljs-operator">=</span> expression<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> expression.interpret()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 表达式</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span><br>&#125;<br><br><span class="hljs-comment">// 数字表达式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberExpression</span>: <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">value</span>: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> value<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> value<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 加法表达式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddExpression</span>: <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> leftExpression: <span class="hljs-type">Expression</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> rightExpression: <span class="hljs-type">Expression</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">leftExpression</span>: <span class="hljs-type">Expression</span>, <span class="hljs-params">rightExpression</span>: <span class="hljs-type">Expression</span>) &#123;<br>        <span class="hljs-keyword">self</span>.leftExpression <span class="hljs-operator">=</span> leftExpression<br>        <span class="hljs-keyword">self</span>.rightExpression <span class="hljs-operator">=</span> rightExpression<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> leftExpression.interpret() <span class="hljs-operator">+</span> rightExpression.interpret()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 减法表达式</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubtractExpression</span>: <span class="hljs-title class_">Expression</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> leftExpression: <span class="hljs-type">Expression</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> rightExpression: <span class="hljs-type">Expression</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">leftExpression</span>: <span class="hljs-type">Expression</span>, <span class="hljs-params">rightExpression</span>: <span class="hljs-type">Expression</span>) &#123;<br>        <span class="hljs-keyword">self</span>.leftExpression <span class="hljs-operator">=</span> leftExpression<br>        <span class="hljs-keyword">self</span>.rightExpression <span class="hljs-operator">=</span> rightExpression<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;<br>        <span class="hljs-keyword">return</span> leftExpression.interpret() <span class="hljs-operator">-</span> rightExpression.interpret()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了一个解释器对象（Interpreter），它包含一个表达式对象（Expression）。我们还定义了三个不同的表达式类型：数字表达式（NumberExpression）、加法表达式（AddExpression）和减法表达式（SubtractExpression）。</p><p>数字表达式表示一个简单的数字，例如“1”或“2”。加法表达式和减法表达式分别表示加法和减法运算。它们都包含左表达式和右表达式，这些表达式都可以是数字表达式或其他的加法&#x2F;减法表达式。这些表达式实现了一个 <strong><code>interpret()</code></strong> 方法，用于解释表达式，并返回表达式的计算结果。</p><p>现在我们可以使用这些表达式和解释器来解释数学表达式了。例如，我们可以解释一个简单的数学表达式“1 + 2 + 3”，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> expression <span class="hljs-operator">=</span> <span class="hljs-type">AddExpression</span>(<br>    leftExpression: <span class="hljs-type">AddExpression</span>(<br>        leftExpression: <span class="hljs-type">NumberExpression</span>(value: <span class="hljs-number">1</span>),<br>        rightExpression: <span class="hljs-type">NumberExpression</span>(value: <span class="hljs-number">2</span>)<br>    ),<br>    rightExpression: <span class="hljs-type">NumberExpression</span>(value: <span class="hljs-number">3</span>)<br>)<br><br><span class="hljs-keyword">let</span> interpreter <span class="hljs-operator">=</span> <span class="hljs-type">Interpreter</span>(expression: expression)<br><span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> interpreter.interpret()<br><br><span class="hljs-built_in">print</span>(result) <span class="hljs-comment">// Output: 6</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们首先创建了一个加法表达式对象，它由三个数字表达式组成，表示一个简单的加法表达式“1 + 2 + 3”。然后我们创建了一个解释器对象，并传入这个加法表达式对象。最后，我们调用解释器对象的 <strong><code>interpret()</code></strong> 方法，得到这个表达式的计算结果，并将其打印出来。</p><p>解释器模式虽然能够解决一些特定问题领域的语法解析问题，但是在实际开发中使用较少，因为其实现和使用比较复杂。通常情况下，我们可以使用其他的方式来解决类似的问题，比如使用正则表达式或特定的库来解析文本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用开发原则</title>
    <link href="/2023/02/25/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/"/>
    <url>/2023/02/25/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="常用开发原则"><a href="#常用开发原则" class="headerlink" title="常用开发原则"></a>常用开发原则</h2><h3 id="1-单一职责原则（Single-Responsibility-Principle，SRP）"><a href="#1-单一职责原则（Single-Responsibility-Principle，SRP）" class="headerlink" title="1. 单一职责原则（Single Responsibility Principle，SRP）"></a>1. 单一职责原则（Single Responsibility Principle，SRP）</h3><p>单一职责原则（Single Responsibility Principle，SRP）是面向对象设计中的一项基本原则，它指出一个类或模块应该只有一个职责或责任，即一个类或模块应该只负责一种功能或行为。</p><p>单一职责原则的目的是将复杂的系统分解为多个简单的组件，每个组件都只关注一个特定的功能或职责，从而使系统更加灵活、可扩展和易于维护。当一个类或模块承担了多种职责时，它就变得复杂、难以维护和扩展，因为修改其中一个职责可能会影响到其他职责。</p><p>单一职责原则常用来解决以下问题：</p><ul><li>类或模块过于庞大，难以维护和理解；</li><li>类或模块承担了过多的职责，难以扩展和重用；</li><li>修改一个职责会影响到其他职责，导致系统出现不稳定的行为。</li></ul><p>下面是一个使用 Swift 5 实现单一职责原则的示例。我们有一个 <strong><code>Order</code></strong> 类，用于表示客户订单，其中包含了订单的详细信息以及订单的处理方法。我们可以将 <strong><code>Order</code></strong> 类拆分成两个类，一个用于表示订单信息，另一个用于处理订单，从而使其符合单一职责原则。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 订单信息类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderInfo</span> &#123;<br>    <span class="hljs-keyword">let</span> orderId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> customerName: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> orderDate: <span class="hljs-type">Date</span><br>    <span class="hljs-keyword">let</span> orderItems: [<span class="hljs-type">OrderItem</span>]<br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">orderId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">customerName</span>: <span class="hljs-type">String</span>, <span class="hljs-params">orderDate</span>: <span class="hljs-type">Date</span>, <span class="hljs-params">orderItems</span>: [<span class="hljs-type">OrderItem</span>]) &#123;<br>        <span class="hljs-keyword">self</span>.orderId <span class="hljs-operator">=</span> orderId<br>        <span class="hljs-keyword">self</span>.customerName <span class="hljs-operator">=</span> customerName<br>        <span class="hljs-keyword">self</span>.orderDate <span class="hljs-operator">=</span> orderDate<br>        <span class="hljs-keyword">self</span>.orderItems <span class="hljs-operator">=</span> orderItems<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 订单处理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">order</span>: <span class="hljs-type">OrderInfo</span>) &#123;<br>        <span class="hljs-comment">// 处理订单逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们将 <strong><code>Order</code></strong> 类拆分成了 <strong><code>OrderInfo</code></strong> 和 <strong><code>OrderProcessor</code></strong> 两个类。**<code>OrderInfo</code>** 类用于表示订单的详细信息，包括订单编号、客户名称、下单日期和订单项；**<code>OrderProcessor</code>** 类用于处理订单，包括处理订单的逻辑和实现。</p><p>通过将 <strong><code>Order</code></strong> 类拆分成多个类，我们遵守了单一职责原则，使每个类只关注一种特定的功能或职责。这样，如果我们需要修改订单处理逻辑，就不会影响到订单信息的表示和存储，从而使系统更加稳定和易于维护。</p><h3 id="2-开放封闭原则（Open-x2F-Closed-Principle，OCP）"><a href="#2-开放封闭原则（Open-x2F-Closed-Principle，OCP）" class="headerlink" title="2. 开放封闭原则（Open&#x2F;Closed Principle，OCP）"></a>2. 开放封闭原则（Open&#x2F;Closed Principle，OCP）</h3><p>开放封闭原则（Open&#x2F;Closed Principle，OCP）是面向对象设计中的一项基本原则，它指出一个软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着在不修改原有代码的情况下，可以通过扩展代码的行为来实现新的功能。</p><p>开放封闭原则的目的是保持系统的稳定性和可维护性。当系统需要修改现有代码来添加新的功能时，可能会导致系统出现不稳定的行为和意外的副作用。通过遵守开放封闭原则，我们可以避免这些问题，同时使系统更加灵活和易于扩展。</p><p>开放封闭原则常用来解决以下问题：</p><ul><li>当需要添加新的功能时，不希望修改现有的代码；</li><li>当需要修改现有的代码时，不希望影响到系统的稳定性和可维护性。</li></ul><p>下面是一个使用 Swift 5 实现开放封闭原则的示例。我们有一个 <strong><code>OrderProcessor</code></strong> 类，用于处理客户订单，其中包含了订单的详细信息以及订单的处理方法。我们希望能够通过添加新的支付方式来扩展订单处理逻辑，同时不影响现有的代码。为了实现这个目标，我们可以将支付逻辑封装到一个单独的类中，从而使其可以独立扩展和修改。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 订单信息类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderInfo</span> &#123;<br>    <span class="hljs-keyword">let</span> orderId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> customerName: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">let</span> orderDate: <span class="hljs-type">Date</span><br>    <span class="hljs-keyword">let</span> orderItems: [<span class="hljs-type">OrderItem</span>]<br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">orderId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">customerName</span>: <span class="hljs-type">String</span>, <span class="hljs-params">orderDate</span>: <span class="hljs-type">Date</span>, <span class="hljs-params">orderItems</span>: [<span class="hljs-type">OrderItem</span>]) &#123;<br>        <span class="hljs-keyword">self</span>.orderId <span class="hljs-operator">=</span> orderId<br>        <span class="hljs-keyword">self</span>.customerName <span class="hljs-operator">=</span> customerName<br>        <span class="hljs-keyword">self</span>.orderDate <span class="hljs-operator">=</span> orderDate<br>        <span class="hljs-keyword">self</span>.orderItems <span class="hljs-operator">=</span> orderItems<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 支付接口</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>)<br>&#125;<br><br><span class="hljs-comment">// 现金支付类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPayment</span>: <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-comment">// 现金支付逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 支付宝支付类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayPayment</span>: <span class="hljs-title class_">Payment</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-comment">// 支付宝支付逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 订单处理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> payment: <span class="hljs-type">Payment</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">payment</span>: <span class="hljs-type">Payment</span>) &#123;<br>        <span class="hljs-keyword">self</span>.payment <span class="hljs-operator">=</span> payment<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">order</span>: <span class="hljs-type">OrderInfo</span>) &#123;<br>        <span class="hljs-comment">// 处理订单逻辑</span><br><br>        <span class="hljs-comment">// 支付订单</span><br>        payment.pay(amount: order.totalAmount)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，我们将支付逻辑封装到了 <strong><code>Payment</code></strong> 接口中，并实现了两个具体的支付类 <strong><code>CashPayment</code></strong> 和 **<code>AlipayPayment</code>**。我们还将支付逻辑注入到了 <strong><code>OrderProcessor</code></strong> 类中，通过传递不同的支付类实现订单处理的扩展和修改。</p><p>通过将支付逻辑封装到一个单独的类中，我们可以在不影响现有代码的情况下，添加新的支付方式和修改支付逻辑，从而实现了开放封闭原则。当需要添加新的支付方式时，我们只需要实现一个新的支付类并注入到 <strong><code>OrderProcessor</code></strong> 中即可，不需要修改现有的代码。</p><p>下面是一个示例代码，用于创建一个现金支付订单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> order <span class="hljs-operator">=</span> <span class="hljs-type">OrderInfo</span>(orderId: <span class="hljs-string">&quot;123456&quot;</span>, customerName: <span class="hljs-string">&quot;张三&quot;</span>, orderDate: <span class="hljs-type">Date</span>(), orderItems: [item1, item2])<br><span class="hljs-keyword">let</span> cashPayment <span class="hljs-operator">=</span> <span class="hljs-type">CashPayment</span>()<br><span class="hljs-keyword">let</span> orderProcessor <span class="hljs-operator">=</span> <span class="hljs-type">OrderProcessor</span>(payment: cashPayment)<br>orderProcessor.process(order: order)<br></code></pre></td></tr></table></figure><p>我们还可以创建一个支付宝支付订单：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> order <span class="hljs-operator">=</span> <span class="hljs-type">OrderInfo</span>(orderId: <span class="hljs-string">&quot;123456&quot;</span>, customerName: <span class="hljs-string">&quot;张三&quot;</span>, orderDate: <span class="hljs-type">Date</span>(), orderItems: [item1, item2])<br><span class="hljs-keyword">let</span> alipayPayment <span class="hljs-operator">=</span> <span class="hljs-type">AlipayPayment</span>()<br><span class="hljs-keyword">let</span> orderProcessor <span class="hljs-operator">=</span> <span class="hljs-type">OrderProcessor</span>(payment: alipayPayment)<br>orderProcessor.process(order: order)<br></code></pre></td></tr></table></figure><p>通过实现开放封闭原则，我们使系统更加灵活和易于扩展，同时保持了系统的稳定性和可维护性。</p><h3 id="3-里式替换原则（Liskov-Substitution-Principle，LSP）"><a href="#3-里式替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="3. 里式替换原则（Liskov Substitution Principle，LSP）"></a>3. 里式替换原则（Liskov Substitution Principle，LSP）</h3><p>里式替换原则（Liskov Substitution Principle，LSP）是面向对象设计中的一个重要原则，它指出：子类对象应该能够替换掉父类对象并且仍能保持程序的正确性。</p><p>这个原则的核心思想是：子类不应该破坏父类的封装和抽象，即子类中新增的方法和属性不应该影响到父类的行为。LSP可以帮助我们确保代码的正确性和可扩展性，同时也可以避免出现一些难以调试的问题。</p><p>下面，我们以一个简单的 Swift 示例来说明 LSP 的应用。假设我们有一个图形库，其中包含 <strong><code>Shape</code></strong> 基类和两个子类 <strong><code>Rectangle</code></strong> 和 <strong><code>Circle</code><strong>。</strong><code>Shape</code></strong> 类有一个计算面积的方法 <strong><code>calculateArea()</code><strong>，</strong><code>Rectangle</code></strong> 和 <strong><code>Circle</code></strong> 分别实现了这个方法。我们可以使用这些类来创建不同的图形，并计算它们的面积。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">var</span> width: <span class="hljs-type">Double</span><br>    <span class="hljs-keyword">var</span> height: <span class="hljs-type">Double</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">width</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">height</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.width <span class="hljs-operator">=</span> width<br>        <span class="hljs-keyword">self</span>.height <span class="hljs-operator">=</span> height<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">return</span> width <span class="hljs-operator">*</span> height<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Double</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.radius <span class="hljs-operator">=</span> radius<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>.pi <span class="hljs-operator">*</span> radius <span class="hljs-operator">*</span> radius<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们希望在图形库中添加一个新的图形类 **<code>Square</code>**，它是 <strong><code>Rectangle</code></strong> 的一个特例，即它的宽和高相等。按照 LSP 的原则，我们应该可以将 <strong><code>Square</code></strong> 对象替换为 <strong><code>Rectangle</code></strong> 对象而不会影响程序的正确性。</p><p>我们可以创建一个 <strong><code>Square</code></strong> 类继承自 **<code>Rectangle</code>**，并重写父类的初始化方法，确保 <strong><code>width</code></strong> 和 <strong><code>height</code></strong> 始终相等：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>: <span class="hljs-title class_">Rectangle</span> &#123;<br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">side</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(width: side, height: side)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以在创建图形时使用 <strong><code>Square</code></strong> 替换 <strong><code>Rectangle</code></strong> 对象，并调用 <strong><code>calculateArea()</code></strong> 方法计算面积：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> rectangle <span class="hljs-operator">=</span> <span class="hljs-type">Rectangle</span>(width: <span class="hljs-number">4</span>, height: <span class="hljs-number">5</span>)<br><span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(radius: <span class="hljs-number">3</span>)<br><span class="hljs-keyword">let</span> square <span class="hljs-operator">=</span> <span class="hljs-type">Square</span>(side: <span class="hljs-number">4</span>)<br><br><span class="hljs-keyword">let</span> shapes: [<span class="hljs-type">Shape</span>] <span class="hljs-operator">=</span> [rectangle, circle, square]<br><br><span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes &#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Area of <span class="hljs-subst">\(<span class="hljs-built_in">type</span>(of: shape))</span> is <span class="hljs-subst">\(shape.calculateArea())</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">输出结果如下：</code></pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Area</span> of <span class="hljs-type">Rectangle</span> <span class="hljs-keyword">is</span> <span class="hljs-number">20.0</span><br><span class="hljs-type">Area</span> of <span class="hljs-type">Circle</span> <span class="hljs-keyword">is</span> <span class="hljs-number">28.274333882308138</span><br><span class="hljs-type">Area</span> of <span class="hljs-type">Square</span> <span class="hljs-keyword">is</span> <span class="hljs-number">16.0</span><br></code></pre></td></tr></table></figure><p>由于 <strong><code>Square</code></strong> 对象是 <strong><code>Rectangle</code></strong> 的特例，我们可以使用 <strong><code>Square</code></strong> 对象替换 <strong><code>Rectangle</code></strong> 对象而不影响程序的正确性。这就是 LSP 的应用途，通过使用 LSP，我们可以创建更加灵活的代码，可以轻松地添加新的子类，并在不破坏现有代码的情况下进行修改和扩展。</p><p>在实际开发中，为了遵循 LSP 原则，我们需要遵循以下几个准则：</p><ul><li>子类必须实现父类的所有方法，并且方法的输入输出参数类型与父类一致或者更加宽松。</li><li>子类新增的方法和属性不应该影响到父类的行为。</li><li>子类的前置条件（输入参数）不能强于父类的前置条件。</li><li>子类的后置条件（输出参数）不能弱于父类的后置条件。</li></ul><p>下面，我们再以一个 Swift 示例来说明 LSP 的应用。假设我们有一个计算器应用，其中包含一个 <strong><code>Calculator</code></strong> 基类和两个子类 <strong><code>SimpleCalculator</code></strong> 和 <strong><code>ScientificCalculator</code><strong>。</strong><code>Calculator</code></strong> 类有一个计算方法 <strong><code>calculate(_:)</code><strong>，</strong><code>SimpleCalculator</code></strong> 和 <strong><code>ScientificCalculator</code></strong> 分别实现了这个方法。我们可以使用这些类来进行简单的数学计算。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-comment">// 简单计算逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScientificCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-comment">// 科学计算逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们希望添加一个新的子类 **<code>GraphingCalculator</code>**，它可以将计算结果以图表的形式展示出来。按照 LSP 的原则，我们应该可以将 <strong><code>GraphingCalculator</code></strong> 对象替换为 <strong><code>SimpleCalculator</code></strong> 或 <strong><code>ScientificCalculator</code></strong> 对象而不会影响程序的正确性。</p><p>我们可以创建一个 <strong><code>GraphingCalculator</code></strong> 类，它继承自 **<code>Calculator</code>**，并实现 <strong><code>calculate(_:)</code></strong> 方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphingCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">super</span>.calculate(expression)<br>        <span class="hljs-comment">// 将计算结果以图表的形式展示出来</span><br>        <span class="hljs-keyword">return</span> result<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们可以使用 <strong><code>GraphingCalculator</code></strong> 对象来进行数学计算，并将计算结果以图表的形式展示出来：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> simpleCalculator <span class="hljs-operator">=</span> <span class="hljs-type">SimpleCalculator</span>()<br><span class="hljs-keyword">let</span> scientificCalculator <span class="hljs-operator">=</span> <span class="hljs-type">ScientificCalculator</span>()<br><span class="hljs-keyword">let</span> graphingCalculator <span class="hljs-operator">=</span> <span class="hljs-type">GraphingCalculator</span>()<br><br><span class="hljs-keyword">let</span> expressions <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;2 + 2&quot;</span>, <span class="hljs-string">&quot;sin(45)&quot;</span>, <span class="hljs-string">&quot;log(10)&quot;</span>]<br><br><span class="hljs-keyword">for</span> expression <span class="hljs-keyword">in</span> expressions &#123;<br>    <span class="hljs-keyword">let</span> simpleResult <span class="hljs-operator">=</span> simpleCalculator.calculate(expression)<br>    <span class="hljs-keyword">let</span> scientificResult <span class="hljs-operator">=</span> scientificCalculator.calculate(expression)<br>    <span class="hljs-keyword">let</span> graphingResult <span class="hljs-operator">=</span> graphingCalculator.calculate(expression)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Simple: <span class="hljs-subst">\(simpleResult)</span>, Scientific: <span class="hljs-subst">\(scientificResult)</span>, Graphing: <span class="hljs-subst">\(graphingResult)</span>&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-type">Simple</span>: <span class="hljs-number">4.0</span>, <span class="hljs-type">Scientific</span>: <span class="hljs-number">0.8509035245341184</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">4.0</span><br><span class="hljs-type">Simple</span>: <span class="hljs-number">0.8509035245341184</span>,<span class="hljs-type">Scientific</span>: <span class="hljs-number">0.8509035245341184</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">0.8509035245341184</span><br><span class="hljs-type">Simple</span>: <span class="hljs-number">2.302585092994046</span>, <span class="hljs-type">Scientific</span>: <span class="hljs-number">2.302585092994046</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">2.302585092994046</span><br></code></pre></td></tr></table></figure><p>可以看到，我们成功地将 <code>GraphingCalculator</code> 对象替换为 <code>SimpleCalculator</code> 和 <code>ScientificCalculator</code> 对象，而不会影响程序的正确性。这就是 LSP 的优势。</p><p>总之，LSP 是一个非常重要的面向对象编程原则，它可以帮助我们创建灵活、可扩展、易于维护的代码。为了遵循 LSP，我们需要在设计类的时候遵循一些基本的规则，并保证子类可以完全替换父类，而不会影响程序的正确性。</p><h3 id="4-接口隔离原则（Interface-Segregation-Principle，ISP）"><a href="#4-接口隔离原则（Interface-Segregation-Principle，ISP）" class="headerlink" title="4. 接口隔离原则（Interface Segregation Principle，ISP）"></a>4. 接口隔离原则（Interface Segregation Principle，ISP）</h3><p>接口隔离原则（Interface Segregation Principle，ISP）是面向对象编程中的一条原则，它指出“客户端不应该被迫依赖于它不使用的方法”。换句话说，如果一个接口的方法过于冗杂，一个类可能不得不实现一些它并不需要的方法。这不仅浪费了时间和资源，而且会导致代码的复杂性和脆弱性。</p><p>ISP 的主要目的是分离接口，将大型、复杂的接口分解为更小、更简单的接口，以便客户端只需知道与其相关的方法。这样，客户端就不必担心不需要的方法，而只需要专注于与其相关的方法。</p><p>为了遵循 ISP，我们需要在设计接口时考虑到客户端的需要，并将其分解为更小、更简单的接口。这样，客户端只需要依赖它们需要的接口，而不必依赖于整个接口。</p><p>下面是一个使用 ISP 的例子。假设我们正在设计一个图形编辑器，其中有多种形状（如矩形、圆形、三角形等）。每个形状都可以绘制、移动、调整大小等。我们可以将这些操作定义在一个大型的 <strong><code>Shape</code></strong> 接口中，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>()<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">to</span> <span class="hljs-params">point</span>: <span class="hljs-type">CGPoint</span>)<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">to</span> <span class="hljs-params">size</span>: <span class="hljs-type">CGSize</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，如果我们这样设计，那么所有的形状都必须实现所有的方法，即使它们并不需要某些方法。这显然不符合 ISP。为了解决这个问题，我们可以将这个大型接口拆分为多个更小、更专业的接口，如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Drawable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>()<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Movable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">to</span> <span class="hljs-params">point</span>: <span class="hljs-type">CGPoint</span>)<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Resizable</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">to</span> <span class="hljs-params">size</span>: <span class="hljs-type">CGSize</span>)<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Shape</span>: <span class="hljs-title class_">Drawable</span>, <span class="hljs-title class_">Movable</span>, <span class="hljs-title class_">Resizable</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>现在，我们的每个形状只需要实现与其相关的方法。例如，圆形只需要实现 <strong><code>Drawable</code></strong> 和 <strong><code>Resizable</code></strong> 接口，而不需要实现 <strong><code>Movable</code></strong> 接口。这样，我们的代码就更加灵活，易于扩展和维护了。</p><p>总之，ISP 是一个非常重要的面向对象编程原则，它可以帮助我们创建灵活、可扩展、易于维护的代码。为了遵循 ISP，我们需要在设计接口时考虑客户端的需要，并将其拆分为更小、更简单的接口。</p><h3 id="5-迪米特法则（Law-of-Demeter，LoD）"><a href="#5-迪米特法则（Law-of-Demeter，LoD）" class="headerlink" title="5. 迪米特法则（Law of Demeter，LoD）"></a>5. 迪米特法则（Law of Demeter，LoD）</h3><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Principle of Least Knowledge），是面向对象编程中的一条设计原则，它强调一个对象应该尽可能少地了解其他对象，并且只和它们的直接朋友（成员变量、方法参数等）通信，而不与非直接朋友进行通信。</p><p>迪米特法则的目的是减少类之间的耦合度，提高系统的稳定性、可维护性和可扩展性。当一个类依赖的其他类太多时，如果这些依赖的类发生了改变，就会对该类产生较大的影响，从而导致代码的复杂度增加。因此，遵循迪米特法则可以使得类之间的耦合度降低，从而使得代码更加模块化、易于维护和重构。</p><p>下面以 Swift 5 代码举例，展示如何使用迪米特法则来减少类之间的耦合度。假设我们有一个订单类，它需要依赖客户类和商品类来进行处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">var</span> customerId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> productId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> quantity: <span class="hljs-type">Int</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">productId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">quantity</span>: <span class="hljs-type">Int</span>) &#123;<br>        <span class="hljs-keyword">self</span>.customerId <span class="hljs-operator">=</span> customerId<br>        <span class="hljs-keyword">self</span>.productId <span class="hljs-operator">=</span> productId<br>        <span class="hljs-keyword">self</span>.quantity <span class="hljs-operator">=</span> quantity<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateTotal</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">let</span> customer <span class="hljs-operator">=</span> <span class="hljs-type">Customer</span>.getCustomerById(customerId: customerId)<br>        <span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> <span class="hljs-type">Product</span>.getProductById(productId: productId)<br>        <span class="hljs-keyword">let</span> totalPrice <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(quantity) <span class="hljs-operator">*</span> product.price<br>        <span class="hljs-keyword">return</span> totalPrice<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span> &#123;<br>        <span class="hljs-comment">// 模拟获取客户对象的过程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Customer</span>(id: customerId, name: <span class="hljs-string">&quot;&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span> &#123;<br>        <span class="hljs-comment">// 模拟获取商品对象的过程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Product</span>(id: productId, name: <span class="hljs-string">&quot;&quot;</span>, price: <span class="hljs-number">0.0</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，订单类依赖了客户类和商品类的静态方法，通过这些静态方法获取了客户对象和商品对象。这种方式违反了迪米特法则，因为订单类不仅需要了解客户类和商品类的接口，还需要了解它们的具体实现细节。</p><p>为了遵循迪米特法则，我们可以通过依赖注入的方式，来减少订单类对客户类和商品类的依赖。下面是修改后的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">CustomerProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerService</span>: <span class="hljs-title class_">CustomerProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span> &#123;<br>        <span class="hljs-comment">// 模拟获取客户对象的过程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Customer</span>(id: customerId, name: <span class="hljs-string">&quot;&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">ProductProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span>: <span class="hljs-title class_">ProductProtocol</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span> &#123;<br>        <span class="hljs-comment">// 模拟获取商品对象的过程</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-type">Product</span>(id: productId, name: <span class="hljs-string">&quot;&quot;</span>, price: <span class="hljs-number">0.0</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;<br>    <span class="hljs-keyword">var</span> customerId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> productId: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> quantity: <span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> customerService: <span class="hljs-type">CustomerProtocol</span><br>    <span class="hljs-keyword">var</span> productService: <span class="hljs-type">ProductProtocol</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">productId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">quantity</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">customerService</span>: <span class="hljs-type">CustomerProtocol</span>, <span class="hljs-params">productService</span>: <span class="hljs-type">ProductProtocol</span>) &#123;<br>        <span class="hljs-keyword">self</span>.customerId <span class="hljs-operator">=</span> customerId<br>        <span class="hljs-keyword">self</span>.productId <span class="hljs-operator">=</span> productId<br>        <span class="hljs-keyword">self</span>.quantity <span class="hljs-operator">=</span> quantity<br>        <span class="hljs-keyword">self</span>.customerService <span class="hljs-operator">=</span> customerService<br>        <span class="hljs-keyword">self</span>.productService <span class="hljs-operator">=</span> productService<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateTotal</span>() -&gt; <span class="hljs-type">Double</span> &#123;<br>        <span class="hljs-keyword">let</span> customer <span class="hljs-operator">=</span> customerService.getCustomerById(customerId: customerId)<br>        <span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> productService.getProductById(productId: productId)<br>        <span class="hljs-keyword">let</span> totalPrice <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(quantity) <span class="hljs-operator">*</span> product.price<br>        <span class="hljs-keyword">return</span> totalPrice<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;<br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;<br>        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span><br>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span><br><br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;<br>        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id<br>        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name<br>        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述代码中，我们使用协议和依赖注入的方式来降低订单类对客户类和商品类的耦合度。具体来说，我们定义了两个协议 <code>CustomerProtocol</code> 和 <code>ProductProtocol</code>，分别包含了获取客户对象和商品对象的方法。然后我们实现了两个具体的服务类 <code>CustomerService</code> 和 <code>ProductService</code>，它们分别实现了上述协议中定义的方法，用于提供客户对象和商品对象的获取功能。</p><p>接下来，我们修改了订单类的构造函数，将客户服务对象和商品服务对象作为参数传入。在 calculateTotal 方法中，我们不再直接调用客户类和商品类的静态方法，而是通过客户服务对象和商品服务对象来获取客户对象和商品对象。这样一来，订单类只依赖了客户服务类和商品服务类的接口，而不再依赖它们的具体实现细节，这就遵循了迪米特法则。</p><p>总之，迪米特法则是一条重要的设计原则，它可以帮助我们减少类之间的耦合度，提高系统的稳定性、可维护性和可扩展性。在编写代码时，我们应该尽可能地遵循这个原则，尽量减少类之间的交互，使得每个类的职责更加清晰，代码结构更加简单易懂，从而使得代码更加健壮和可维护。</p><p>需要注意的是，在实际开发中，迪米特法则并不是一个银弹，它并不能解决所有的问题，也不能被简单地应用到所有的场景中。在某些情况下，迪米特法则可能会导致类之间的通信变得复杂，从而降低系统的效率和性能。因此，在应用迪米特法则时，我们需要根据具体的情况来灵活运用，综合考虑各种因素，找到最合适的设计方案。</p><p>“银弹”是一个编程界中的术语，指的是一种能够解决所有问题的神奇解决方案。因此，“迪米特法则并不是一个银弹”意味着迪米特法则并不能解决所有问题，我们需要根据具体情况进行灵活应用和综合考虑。</p><h3 id="6-依赖倒置原则（Dependency-Inversion-Principle，DIP）"><a href="#6-依赖倒置原则（Dependency-Inversion-Principle，DIP）" class="headerlink" title="6. 依赖倒置原则（Dependency Inversion Principle，DIP）"></a>6. 依赖倒置原则（Dependency Inversion Principle，DIP）</h3><p>依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它强调高层模块不应该依赖低层模块，它们都应该依赖于抽象；而抽象不应该依赖于细节，细节应该依赖于抽象。简单来说，就是要面向接口编程，而不是面向实现编程。</p><p>依赖倒置原则的作用是降低模块之间的耦合度，提高代码的灵活性、可扩展性和可维护性。它可以避免在修改一个模块时，对其他模块造成影响，同时也能够方便地进行单元测试和模块重用。</p><p>下面是使用 Swift 5 实现依赖倒置原则的一个示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 定义一个协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>()<br>&#125;<br><br><span class="hljs-comment">// 实现两个类，它们都遵循了 Animal 协议</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>: <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Meow&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Woof&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义一个高层模块，它依赖于 Animal 协议</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalShelter</span> &#123;<br>    <span class="hljs-keyword">var</span> animals: [<span class="hljs-type">Animal</span>] <span class="hljs-operator">=</span> []<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addAnimal</span>(<span class="hljs-params">animal</span>: <span class="hljs-type">Animal</span>) &#123;<br>        animals.append(animal)<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeAllAnimalsSound</span>() &#123;<br>        <span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals &#123;<br>            animal.makeSound()<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在客户端代码中，可以通过向 AnimalShelter 添加不同的 Animal 来实现不同的行为</span><br><span class="hljs-keyword">let</span> animalShelter <span class="hljs-operator">=</span> <span class="hljs-type">AnimalShelter</span>()<br>animalShelter.addAnimal(animal: <span class="hljs-type">Cat</span>())<br>animalShelter.addAnimal(animal: <span class="hljs-type">Dog</span>())<br>animalShelter.makeAllAnimalsSound()<br></code></pre></td></tr></table></figure><p>在上面的示例中，Animal 是一个抽象的概念，Cat 和 Dog 是具体的实现类。AnimalShelter 是一个高层模块，它不依赖于具体的实现类，而是依赖于 Animal 协议。在客户端代码中，可以通过向 AnimalShelter 添加不同的 Animal 来实现不同的行为，而不需要修改 AnimalShelter 类的代码。</p><p>这就是依赖倒置原则的一个实现，它通过引入抽象的概念，降低了 AnimalShelter 和具体实现类之间的耦合度，提高了代码的可扩展性和可维护性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="/2023/02/25/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/02/25/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式是一种创建型设计模式，允许客户端创建一系列相关对象而无需指定其具体类。这种模式提供了一种封装一组具有共同主题的单独工厂而不指定其具体类的方法。</p><p>在 Swift 5 中，我们可以通过定义协议并用其实现类来实现抽象工厂模式。以下是一个基于抽象工厂模式的例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// 定义抽象工厂协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createButton</span>() -&gt; <span class="hljs-type">Button</span><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createTextField</span>() -&gt; <span class="hljs-type">TextField</span><br>&#125;<br><br><span class="hljs-comment">// 定义具体工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory1</span>: <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createButton</span>() -&gt; <span class="hljs-type">Button</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ConcreteButton1</span>()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createTextField</span>() -&gt; <span class="hljs-type">TextField</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ConcreteTextField1</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体工厂类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFactory2</span>: <span class="hljs-title class_">AbstractFactory</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createButton</span>() -&gt; <span class="hljs-type">Button</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ConcreteButton2</span>()<br>    &#125;<br><br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createTextField</span>() -&gt; <span class="hljs-type">TextField</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-type">ConcreteTextField2</span>()<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义抽象产品协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>()<br>&#125;<br><br><span class="hljs-comment">// 定义具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteButton1</span>: <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is Button 1&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteButton2</span>: <span class="hljs-title class_">Button</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is Button 2&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义抽象产品协议</span><br><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">TextField</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>()<br>&#125;<br><br><span class="hljs-comment">// 定义具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteTextField1</span>: <span class="hljs-title class_">TextField</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is Text Field 1&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义具体产品类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteTextField2</span>: <span class="hljs-title class_">TextField</span> &#123;<br>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;This is Text Field 2&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用抽象工厂模式创建对象</span><br><span class="hljs-keyword">let</span> factory1 <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteFactory1</span>()<br><span class="hljs-keyword">let</span> factory2 <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteFactory2</span>()<br><br><span class="hljs-keyword">let</span> button1 <span class="hljs-operator">=</span> factory1.createButton()<br><span class="hljs-keyword">let</span> textField1 <span class="hljs-operator">=</span> factory1.createTextField()<br><br><span class="hljs-keyword">let</span> button2 <span class="hljs-operator">=</span> factory2.createButton()<br><span class="hljs-keyword">let</span> textField2 <span class="hljs-operator">=</span> factory2.createTextField()<br><br>button1.display() <span class="hljs-comment">// Output: This is Button 1</span><br>textField1.display() <span class="hljs-comment">// Output: This is Text Field 1</span><br><br>button2.display() <span class="hljs-comment">// Output: This is Button 2</span><br>textField2.display() <span class="hljs-comment">// Output: This is Text Field 2</span><br><br></code></pre></td></tr></table></figure><p>在上述代码中，我们定义了一个抽象工厂协议 <code>AbstractFactory</code>，并用其实现类 <code>ConcreteFactory1</code> 和 <code>ConcreteFactory2</code> 来创建一系列相关对象。具体产品类 <code>ConcreteButton1</code>、<code>ConcreteButton2</code>、<code>ConcreteTextField1</code> 和 <code>ConcreteTextField2</code> 实现了抽象产品协议 <code>Button</code> 和 <code>TextField</code>，并在具体工厂类中被实例化。通过使用具体工厂类创建产品对象，我们可以无需指定其具体类，从而实现了抽象工厂模式的特性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/02/25/hello-world/"/>
    <url>/2023/02/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
