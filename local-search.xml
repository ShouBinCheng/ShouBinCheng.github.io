<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS 性能优化</title>
    <link href="/2023/02/28/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/02/28/iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-Performance-Optimization"><a href="#iOS-Performance-Optimization" class="headerlink" title="iOS-Performance-Optimization"></a>iOS-Performance-Optimization</h1><p>关于 iOS 性能优化梳理：<br>基本工具、业务优化、内存优化、卡顿优化、电量优化、 安装包瘦身、启动优化、网络优化等</p><h2 id="iOS-官方文档"><a href="#iOS-官方文档" class="headerlink" title="iOS 官方文档"></a>iOS 官方文档</h2><ul><li><a href="https://developer.apple.com/library/content/navigation/#section=Topics&topic=Performance">Performance 专题</a></li></ul><h2 id="iOS-性能优化相关书籍"><a href="#iOS-性能优化相关书籍" class="headerlink" title="iOS 性能优化相关书籍"></a>iOS 性能优化相关书籍</h2><ul><li><a href="http://download.csdn.net/detail/tskyming/9831453">Pro iOS Apps Performance Optimization</a></li><li><a href="http://download.csdn.net/detail/tskyming/9831465">High Performance iOS Apps</a></li></ul><h2 id="Instruments-工具相关"><a href="#Instruments-工具相关" class="headerlink" title="Instruments 工具相关"></a>Instruments 工具相关</h2><ul><li><a href="https://developer.apple.com/library/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/index.html">Instruments User Guide</a> <a href="http://cdn.cocimg.com/bbs/attachment/Fid_6/6_24457_90eabb4ed5b3863.pdf">中文翻译-PDF</a> </li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933485.html">Instruments之Leaks学习</a> </li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933195.html">Instruments学习之Allocations</a> </li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933604.html">instrument之Time Profiler总结</a></li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933364.html">Instruments学习之Core Animation学习</a> </li><li><a href="http://www.cnblogs.com/lxlx1798/p/6933141.html">Instruments之Activity Monitor使用入门</a> </li><li><a href="http://www.jianshu.com/p/9dbbc91c8059">使用Instrument调试界面卡顿</a></li><li><a href="https://github.com/AttackOnDobby/iOS-Core-Animation-Advanced-Techniques/blob/master/12-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.md">Core Animation性能调优</a></li></ul><h2 id="综合篇"><a href="#综合篇" class="headerlink" title="综合篇"></a>综合篇</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2012/235">WWDC2012-235-iOS APP Performance:Responsiveness</a></li><li><a href="http://wereadteam.github.io/2016/05/03/WeRead-Performance/">微信读书iOS性能优化</a></li><li><a href="http://wereadteam.github.io/2016/12/12/Monitor/">微信读书 iOS 质量保证及性能监控</a></li><li><a href="https://ming1016.github.io/2017/06/20/deeply-ios-performance-optimization/">深入剖析 iOS 性能优化</a></li><li><a href="http://blog.csdn.net/magicwindow/article/details/51423463">魔窗研发副总裁沈哲：移动端SDK的优化之路</a></li><li><a href="http://www.cocoachina.com/design/20160905/17483.html">搜狗输入法 iOS 版开发与优化实践</a><a href="https://github.com/MDCC2016/iOS-Session-Slides/blob/master/%E6%90%9C%E7%8B%97%E8%BE%93%E5%85%A5%E6%B3%95%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5-%E6%9D%8E%E8%85%BE%E6%9D%B0.pdf">PPT</a></li><li><a href="http://www.infoq.com/cn/presentations/stability-and-performance-of-mogujie-app">蘑菇街 App 的稳定性与性能实践</a><a href="https://sanwen8.cn/p/6e5c888.html">PPT</a></li><li><a href="http://pstatic.geekbang.org/pdf/593a53d813cef.pdf?e=1497499485&token=eHNJKRTldoRsUX0uCP9M3icEhpbyh3VF9Nrk5UPM:sa-xp_aIeIhtiWbqR-hY4ImMzFc=">⼿淘iOS性能优化探索</a></li><li><a href="https://juejin.im/post/58ca0832a22b9d006418fe43">iOS App 稳定性指标及监测</a></li></ul><h2 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h2><ul><li><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/ManagingMemory/ManagingMemory.html#//apple_ref/doc/uid/10000160i">Memory Usage Performance Guidelines</a> </li><li><a href="https://juejin.im/post/5a5e13c45188257327399e19">探索iOS内存分配</a> </li><li><a href="http://wetest.qq.com/lab/view/367.html?from=content_juejin">iOS微信内存监控</a></li></ul><h2 id="卡顿优化"><a href="#卡顿优化" class="headerlink" title="卡顿优化"></a>卡顿优化</h2><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&idx=1&mid=207890859&scene=23&sn=e98dd604cdb854e7a5808d2072c29162&srcid=0921FzoCw9j1W7n4uFYKuarC#rd">微信iOS卡顿监控系统</a></li><li><a href="http://www.cnblogs.com/gatsbywang/p/5555200.html">iOS-卡顿检测</a></li><li><a href="http://ios.jobbole.com/93085/">iOS监控：卡顿检测</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&mid=2650264136&idx=1&sn=052c1db8131d4bed8458b98e1ec0d5b0&chksm=f406837dc3710a6b49e76ce3639f671373b553e8a91b544e82bb8747e9adc7985fea1093a394#rd">iOS应用UI线程卡顿监控</a></li><li><a href="http://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/">iOS 保持界面流畅的技巧</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzA4MzEwOTkyMQ==&mid=2667379069&idx=1&sn=376d9ef2261cf13e930406f1c35d3569&chksm=84f32833b384a1250ef66f76a8d050216fd3b0bd4ea99b55f4a609cf268c8169ac2889746245&mpshare=1&scene=1&srcid=0810MDXnroCGDhecWqlXazwE&key=05d58d453d781a66b453e3d41dd8d420839dd771948b07f8c8afe3482922901ad13e8c8ab46f48d0883e9b55d304f6ce272854ecc200f68557644581408036c8ee0c5154fbf413a007cd7617b0e086f6&ascene=0&uin=MjY1NTg0NzMyMQ==&devicetype=iMac+MacBookPro11,4+OSX+OSX+10.12.5+build(16F73)&version=12020810&nettype=WIFI&fontScale=100&pass_ticket=OB4hdN6ImVq0WXd+DAJVSADk3OsXMiJH5VzZqXk/7meSbJNPMBTUB2z5/ct+uPmN">实现 60fps 的网易云音乐首页</a> </li><li><a href="http://wetest.qq.com/lab/view/354.html">QQ空间掉帧率优化实战</a></li></ul><h2 id="电量优化"><a href="#电量优化" class="headerlink" title="电量优化"></a>电量优化</h2><ul><li><a href="https://developer.apple.com/library/content/documentation/Performance/Conceptual/EnergyGuide-iOS/index.html#//apple_ref/doc/uid/TP40015243">Guide - Energy Efficiency Guide for iOS Apps</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/238/">WWDC2017 - Writing Energy Efficient Apps</a></li><li><a href="https://github.com/ChenYilong/iOSBlog/issues/10">iOS 常见耗电量检测方案调研</a></li><li><a href="http://www.jianshu.com/p/f0dc653d04ca">教你开发省电的 iOS app（WWDC17 观后）</a></li><li><a href="https://juejin.im/post/5a0c5af051882578da0d6925">浅析移动蜂窝网络的特点及其省电方案</a></li><li><a href="https://mp.weixin.qq.com/s/q39BHIWsbdNeqfH85EOkIQ">iOS电量测试实践</a></li><li><a href="http://www.cocoachina.com/ios/20171204/21413.html">iOS进阶–App功耗优化看这篇就够了</a></li></ul><h2 id="启动优化"><a href="#启动优化" class="headerlink" title="启动优化"></a>启动优化</h2><ul><li><a href="https://developer.apple.com/videos/play/wwdc2016/406">WWDC2016-406-Optimizing App Startup Time</a></li><li><a href="https://developer.apple.com/videos/play/wwdc2017/413">WWDC2017-413-App Startup Time:Past,Present,and Future</a></li><li><a href="https://www.jianshu.com/p/c14987eee107">如何精准度量iOSAPP启动时间</a></li><li><a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time">优化 App 的启动时间-杨萧玉</a></li><li><a href="https://techblog.toutiao.com/2017/01/17/iosspeed/#more">iOS客户端启动速度优化-今日头条</a></li><li><a href="https://mp.weixin.qq.com/s/Kf3EbDIUuf0aWVT-UCEmbA">iOS App 启动性能优化-WiFi管家</a></li><li><a href="http://www.cocoachina.com/ios/20160104/14870.html">iOS App如何优化启动时间-Facebook</a></li><li><a href="http://www.infoq.com/cn/presentations/ios-typewriting-start-speed-optimization">iOS 启动速度优化-百度输入法</a></li><li><a href="https://juejin.im/post/5a31190751882559e225a775">一次立竿见影的启动时间优化</a></li><li><a href="https://objccn.io/issue-6-3/">obj中国-Mach-O 可执行文件</a></li></ul><h2 id="体积优化"><a href="#体积优化" class="headerlink" title="体积优化"></a>体积优化</h2><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=207986417&idx=1&sn=77ea7d8e4f8ab7b59111e78c86ccfe66&scene=24&srcid=0921TTAXHGHWKqckEHTvGzoA#rd">iOS微信安装包瘦身</a></li><li><a href="https://techblog.toutiao.com/2016/12/27/iphone/">今日头条IPA安装包的优化</a></li><li><a href="http://www.infoq.com/cn/articles/ios-thinning-delete-unnecessary-mach-o">iOS瘦身之删除FrameWork中无用mach-O文件</a></li><li><a href="http://www.infoq.com/cn/articles/clang-plugin-ios-app-size-reducing">基于clang插件的一种iOS包大小瘦身方案</a></li><li><a href="http://blog.cnbang.net/tech/2544/">iOS可执行文件瘦身方法</a></li><li><a href="http://crespoxiao.github.io/2016/11/12/iOS%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/">iOS图片优化方案</a></li><li><a href="https://ming1016.github.io/2017/06/12/gmtc-ios-slimming-practice/">滴滴出行 iOS 端瘦身实践的 Slides</a></li></ul><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><ul><li><a href="http://tech.meituan.com/SharkSDK.html">美团点评移动网络优化实践</a></li><li><a href="http://mp.weixin.qq.com/s?__biz=MzAwMDU1MTE1OQ==&mid=209805123&idx=1&sn=ced8d67c3e2cc3ca38ef722949fa21f8">开源版HttpDNS方案详解</a></li><li><a href="http://www.infoq.com/cn/articles/how-ctrip-improves-app-networking-performance">携程App的网络性能优化实践</a></li><li><a href="http://www.infoq.com/cn/articles/app-network-service-and-performance-optimization-of-ctrip">2016年携程App网络服务通道治理和性能优化实践</a></li><li><a href="http://www.infoq.com/cn/articles/mogujie-app-chromium-network-layer">蘑菇街App Chromium网络栈实践</a></li><li><a href="http://www.infoq.com/cn/presentations/mogujie-high-concurrent-multi-terminal-wireless-gateway-practice">蘑菇街高并发多终端无线网关实践</a></li><li><a href="http://blog.cnbang.net/tech/3531/?hmsr=toutiao.io&utm_medium=toutiao.io&utm_source=toutiao.io">移动 APP 网络优化概述</a></li></ul><h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><ul><li><a href="https://github.com/fastred/Optimizing-Swift-Build-Times">Optimizing-Swift-Build-Times</a></li></ul><h2 id="APM"><a href="#APM" class="headerlink" title="APM"></a>APM</h2><ul><li><a href="http://mp.weixin.qq.com/s?__biz=MzA3ODg4MDk0Ng==&mid=2651112215&idx=1&sn=9cc5b5fa630542a6d4b7a5626e35217a#rd">网易 - NeteaseAPM iOS SDK技术实现分享</a></li><li><a href="http://www.jianshu.com/p/69ce01e15042">网易乐得 - iOS无埋点数据SDK实践之路</a> </li><li><a href="http://www.infoq.com/cn/presentations/mobile-terminal-apm-product-development-skills">听云 - 移动端 APM 产品研发技能</a> </li><li><a href="http://www.infoq.com/cn/presentations/mobile-app-performance-monitoring-practice?utm_source=presentations_about_mobile&utm_medium=link&utm_campaign=mobile">听云 - 移动 App 性能监测</a></li><li><a href="https://github.com/aozhimin/iOS-Monitor-Platform">iOS 性能监控 SDK —— Wedjat（华狄特）开发过程的调研和整理</a></li><li><a href="https://github.com/iOS-APM/iOS-APM-Secrets">揭秘 APM iOS SDK 的核心技术</a>  </li><li><a href="https://github.com/aozhimin/iOS-Monitor-Resources">iOS-Monitor-Resources</a></li></ul><h2 id="调试-amp-Crash"><a href="#调试-amp-Crash" class="headerlink" title="调试 &amp; Crash"></a>调试 &amp; Crash</h2><ul><li><a href="https://github.com/aozhimin/iOS-Debug-Hacks">iOS 项目开发过程中用到的高级调试技巧，涉及三方库动态调试、静态分析和反编译等领域</a></li><li><a href="https://developer.apple.com/library/content/technotes/tn2151/_index.html">Understanding and Analyzing Application Crash Reports</a></li></ul><h2 id="相关开源库"><a href="#相关开源库" class="headerlink" title="相关开源库"></a>相关开源库</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li><a href="https://github.com/CNSRE/HTTPDNSLib-for-iOS">HTTPDNSLib-for-iOS</a></li><li><a href="https://github.com/CNSRE/HTTPDNSLib">HTTPDNSLib-for-Andorod</a></li><li><a href="https://github.com/coderyi/NetworkEye/blob/master/README_Chinese.md">NetworkEye</a></li></ul><h3 id="卡顿"><a href="#卡顿" class="headerlink" title="卡顿"></a>卡顿</h3><ul><li><a href="https://github.com/suifengqjn/PerformanceMonitor">PerformanceMonitor-Runloop</a></li><li><a href="https://github.com/featuretower/GYMonitor">GYMonitor-FPS</a></li></ul><h3 id="瘦身"><a href="#瘦身" class="headerlink" title="瘦身"></a>瘦身</h3><ul><li><a href="https://github.com/tinymind/LSUnusedResources">LSUnusedResources</a></li><li><a href="https://github.com/huanxsd/LinkMap">LinkMap</a></li></ul><h2 id="APM-1"><a href="#APM-1" class="headerlink" title="APM"></a>APM</h2><ul><li><a href="https://github.com/iOS-APM/iOS-System-Services">iOS-System-Services</a></li><li><a href="https://github.com/iOS-APM/SystemMonitor">System Monitor</a></li><li><a href="https://github.com/Split82/iOSMemoryBudgetTest">iOS Memory Budget Test</a></li><li><a href="https://github.com/ArmsZhou/PerformanceTestingHelper">PerformanceTestingHelper</a></li><li><a href="https://github.com/Tencent/GT">GT</a></li></ul><h2 id="原作者链接"><a href="#原作者链接" class="headerlink" title="原作者链接"></a>原作者链接</h2><ul><li><a href="https://github.com/tbfungeek/iOS-Performance-Optimization">iOS-Performance-Optimization</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 协议字段位详解</title>
    <link href="/2023/02/27/TCP-%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/27/TCP-%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-协议字段位详解"><a href="#TCP-协议字段位详解" class="headerlink" title="TCP 协议字段位详解"></a>TCP 协议字段位详解</h1><p>TCP（Transmission Control Protocol）协议是一种面向连接、可靠的传输协议。TCP协议头部有20个字节，其中包括以下字段：</p><ul><li>源端口号（16位）：指发送端口的端口号。</li><li>目的端口号（16位）：指接收端口的端口号。</li><li>序列号（32位）：是一个32位的无符号整数，表示在当前连接中传输的第一个数据字节的序号。</li><li>确认号（32位）：是一个32位的无符号整数，表示期望收到的下一个字节的序号。</li><li>数据偏移（4位）：指的是TCP头部中数据的起始位置。因为TCP头部的长度是可变的，所以需要这个字段来指定数据的起始位置。</li><li>保留（6位）：暂时保留，未使用。</li><li>控制位（6位）：TCP协议头部中最重要的字段，包含了6个控制位，分别为URG、ACK、PSH、RST、SYN和FIN。</li><li>窗口大小（16位）：表示接收端点的缓存大小，用来控制发送端点的发送速度。</li><li>校验和（16位）：用来检测TCP头部和数据的完整性。</li><li>紧急指针（16位）：只有在URG标志被设置时才有意义，表示紧急数据的偏移量。</li><li>选项（可变长度）：TCP头部的选项字段，长度可变。</li></ul><p>下面是TCP协议头部的位图：</p><div class="code-wrapper"><pre><code class="hljs bash"> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|          Source Port          |       Destination Port        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                        Sequence Number                        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Acknowledgment Number                      |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  Data |           |U|A|P|R|S|F|                               || Offset| Reserved  |R|C|S|S|Y|I|            Window             ||       |           |G|K|H|T|N|N|                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|           Checksum            |         Urgent Pointer        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Options                    |    Padding    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><p>以上是 TCP 协议字段位的详细解释和协议头部的位图。</p><ol><li><p>三次握手和四次挥手的过程及含义。</p><p> 三次握手是建立连接时使用的过程，四次挥手是断开连接时使用的过程。三次握手的过程为：</p><ul><li>客户端发送 SYN 报文，指明客户端的初始序列号。</li><li>服务器返回 SYN+ACK 报文，指明服务器的初始序列号和确认号。</li><li>客户端返回 ACK 报文，指明客户端的确认号。</li></ul><p> 四次挥手的过程为：</p><ul><li>客户端发送 FIN 报文，请求关闭连接。</li><li>服务器返回 ACK 报文，确认收到了客户端的 FIN 报文。</li><li>服务器发送 FIN 报文，请求关闭连接。</li><li>客户端返回 ACK 报文，确认收到了服务器的 FIN 报文。</li></ul></li><li><p>TCP 的拥塞控制算法有哪些？</p><p> TCP 的拥塞控制算法有四种，分别是：慢启动、拥塞避免、快重传和快恢复。</p><ul><li>慢启动：连接建立后，TCP 发送方先将拥塞窗口 cwnd 初始化为一个较小的值，然后在每个往返时间内将 cwnd 加倍，直到出现丢包或拥塞发生。</li><li>拥塞避免：当 cwnd 达到一个阈值（ssthresh）时，cwnd 的增长就减缓为每个往返时间内只增加一个 MSS。</li><li>快重传：当发送方连续收到 3 个重复的 ACK 报文时，就立即重传对方尚未收到的报文段，以避免超时重传。</li><li>快恢复：当出现拥塞丢包时，发送方将 ssthresh 和 cwnd 更新为当前值的一半，然后继续执行拥塞避免算法。</li></ul></li><li><p>TCP 和 UDP 的区别是什么？</p><p> TCP 和 UDP 都是传输层协议，但是它们有很大的区别。TCP 是面向连接的，可靠的传输协议，而 UDP 则是无连接的、不可靠的传输协议。具体来说，TCP 提供了以下特性：</p><ul><li>可靠性：TCP 使用应答机制来保证数据的可靠传输。</li><li>面向连接：TCP 在通信前需要建立连接，通信结束后需要断开连接。</li><li>流量控制和拥塞控制：TCP 通过滑动窗口和拥塞控制算法来控制数据的传输速率。</li></ul><p> UDP 则不提供以上的特性，它更加简单、轻量级，适合于一些对可靠性要求不高的场景，如在线游戏等。</p></li></ol><p>基于 TCP 协议封装新的应用层协议时，需要注意以下问题：</p><ol><li>大端小端问题：TCP 协议头中的一些字段是多字节的，不同机器对于多字节字段的存储方式有所不同。为了解决这个问题，可以使用网络字节序（也称为大端字节序）来表示多字节字段，即始终将高位字节放在低地址处。</li><li>粘包黏包问题：由于 TCP 协议是面向流的，而应用层协议通常是面向消息的，因此在发送端，需要将一个完整的消息拆分成多个 TCP 报文段发送，同时在接收端，需要将多个 TCP 报文段组装成一个完整的消息。为了解决这个问题，可以采用以下方法：<ul><li>消息长度标记法：在消息的开头加上一个固定长度的字段，表示整个消息的长度，接收端先读取这个字段，然后读取相应长度的数据，即为一个完整的消息。</li><li>分隔符法：在消息的结尾加上一个特定的分隔符，表示一个消息的结束，接收端一直读取数据，直到读到分隔符为止，即为一个完整的消息。</li><li>固定长度法：固定每个消息的长度，接收端先读取固定长度的数据，然后将其解析为一个完整的消息。</li></ul></li></ol><p>除此之外，还需要考虑数据完整性、安全性等问题，比如可以使用消息认证码（MAC）来保证数据完整性和认证，使用加密算法来保证数据的安全性。</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket 协议字段位详解</title>
    <link href="/2023/02/27/WebSocket%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/27/WebSocket%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="WebSocket-协议字段位详解"><a href="#WebSocket-协议字段位详解" class="headerlink" title="WebSocket 协议字段位详解"></a>WebSocket 协议字段位详解</h1><p>WebSocket 协议是一种基于 TCP 协议的应用层协议，它是为了解决 HTTP 协议的一些缺陷而设计的。WebSocket 协议头部有 2 个或 14 个字节，其中包括以下字段：</p><ul><li>FIN（1 位）：表示该数据帧是否为一帧的最后一部分。</li><li>RSV1, RSV2, RSV3（各 1 位）：保留位，目前未使用。</li><li>Opcode（4 位）：表示数据帧的类型，包括文本、二进制、关闭连接等。</li><li>Mask（1 位）：表示是否对数据进行掩码处理，防止数据在传输过程中被篡改。</li><li>Payload Length（7 位或 7 + 16 + 64 位）：表示数据负载的长度，如果长度小于 126，则使用 7 位来表示；如果长度大于等于 126，则使用 7 + 16 位或 7 + 16 + 64 位来表示。</li><li>Masking Key（0 或 4 字节）：掩码密钥，如果 Mask 位为 1，则需要使用掩码密钥对数据进行掩码处理。</li><li>Payload Data（可变长度）：表示数据帧的负载数据。</li></ul><p>下面是 WebSocket 协议头部的位图：</p><div class="code-wrapper"><pre><code class="hljs bash"> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len |    Extended payload length    ||I|S|S|S|  (4)  |A|     (7)     |             (16/64)           ||N|V|V|V|       |S|             |   (<span class="hljs-keyword">if</span> payload len==126/127)   || |1|2|3|       |K|             |                               |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +|     Extended payload length continued, <span class="hljs-keyword">if</span> payload len == 127  |+ - - - - - - - - - - - - - - - +-------------------------------+|                               |Masking-key, <span class="hljs-keyword">if</span> MASK <span class="hljs-built_in">set</span> to 1  |+-------------------------------+-------------------------------+| Masking-key (continued)       |          Payload Data         |+-------------------------------- - - - - - - - - - - - - - - - +:                     Payload Data continued ...                :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +|                     Payload Data continued ...                |+---------------------------------------------------------------+</code></pre></div><p>以上是 WebSocket 协议字段位的详细解释和协议头部的位图。</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UDP 协议字段位详解</title>
    <link href="/2023/02/27/UDP%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/27/UDP%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="UDP-协议字段位详解"><a href="#UDP-协议字段位详解" class="headerlink" title="UDP 协议字段位详解"></a>UDP 协议字段位详解</h1><p>UDP（User Datagram Protocol）是一种无连接的基于 IP 协议的传输层协议，与TCP相比，UDP协议具有传输速度快、实时性强等优点。在UDP协议中，数据被分割成数据报，每个数据报都包含了一些字段。下面是UDP协议每个字段位的详解：</p><ul><li>**源端口(Source Port)**：这个字段占用16个比特位，表示发送端口号。它是在UDP报文中标识发送方应用程序的端口号，用于接收方回复信息时确定回复的是哪个端口。</li><li>**目的端口(Destination Port)**：这个字段占用16个比特位，表示接收端口号。它是在UDP报文中标识接收方应用程序的端口号，用于接收发送方发送的信息。</li><li>**长度(Length)**：这个字段占用16个比特位，表示UDP数据报的长度。它表示整个数据报的长度，包括UDP报头和UDP数据。</li><li>**校验和(Checksum)**：这个字段占用16个比特位，表示UDP数据报的校验和。它用于检验UDP数据报在传输过程中是否发生了错误。</li></ul><p>下面是UDP协议的字段位图：</p><div class="code-wrapper"><pre><code class="hljs bash"> 0      7 8     15 16    23 24    31+--------+--------+--------+--------+|     源端口号     |     目的端口号    |+--------+--------+--------+--------+|           长度             |校验和  |+--------+--------+--------+--------+|              数据           ....   |+--------+--------+--------+--------+</code></pre></div><p>以上是UDP协议每个字段位的详解和协议位图。</p><p>UDP协议是一种无连接的传输层协议。在UDP协议中，数据被分割成数据报，每个数据报都包含了一些字段。UDP协议具有传输速度快、实时性强等优点，但是不保证可靠性和数据的有序性。UDP对传输的数据没有任何担保，只是尽力去传输。当数据丢失或者出现错误时，UDP不会进行重传或者纠错。因此，UDP适用于数据量小、对可靠性要求不高的场景，例如在线游戏、实时视频和音频传输等。</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IP 协议字段位详解</title>
    <link href="/2023/02/27/IP-%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/27/IP-%E5%8D%8F%E8%AE%AE%E5%AD%97%E6%AE%B5%E4%BD%8D%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="IP-协议字段位详解"><a href="#IP-协议字段位详解" class="headerlink" title="IP 协议字段位详解"></a>IP 协议字段位详解</h1><p>IP（Internet Protocol）协议是互联网的核心协议之一，它负责将网络层的数据包从源地址传输到目的地址。在IP数据包中，有许多字段用于描述数据包的内容和传输信息。下面将详细介绍IP协议中每个字段位的含义和作用。</p><h2 id="IP协议位图"><a href="#IP协议位图" class="headerlink" title="IP协议位图"></a>IP协议位图</h2><p>以下是IP协议的位图表示，其中包括了每个字段位的位置和长度：</p><div class="code-wrapper"><pre><code class="hljs bash">0                   1                   2                   30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|Version|  IHL  |Type of Service|          Total Length         |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|         Identification        |Flags|      Fragment Offset    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|  Time to Live |    Protocol   |         Header Checksum       |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                       Source Address                          |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Destination Address                        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                    Options                    |    Padding    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</code></pre></div><h2 id="IP协议字段位详解"><a href="#IP协议字段位详解" class="headerlink" title="IP协议字段位详解"></a>IP协议字段位详解</h2><h3 id="Version（版本）"><a href="#Version（版本）" class="headerlink" title="Version（版本）"></a>Version（版本）</h3><p>该字段占4位，用于指定IP协议版本号。当前IP协议版本为IPv4，其版本号为4。</p><h3 id="IHL（报头长度）"><a href="#IHL（报头长度）" class="headerlink" title="IHL（报头长度）"></a>IHL（报头长度）</h3><p>该字段占4位，用于指定IP数据包报头的长度，以32位字长为单位。因此，IHL字段的值是4的倍数。最小值为5，最大值为15。</p><h3 id="Type-of-Service（服务类型）"><a href="#Type-of-Service（服务类型）" class="headerlink" title="Type of Service（服务类型）"></a>Type of Service（服务类型）</h3><p>该字段占8位，用于指定IP数据包的服务类型。其中，前3位为优先级，后5位为服务类型。该字段已被DSCP所取代。</p><h3 id="Total-Length（总长度）"><a href="#Total-Length（总长度）" class="headerlink" title="Total Length（总长度）"></a>Total Length（总长度）</h3><p>该字段占16位，用于指定IP数据包的总长度，以字节为单位。该长度包括IP数据包的报头和数据负载。</p><h3 id="Identification（标识）"><a href="#Identification（标识）" class="headerlink" title="Identification（标识）"></a>Identification（标识）</h3><p>该字段占16位，用于标识IP数据包的唯一标识符。每个IP数据包都应该有一个唯一的标识符。</p><h3 id="Flags（标志）"><a href="#Flags（标志）" class="headerlink" title="Flags（标志）"></a>Flags（标志）</h3><p>该字段占3位，用于指定IP数据包的分片信息。其中，第1位为Reserved，第2位为Don’t Fragment（DF），第3位为More Fragments（MF）。</p><h3 id="Fragment-Offset（分片偏移）"><a href="#Fragment-Offset（分片偏移）" class="headerlink" title="Fragment Offset（分片偏移）"></a>Fragment Offset（分片偏移）</h3><p>该字段占13位，用于指定IP数据包在分片后的偏移量，以8字节为单位。该字段只在MF标志位被设置时有效。</p><h3 id="Time-to-Live（生存时间）"><a href="#Time-to-Live（生存时间）" class="headerlink" title="Time to Live（生存时间）"></a>Time to Live（生存时间）</h3><p>该字段占8位，用于指定IP数据包在网络中的生存时间。每次经过一个路由器，该字段的值就会减1，当该字段的值为0时，数据包将被丢弃。</p><h3 id="Protocol（协议）"><a href="#Protocol（协议）" class="headerlink" title="Protocol（协议）"></a>Protocol（协议）</h3><p>该字段占8位，用于指定IP数据包中的上层协议类型。常见的协议类型有TCP、UDP和ICMP等。</p><h3 id="Header-Checksum（报头校验和）"><a href="#Header-Checksum（报头校验和）" class="headerlink" title="Header Checksum（报头校验和）"></a>Header Checksum（报头校验和）</h3><p>该字段占16位，用于校验IP数据包报头的正确性。校验和的计算方法是将报头中的每个16位字加起来，再将结果按位取反。</p><h3 id="Source-Address（源地址）"><a href="#Source-Address（源地址）" class="headerlink" title="Source Address（源地址）"></a>Source Address（源地址）</h3><p>该字段占32位，用于指定IP数据包的源地址。</p><h3 id="Destination-Address（目的地址）"><a href="#Destination-Address（目的地址）" class="headerlink" title="Destination Address（目的地址）"></a>Destination Address（目的地址）</h3><p>该字段占32位，用于指定IP数据包的目的地址。</p><h3 id="Options（选项）"><a href="#Options（选项）" class="headerlink" title="Options（选项）"></a>Options（选项）</h3><p>该字段占变长，用于在IP数据包中添加一些可选的信息，如记录路径、时间戳等。如果该字段不存在，则用0填充。</p><h3 id="Padding（填充）"><a href="#Padding（填充）" class="headerlink" title="Padding（填充）"></a>Padding（填充）</h3><p>该字段占变长，用于将Options字段的长度补齐成4的倍数。如果Options字段的长度已经是4的倍数，则Padding字段不存在。</p><p>以上是IP协议中每个字段位的详细解释，了解这些字段的作用可以帮助我们更好地理解IP数据包的结构和传输过程。</p><p>如果我们要发送一个IP数据包，那么我们需要填写这些字段，并将它们放入数据包中。在数据包传输过程中，这些字段会被路由器等网络设备读取和处理，以确定数据包的发送和转发路径。</p><p>需要注意的是，IP数据包在传输过程中可能会被分片。当数据包的长度超过网络设备的MTU（最大传输单元）时，它就会被分成多个小片，以便在网络中传输。分片后的数据包会在每个数据包的头部添加分片偏移和标志等信息，以便在目的地将它们重新组装成原始数据包。因此，在处理和发送IP数据包时，我们需要考虑到数据包的长度和MTU等因素。</p>]]></content>
    
    
    <categories>
      
      <category>网络协议</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2023/02/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2023/02/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法是计算机科学中经典的问题之一。它的目的是将一组数据按照指定的顺序进行排列。这里将介绍常见的几种排序算法及其时间复杂度和空间复杂度分析。</p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序是最基本的排序算法之一，它的基本思想是将相邻的元素两两比较，将较大的元素向后移动。时间复杂度为O(n^2)，空间复杂度为O(1)。</p><ul><li>最优情况：输入数组已经按照从小到大的顺序排好了，此时时间复杂度为O(n)。</li><li>最坏情况：输入数组按照从大到小的顺序排列，此时时间复杂度为O(n^2)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">bubbleSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>]) &#123;    <span class="hljs-keyword">guard</span> array.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>array.count &#123;        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>array.count<span class="hljs-operator">-</span>i &#123;            <span class="hljs-keyword">if</span> array[j<span class="hljs-operator">-</span><span class="hljs-number">1</span>] <span class="hljs-operator">&gt;</span> array[j] &#123;                array.swapAt(j<span class="hljs-operator">-</span><span class="hljs-number">1</span>, j)            &#125;        &#125;    &#125;&#125;</code></pre></div><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序是一种简单直观的排序算法，它的基本思想是每次从未排序的数组中选择最小的元素，然后将其放到已排序的数组的末尾。时间复杂度为O(n^2)，空间复杂度为O(1)。</p><ul><li>最优情况和最坏情况的时间复杂度均为O(n^2)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">selectionSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>]) &#123;    <span class="hljs-keyword">guard</span> array.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>array.count<span class="hljs-operator">-</span><span class="hljs-number">1</span> &#123;        <span class="hljs-keyword">var</span> minIndex <span class="hljs-operator">=</span> i        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> i<span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>array.count &#123;            <span class="hljs-keyword">if</span> array[j] <span class="hljs-operator">&lt;</span> array[minIndex] &#123;                minIndex <span class="hljs-operator">=</span> j            &#125;        &#125;        <span class="hljs-keyword">if</span> i <span class="hljs-operator">!=</span> minIndex &#123;            array.swapAt(i, minIndex)        &#125;    &#125;&#125;</code></pre></div><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>插入排序是一种简单直观的排序算法，它的基本思想是将未排序的元素插入到已排序的数组中。时间复杂度为O(n^2)，空间复杂度为O(1)。</p><ul><li>最优情况：输入数组已经按照从小到大的顺序排好了，此时时间复杂度为O(n)。</li><li>最坏情况：输入数组按照从大到小的顺序排列，此时时间复杂度为O(n^2)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">insertionSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>]) &#123;    <span class="hljs-keyword">guard</span> array.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">..&lt;</span>array.count &#123;        <span class="hljs-keyword">var</span> j <span class="hljs-operator">=</span> i        <span class="hljs-keyword">let</span> temp <span class="hljs-operator">=</span> array[j]        <span class="hljs-keyword">while</span> j <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">&amp;&amp;</span> temp <span class="hljs-operator">&lt;</span> array[j<span class="hljs-operator">-</span><span class="hljs-number">1</span>] &#123;            array[j] <span class="hljs-operator">=</span> array[j<span class="hljs-operator">-</span><span class="hljs-number">1</span>]            j <span class="hljs-operator">-=</span> <span class="hljs-number">1</span>        &#125;        array[j] <span class="hljs-operator">=</span> temp    &#125;&#125;</code></pre></div><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p>快速排序是一种常用的排序算法，它的基本思想是通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，然后分别对这两部分记录继续进行排序，直到整个序列有序。时间复杂度为O(nlogn)，空间复杂度为O(logn)。</p><ul><li>最优情况：每次分区的中间元素恰好为数组的中位数，此时时间复杂度为O(n log n)。</li><li>最坏情况：每次分区的中间元素都是最小或最大的元素，此时时间复杂度为O(n^2)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">quickSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">left</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">right</span>: <span class="hljs-type">Int</span>) &#123;    <span class="hljs-keyword">guard</span> left <span class="hljs-operator">&lt;</span> right <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span>    &#125;    <span class="hljs-keyword">var</span> i <span class="hljs-operator">=</span> left    <span class="hljs-keyword">var</span> j <span class="hljs-operator">=</span> right    <span class="hljs-keyword">let</span> pivot <span class="hljs-operator">=</span> array[(left<span class="hljs-operator">+</span>right)<span class="hljs-operator">/</span><span class="hljs-number">2</span>]    <span class="hljs-keyword">while</span> i <span class="hljs-operator">&lt;=</span> j &#123;        <span class="hljs-keyword">while</span> array[i] <span class="hljs-operator">&lt;</span> pivot &#123;            i <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">while</span> array[j] <span class="hljs-operator">&gt;</span> pivot &#123;            j <span class="hljs-operator">-=</span> <span class="hljs-number">1</span>        &#125;        <span class="hljs-keyword">if</span> i <span class="hljs-operator">&lt;=</span> j &#123;            array.swapAt(i, j)            i <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>            j <span class="hljs-operator">-=</span> <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">if</span> left <span class="hljs-operator">&lt;</span> j &#123;        quickSort(<span class="hljs-operator">&amp;</span>array, left, j)    &#125;    <span class="hljs-keyword">if</span> i <span class="hljs-operator">&lt;</span> right &#123;        quickSort(<span class="hljs-operator">&amp;</span>array, i, right)    &#125;&#125;</code></pre></div><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p>归并排序是一种稳定的排序算法，它的基本思想是将待排序的数组分成若干个子序列，每个子序列都是有序的，然后再将子序列合并成一个有序的序列。时间复杂度为O(nlogn)，空间复杂度为O(n)。</p><ul><li>最优情况和最坏情况的时间复杂度均为O(n log n)。</li></ul><p>Swift5示例代码如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">mergeSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">array</span>: [<span class="hljs-type">Int</span>]) -&gt; [<span class="hljs-type">Int</span>] &#123;    <span class="hljs-keyword">guard</span> array.count <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> array    &#125;    <span class="hljs-keyword">let</span> middleIndex <span class="hljs-operator">=</span> array.count <span class="hljs-operator">/</span> <span class="hljs-number">2</span>    <span class="hljs-keyword">let</span> leftArray <span class="hljs-operator">=</span> mergeSort(<span class="hljs-type">Array</span>(array[<span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span>middleIndex]))    <span class="hljs-keyword">let</span> rightArray <span class="hljs-operator">=</span> mergeSort(<span class="hljs-type">Array</span>(array[middleIndex<span class="hljs-operator">..&lt;</span>array.count]))    <span class="hljs-keyword">return</span> merge(leftArray, rightArray)&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">merge</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">left</span>: [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">right</span>: [<span class="hljs-type">Int</span>]) -&gt; [<span class="hljs-type">Int</span>] &#123;    <span class="hljs-keyword">var</span> leftIndex <span class="hljs-operator">=</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> rightIndex <span class="hljs-operator">=</span> <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> orderedArray <span class="hljs-operator">=</span> [<span class="hljs-type">Int</span>]()    <span class="hljs-keyword">while</span> leftIndex <span class="hljs-operator">&lt;</span> left.count <span class="hljs-operator">&amp;&amp;</span> rightIndex <span class="hljs-operator">&lt;</span> right.count &#123;        <span class="hljs-keyword">if</span> left[leftIndex] <span class="hljs-operator">&lt;</span> right[rightIndex] &#123;            orderedArray.append(left[leftIndex])            leftIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> left[leftIndex] <span class="hljs-operator">&gt;</span> right[rightIndex] &#123;            orderedArray.append(right[rightIndex])            rightIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>        &#125; <span class="hljs-keyword">else</span> &#123;            orderedArray.append(left[leftIndex])            leftIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>            orderedArray.append(right[rightIndex])            rightIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>        &#125;    &#125;    <span class="hljs-keyword">while</span> leftIndex <span class="hljs-operator">&lt;</span> left.count &#123;        orderedArray.append(left[leftIndex])        leftIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">while</span> rightIndex <span class="hljs-operator">&lt;</span> right.count &#123;        orderedArray.append(right[rightIndex])        rightIndex <span class="hljs-operator">+=</span> <span class="hljs-number">1</span>    &#125;    <span class="hljs-keyword">return</span> orderedArray&#125;</code></pre></div><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p>堆排序是一种基于堆结构的排序算法。它的基本思想是在待排序序列中建立一个堆，然后依次从堆中取出最大（最小）元素，将其放置到已排序序列的末尾，直到堆中没有元素。</p><p>堆排序算法的时间复杂度为O(n log n)，它的性能表现比大多数其他排序算法都要好。同时，它的实现也比较简单，只需要一个数组作为数据结构即可。</p><ul><li>最优情况和最坏情况的时间复杂度均为O(n log n)。</li></ul><p>Swift5实现堆排序的代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">func</span> <span class="hljs-title function_">heapSort</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">arr</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>]) &#123;    <span class="hljs-keyword">let</span> n <span class="hljs-operator">=</span> arr.count    <span class="hljs-comment">// 构建大根堆</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span><span class="hljs-operator">...</span>(n<span class="hljs-operator">/</span><span class="hljs-number">2</span><span class="hljs-operator">-</span><span class="hljs-number">1</span>)).reversed() &#123;        heapify(<span class="hljs-operator">&amp;</span>arr, n, i)    &#125;    <span class="hljs-comment">// 从堆中取出元素，放置到已排序的序列中</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> (<span class="hljs-number">0</span><span class="hljs-operator">...</span>(n<span class="hljs-operator">-</span><span class="hljs-number">1</span>)).reversed() &#123;        arr.swapAt(<span class="hljs-number">0</span>, i)        heapify(<span class="hljs-operator">&amp;</span>arr, i, <span class="hljs-number">0</span>)    &#125;&#125;<span class="hljs-comment">// 调整堆</span><span class="hljs-keyword">func</span> <span class="hljs-title function_">heapify</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">arr</span>: <span class="hljs-keyword">inout</span> [<span class="hljs-type">Int</span>], <span class="hljs-keyword">_</span> <span class="hljs-params">n</span>: <span class="hljs-type">Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-params">i</span>: <span class="hljs-type">Int</span>) &#123;    <span class="hljs-keyword">var</span> largest <span class="hljs-operator">=</span> i    <span class="hljs-keyword">let</span> l <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">let</span> r <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-operator">*</span> i <span class="hljs-operator">+</span> <span class="hljs-number">2</span>    <span class="hljs-keyword">if</span> l <span class="hljs-operator">&lt;</span> n <span class="hljs-operator">&amp;&amp;</span> arr[l] <span class="hljs-operator">&gt;</span> arr[largest] &#123;        largest <span class="hljs-operator">=</span> l    &#125;    <span class="hljs-keyword">if</span> r <span class="hljs-operator">&lt;</span> n <span class="hljs-operator">&amp;&amp;</span> arr[r] <span class="hljs-operator">&gt;</span> arr[largest] &#123;        largest <span class="hljs-operator">=</span> r    &#125;    <span class="hljs-keyword">if</span> largest <span class="hljs-operator">!=</span> i &#123;        arr.swapAt(i, largest)        heapify(<span class="hljs-operator">&amp;</span>arr, n, largest)    &#125;&#125;</code></pre></div><p>这个函数接受一个整数数组作为参数，将数组进行堆排序。它首先构建一个大根堆，然后从堆中取出元素，放置到已排序的序列中。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>算法</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iOS 常用的开发架构</title>
    <link href="/2023/02/25/iOS-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/02/25/iOS-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BC%80%E5%8F%91%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-常用的开发架构"><a href="#iOS-常用的开发架构" class="headerlink" title="iOS 常用的开发架构"></a>iOS 常用的开发架构</h1><p>在iOS开发中，常用的开发架构有MVC、MVVM和VIPER。下面将分别对这三种架构进行讲解。</p><h2 id="1-MVC架构"><a href="#1-MVC架构" class="headerlink" title="1. MVC架构"></a>1. MVC架构</h2><p>MVC是Model-View-Controller的缩写，是一种将应用程序分成三个核心部件的设计模式。</p><ul><li>Model：数据模型，封装了应用程序的数据以及操作数据的方法。</li><li>View：用户界面，展示数据以及与用户交互的界面。</li><li>Controller：控制器，协调Model和View之间的通信。</li></ul><h3 id="MVC-Swift-5-示例代码"><a href="#MVC-Swift-5-示例代码" class="headerlink" title="MVC Swift 5 示例代码"></a>MVC Swift 5 示例代码</h3><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// Model</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">age</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> age    &#125;&#125;<span class="hljs-comment">// View</span><span class="hljs-keyword">import</span> UIKit<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonView</span>: <span class="hljs-title class_">UIView</span> &#123;    <span class="hljs-keyword">let</span> nameLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">let</span> ageLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">frame</span>: <span class="hljs-type">CGRect</span>) &#123;        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(frame: frame)        nameLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        ageLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">60</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        <span class="hljs-keyword">self</span>.addSubview(nameLabel)        <span class="hljs-keyword">self</span>.addSubview(ageLabel)    &#125;    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-params">coder</span>: <span class="hljs-type">NSCoder</span>) &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;init(coder:) has not been implemented&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">configure</span>(<span class="hljs-params">with</span> <span class="hljs-params">person</span>: <span class="hljs-type">Person</span>) &#123;        nameLabel.text <span class="hljs-operator">=</span> person.name        ageLabel.text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>(person.age)&quot;</span>    &#125;&#125;<span class="hljs-comment">// Controller</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonController</span> &#123;    <span class="hljs-keyword">let</span> person: <span class="hljs-type">Person</span>    <span class="hljs-keyword">let</span> personView: <span class="hljs-type">PersonView</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">person</span>: <span class="hljs-type">Person</span>, <span class="hljs-params">personView</span>: <span class="hljs-type">PersonView</span>) &#123;        <span class="hljs-keyword">self</span>.person <span class="hljs-operator">=</span> person        <span class="hljs-keyword">self</span>.personView <span class="hljs-operator">=</span> personView        <span class="hljs-keyword">self</span>.personView.configure(with: person)    &#125;&#125;</code></pre></div><h2 id="2-MVVM架构"><a href="#2-MVVM架构" class="headerlink" title="2. MVVM架构"></a>2. MVVM架构</h2><p>MVVM是Model-View-ViewModel的缩写，是在MVC架构的基础上发展而来的一种设计模式。</p><ul><li>Model：数据模型，封装了应用程序的数据以及操作数据的方法。</li><li>View：用户界面，展示数据以及与用户交互的界面。</li><li>ViewModel：作为View和Model之间的中间层，负责处理View的展示逻辑，将Model的数据转化为View需要的数据。</li></ul><h3 id="MVVM-Swift-5-示例代码"><a href="#MVVM-Swift-5-示例代码" class="headerlink" title="MVVM Swift 5 示例代码"></a>MVVM Swift 5 示例代码</h3><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// Model</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">age</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> age    &#125;&#125;<span class="hljs-comment">// ViewModel</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonViewModel</span> &#123;    <span class="hljs-keyword">var</span> person: <span class="hljs-type">Person</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">person</span>: <span class="hljs-type">Person</span>) &#123;        <span class="hljs-keyword">self</span>.person <span class="hljs-operator">=</span> person    &#125;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> person.name    &#125;    <span class="hljs-keyword">var</span> age: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>(person.age)&quot;</span>    &#125;&#125;<span class="hljs-comment">// View</span><span class="hljs-keyword">import</span> UIKit<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonView</span>: <span class="hljs-title class_">UIView</span> &#123;    <span class="hljs-keyword">let</span> nameLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">let</span> ageLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">var</span> viewModel: <span class="hljs-type">PersonViewModel</span>? &#123;        <span class="hljs-keyword">didSet</span> &#123;            nameLabel.text <span class="hljs-operator">=</span> viewModel<span class="hljs-operator">?</span>.name            ageLabel.text <span class="hljs-operator">=</span> viewModel<span class="hljs-operator">?</span>.age        &#125;    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">frame</span>: <span class="hljs-type">CGRect</span>) &#123;        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(frame: frame)        nameLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        ageLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">60</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        <span class="hljs-keyword">self</span>.addSubview(nameLabel)        <span class="hljs-keyword">self</span>.addSubview(ageLabel)    &#125;    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-params">coder</span>: <span class="hljs-type">NSCoder</span>) &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;init(coder:) has not been implemented&quot;</span>)    &#125;&#125;<span class="hljs-comment">// Controller</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonController</span> &#123;    <span class="hljs-keyword">let</span> personView: <span class="hljs-type">PersonView</span>    <span class="hljs-keyword">let</span> personViewModel: <span class="hljs-type">PersonViewModel</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">person</span>: <span class="hljs-type">Person</span>) &#123;        <span class="hljs-keyword">self</span>.personViewModel <span class="hljs-operator">=</span> <span class="hljs-type">PersonViewModel</span>(person: person)        <span class="hljs-keyword">self</span>.personView <span class="hljs-operator">=</span> <span class="hljs-type">PersonView</span>()        <span class="hljs-keyword">self</span>.personView.viewModel <span class="hljs-operator">=</span> personViewModel    &#125;&#125;</code></pre></div><h2 id="3-VIPER架构"><a href="#3-VIPER架构" class="headerlink" title="3. VIPER架构"></a>3. VIPER架构</h2><p>VIPER是View-Interactor-Presenter-Entity-Router的缩写，是一种通过将应用程序的逻辑分解成多个独立的模块来构建清晰、可扩展和易于维护的架构。</p><ul><li>View：用户界面，展示数据以及与用户交互的界面。</li><li>Interactor：业务逻辑层，负责处理业务逻辑。</li><li>Presenter：负责将Interactor返回的数据转化为View需要的数据。</li><li>Entity：数据模型，封装了应用程序的数据以及操作数据的方法。</li><li>Router：负责处理模块之间的跳转逻辑。</li></ul><h3 id="VIPER-Swift-5-示例代码"><a href="#VIPER-Swift-5-示例代码" class="headerlink" title="VIPER Swift 5 示例代码"></a>VIPER Swift 5 示例代码</h3><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// Entity</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> age: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">age</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.age <span class="hljs-operator">=</span> age    &#125;&#125;<span class="hljs-comment">// Interactor</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonInteractor</span> &#123;    <span class="hljs-keyword">var</span> person: <span class="hljs-type">Person</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchPerson</span>() -&gt; <span class="hljs-type">Person</span> &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> person &#123;            <span class="hljs-keyword">return</span> person        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> <span class="hljs-type">Person</span>(name: <span class="hljs-string">&quot;Tom&quot;</span>, age: <span class="hljs-number">18</span>)            <span class="hljs-keyword">self</span>.person <span class="hljs-operator">=</span> person            <span class="hljs-keyword">return</span> person        &#125;    &#125;&#125;<span class="hljs-comment">// Presenter</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonPresenter</span> &#123;    <span class="hljs-keyword">var</span> person: <span class="hljs-type">Person</span>?    <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> view: <span class="hljs-type">PersonView</span>?    <span class="hljs-keyword">let</span> interactor <span class="hljs-operator">=</span> <span class="hljs-type">PersonInteractor</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fetchPerson</span>() &#123;        <span class="hljs-keyword">let</span> person <span class="hljs-operator">=</span> interactor.fetchPerson()        <span class="hljs-keyword">self</span>.person <span class="hljs-operator">=</span> person        view<span class="hljs-operator">?</span>.configure(with: person)    &#125;&#125;<span class="hljs-comment">// View</span><span class="hljs-keyword">import</span> UIKit<span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonView</span>: <span class="hljs-title class_">UIView</span> &#123;    <span class="hljs-keyword">let</span> nameLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">let</span> ageLabel <span class="hljs-operator">=</span> <span class="hljs-type">UILabel</span>()    <span class="hljs-keyword">var</span> presenter: <span class="hljs-type">PersonPresenter</span>?    <span class="hljs-keyword">override</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">frame</span>: <span class="hljs-type">CGRect</span>) &#123;        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(frame: frame)        nameLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        ageLabel.frame <span class="hljs-operator">=</span> <span class="hljs-type">CGRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">60</span>, width: <span class="hljs-number">100</span>, height: <span class="hljs-number">50</span>)        <span class="hljs-keyword">self</span>.addSubview(nameLabel)        <span class="hljs-keyword">self</span>.addSubview(ageLabel)    &#125;    <span class="hljs-keyword">required</span> <span class="hljs-keyword">init?</span>(<span class="hljs-params">coder</span>: <span class="hljs-type">NSCoder</span>) &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;init(coder:) has not been implemented&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">configure</span>(<span class="hljs-params">with</span> <span class="hljs-params">person</span>: <span class="hljs-type">Person</span>) &#123;        nameLabel.text <span class="hljs-operator">=</span> person.name        ageLabel.text <span class="hljs-operator">=</span> <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>(person.age)&quot;</span>    &#125;&#125;<span class="hljs-comment">// Router</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonRouter</span> &#123;&#125;<span class="hljs-comment">// Controller</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonController</span> &#123;    <span class="hljs-keyword">let</span> personView <span class="hljs-operator">=</span> <span class="hljs-type">PersonView</span>()    <span class="hljs-keyword">let</span> personPresenter <span class="hljs-operator">=</span> <span class="hljs-type">PersonPresenter</span>()    <span class="hljs-keyword">let</span> personRouter <span class="hljs-operator">=</span> <span class="hljs-type">PersonRouter</span>()    <span class="hljs-keyword">init</span>() &#123;        personPresenter.view <span class="hljs-operator">=</span> personView        personView.presenter <span class="hljs-operator">=</span> personPresenter    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>iOS</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24 种设计模式-1 (Swift 5版)</title>
    <link href="/2023/02/25/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-Swift-5%E7%89%88/"/>
    <url>/2023/02/25/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-1-Swift-5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="创建型模式（Creational-Patterns）"><a href="#创建型模式（Creational-Patterns）" class="headerlink" title="创建型模式（Creational Patterns）"></a>创建型模式（Creational Patterns）</h2><h3 id="1-简单工厂模式（Simple-Factory-Pattern）"><a href="#1-简单工厂模式（Simple-Factory-Pattern）" class="headerlink" title="1. 简单工厂模式（Simple Factory Pattern）"></a>1. 简单工厂模式（Simple Factory Pattern）</h3><p>简单工厂模式（Simple Factory Pattern）是一种创建型设计模式，它的主要目的是提供一个统一的接口来创建对象，而无需暴露具体的创建逻辑。该模式常用来解决创建对象时客户端代码需要知道所有可能被创建对象类的问题。</p><p>在简单工厂模式中，通常包括一个工厂类和多个产品类。工厂类根据客户端请求的参数来决定创建哪个产品类的对象，并返回给客户端。这样客户端就无需直接调用产品类的构造函数来创建对象了。</p><p>以下是一个使用简单工厂模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义一个接口，所有产品类都要实现这个接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">use</span>()&#125;<span class="hljs-comment">// 具体的产品类实现 Product 接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span>: <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">use</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ProductA used&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductB</span>: <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">use</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ProductB used&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 简单工厂类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleFactory</span> &#123;    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ProductType</span> &#123;        <span class="hljs-keyword">case</span> <span class="hljs-type">A</span>, <span class="hljs-type">B</span>    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">createProduct</span>(<span class="hljs-params">type</span>: <span class="hljs-type">ProductType</span>) -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-keyword">switch</span> type &#123;        <span class="hljs-keyword">case</span> .<span class="hljs-type">A</span>:            <span class="hljs-keyword">return</span> <span class="hljs-type">ProductA</span>()        <span class="hljs-keyword">case</span> .<span class="hljs-type">B</span>:            <span class="hljs-keyword">return</span> <span class="hljs-type">ProductB</span>()        &#125;    &#125;&#125;<span class="hljs-comment">// 客户端代码</span><span class="hljs-keyword">let</span> productA <span class="hljs-operator">=</span> <span class="hljs-type">SimpleFactory</span>.createProduct(type: .<span class="hljs-type">A</span>)productA.use() <span class="hljs-comment">// 输出: &quot;ProductA used&quot;</span><span class="hljs-keyword">let</span> productB <span class="hljs-operator">=</span> <span class="hljs-type">SimpleFactory</span>.createProduct(type: .<span class="hljs-type">B</span>)productB.use() <span class="hljs-comment">// 输出: &quot;ProductB used&quot;</span></code></pre></div></li></ul><p>在上面的示例代码中，**<code>Product</code>** 定义了一个使用产品的接口。**<code>ProductA</code>** 和 <strong><code>ProductB</code></strong> 是具体的产品类，它们都实现了 <strong><code>Product</code></strong> 接口。**<code>SimpleFactory</code>** 是简单工厂类，它根据客户端请求的参数来创建不同的产品类的对象，然后返回给客户端。最后，客户端通过调用返回的对象的 <strong><code>use</code></strong> 方法来使用产品。</p><h3 id="2-抽象工厂模式（Abstract-Factory-Pattern）"><a href="#2-抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="2. 抽象工厂模式（Abstract Factory Pattern）"></a>2. 抽象工厂模式（Abstract Factory Pattern）</h3><p>抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一种创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。这种模式属于对象创建型模式，它解决了在不指定对象具体类的情况下创建一系列相关或相互依赖的对象问题。</p><p>抽象工厂模式通常用于以下场景：</p><ul><li>一个系统要独立于它的产品的创建、组合和表示时</li><li>一个系统要由多个产品系列中的一个来配置时</li><li>强调一系列相关的产品对象的设计以便进行联合使用时</li><li>提供一个产品类库，只想显示它的接口而不是实现时</li></ul><p>下面是一个简单的 Swift 5 示例，展示了如何使用抽象工厂模式创建和使用不同系列的产品对象。假设我们需要创建一组不同的计算机，每台计算机包含 CPU 和主板，分为 Intel 和 AMD 两个系列。我们可以定义一个 <strong><code>AbstractFactory</code></strong> 协议，其中包含了创建 CPU 和主板的两个方法，然后定义两个具体的工厂类 <strong><code>IntelFactory</code></strong> 和 <strong><code>AMDFactory</code></strong> 分别实现该协议，以便创建相应系列的产品。最后，我们可以在客户端中使用工厂对象来创建所需的产品。</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 抽象产品协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">CPU</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Motherboard</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;&#125;<span class="hljs-comment">// 抽象工厂协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">AbstractFactory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createCPU</span>() -&gt; <span class="hljs-type">CPU</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createMotherboard</span>() -&gt; <span class="hljs-type">Motherboard</span>&#125;<span class="hljs-comment">// 具体产品</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCPU</span>: <span class="hljs-title class_">CPU</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Intel CPU&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelMotherboard</span>: <span class="hljs-title class_">Motherboard</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Intel Motherboard&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDCPU</span>: <span class="hljs-title class_">CPU</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AMD CPU&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDMotherboard</span>: <span class="hljs-title class_">Motherboard</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AMD Motherboard&quot;</span>    &#125;&#125;<span class="hljs-comment">// 具体工厂</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelFactory</span>: <span class="hljs-title class_">AbstractFactory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createCPU</span>() -&gt; <span class="hljs-type">CPU</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">IntelCPU</span>()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createMotherboard</span>() -&gt; <span class="hljs-type">Motherboard</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">IntelMotherboard</span>()    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">AMDFactory</span>: <span class="hljs-title class_">AbstractFactory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createCPU</span>() -&gt; <span class="hljs-type">CPU</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">AMDCPU</span>()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createMotherboard</span>() -&gt; <span class="hljs-type">Motherboard</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">AMDMotherboard</span>()    &#125;&#125;<span class="hljs-comment">// 客户端代码</span><span class="hljs-keyword">let</span> intelFactory <span class="hljs-operator">=</span> <span class="hljs-type">IntelFactory</span>()<span class="hljs-keyword">let</span> amdFactory <span class="hljs-operator">=</span> <span class="hljs-type">AMDFactory</span>()<span class="hljs-keyword">let</span> intelCPU <span class="hljs-operator">=</span> intelFactory.createCPU()<span class="hljs-keyword">let</span> intelMotherboard <span class="hljs-operator">=</span> intelFactory.createMotherboard()<span class="hljs-keyword">let</span> amdCPU <span class="hljs-operator">=</span> amdFactory.createCPU()<span class="hljs-keyword">let</span> amdMotherboard <span class="hljs-operator">=</span> amdFactory.createMotherboard()<span class="hljs-built_in">print</span>(intelCPU.name) <span class="hljs-comment">// 输出: Intel CPU</span><span class="hljs-built_in">print</span>(intelMotherboard.name) <span class="hljs-comment">// 输出: Intel Motherboard</span><span class="hljs-built_in">print</span>(amdCPU.name) <span class="hljs-comment">// 输出: AMD CPU</span><span class="hljs-built_in">print</span>(amdMotherboard.name) <span class="hljs-comment">// 输出: AMD Motherboard</span></code></pre></div></li></ul><h3 id="3-工厂方法模式（Factory-Method-Pattern）"><a href="#3-工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="3. 工厂方法模式（Factory Method Pattern）"></a>3. 工厂方法模式（Factory Method Pattern）</h3><p>工厂方法模式（Factory Method Pattern）是一种常用的创建型设计模式，它定义了一个用于创建对象的接口，但是让子类决定将哪一个类实例化，工厂方法模式让一个类的实例化延迟到其子类。</p><p>工厂方法模式可以很好地解决创建对象的问题，可以避免直接使用 <strong><code>new</code></strong> 这种方式创建对象，而是通过工厂方法来创建对象，这样可以避免代码中的耦合问题，增强代码的可扩展性和可维护性。</p><p>下面是一个使用 Swift 5 实现工厂方法模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 抽象产品</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;&#125;<span class="hljs-comment">// 具体产品 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductA</span>: <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product A&quot;</span> &#125;&#125;<span class="hljs-comment">// 具体产品 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductB</span>: <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product B&quot;</span> &#125;&#125;<span class="hljs-comment">// 抽象工厂</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Factory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createProduct</span>() -&gt; <span class="hljs-type">Product</span>&#125;<span class="hljs-comment">// 具体工厂 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryA</span>: <span class="hljs-title class_">Factory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createProduct</span>() -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">ProductA</span>()    &#125;&#125;<span class="hljs-comment">// 具体工厂 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FactoryB</span>: <span class="hljs-title class_">Factory</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createProduct</span>() -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">ProductB</span>()    &#125;&#125;<span class="hljs-comment">// 客户端代码</span><span class="hljs-keyword">let</span> factoryA <span class="hljs-operator">=</span> <span class="hljs-type">FactoryA</span>()<span class="hljs-keyword">let</span> factoryB <span class="hljs-operator">=</span> <span class="hljs-type">FactoryB</span>()<span class="hljs-keyword">let</span> productA <span class="hljs-operator">=</span> factoryA.createProduct()<span class="hljs-keyword">let</span> productB <span class="hljs-operator">=</span> factoryB.createProduct()<span class="hljs-built_in">print</span>(productA.name) <span class="hljs-comment">// &quot;Product A&quot;</span><span class="hljs-built_in">print</span>(productB.name) <span class="hljs-comment">// &quot;Product B&quot;</span></code></pre></div></li></ul><p>在这个示例代码中，我们定义了一个 <strong><code>Product</code></strong> 协议，其中包含一个 <strong><code>name</code></strong> 属性，用于表示产品的名称。然后，我们定义了两个具体产品 <strong><code>ProductA</code></strong> 和 **<code>ProductB</code>**，它们分别实现了 <strong><code>Product</code></strong> 协议。</p><p>接着，我们定义了一个 <strong><code>Factory</code></strong> 协议，其中包含一个 <strong><code>createProduct</code></strong> 方法，用于创建产品。然后，我们定义了两个具体工厂 <strong><code>FactoryA</code></strong> 和 **<code>FactoryB</code>**，它们分别实现了 <strong><code>Factory</code></strong> 协议，用于创建不同的产品。</p><p>最后，在客户端代码中，我们实例化了两个具体工厂 <strong><code>factoryA</code></strong> 和 **<code>factoryB</code>**，然后使用它们的 <strong><code>createProduct</code></strong> 方法来创建具体产品 <strong><code>productA</code></strong> 和 **<code>productB</code>**。通过这种方式，我们可以避免在客户端代码中直接使用 <strong><code>new</code></strong> 来创建对象，而是通过工厂方法来创建对象，从而提高了代码的可扩展性和可维护性。</p><h3 id="4-建造者模式（Builder-Pattern）"><a href="#4-建造者模式（Builder-Pattern）" class="headerlink" title="4. 建造者模式（Builder Pattern）"></a>4. 建造者模式（Builder Pattern）</h3><p>建造者模式（Builder Pattern）是一种创建型设计模式，它允许你创建复杂的对象，同时将其构造过程与表示分离。使用建造者模式可以将一个复杂对象的构建过程和表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式适用于以下情况：</p><ul><li>当需要创建的对象具有复杂的内部结构时，可以使用建造者模式将构造方法的调用顺序与属性的设置分离，从而降低代码的复杂度。</li><li>当需要构建不同属性的对象时，可以使用建造者模式来创建不同的属性组合。</li></ul><p>以下是使用 Swift 5 实现建造者模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// Product</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pizza</span> &#123;    <span class="hljs-keyword">var</span> dough: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">var</span> sauce: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">var</span> toppings: [<span class="hljs-type">String</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">func</span> <span class="hljs-title function_">showPizza</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Pizza with <span class="hljs-subst">\(dough)</span> dough, <span class="hljs-subst">\(sauce)</span> sauce and toppings: <span class="hljs-subst">\(toppings.joined(separator: <span class="hljs-string">&quot;, &quot;</span>))</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// Builder</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">PizzaBuilder</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addDough</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addSauce</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addToppings</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getPizza</span>() -&gt; <span class="hljs-type">Pizza</span>&#125;<span class="hljs-comment">// Concrete Builder</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MargheritaPizzaBuilder</span>: <span class="hljs-title class_">PizzaBuilder</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> pizza <span class="hljs-operator">=</span> <span class="hljs-type">Pizza</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addDough</span>() &#123;        pizza.dough <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Thin crust&quot;</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addSauce</span>() &#123;        pizza.sauce <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Tomato sauce&quot;</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addToppings</span>() &#123;        pizza.toppings <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;Mozzarella cheese&quot;</span>, <span class="hljs-string">&quot;Basil leaves&quot;</span>]    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getPizza</span>() -&gt; <span class="hljs-type">Pizza</span> &#123;        <span class="hljs-keyword">return</span> pizza    &#125;&#125;<span class="hljs-comment">// Director</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">PizzaDirector</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> builder: <span class="hljs-type">PizzaBuilder</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">builder</span>: <span class="hljs-type">PizzaBuilder</span>) &#123;        <span class="hljs-keyword">self</span>.builder <span class="hljs-operator">=</span> builder    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makePizza</span>() -&gt; <span class="hljs-type">Pizza</span> &#123;        builder.addDough()        builder.addSauce()        builder.addToppings()        <span class="hljs-keyword">return</span> builder.getPizza()    &#125;&#125;<span class="hljs-comment">// Client code</span><span class="hljs-keyword">let</span> margheritaBuilder <span class="hljs-operator">=</span> <span class="hljs-type">MargheritaPizzaBuilder</span>()<span class="hljs-keyword">let</span> pizzaDirector <span class="hljs-operator">=</span> <span class="hljs-type">PizzaDirector</span>(builder: margheritaBuilder)<span class="hljs-keyword">let</span> margheritaPizza <span class="hljs-operator">=</span> pizzaDirector.makePizza()margheritaPizza.showPizza()</code></pre></div></li></ul><p>在这个示例中，**<code>Pizza</code>** 是我们要创建的复杂对象，而 <strong><code>PizzaBuilder</code></strong> 协议定义了建造者应该具备的方法，包括添加面团、酱料和配料等。 <strong><code>MargheritaPizzaBuilder</code></strong> 是建造者的具体实现，它实现了 <strong><code>PizzaBuilder</code></strong> 协议中的方法，用于构建玛格丽特比萨。**<code>PizzaDirector</code>** 类负责管理建造者的调用顺序，它根据特定的建造者构建产品。最后，客户端代码使用建造者和指挥者来构建产品并将其展示出来。</p><h3 id="5-原型模式（Prototype-Pattern）"><a href="#5-原型模式（Prototype-Pattern）" class="headerlink" title="5. 原型模式（Prototype Pattern）"></a>5. 原型模式（Prototype Pattern）</h3><p>原型模式（Prototype Pattern）是一种创建型设计模式，它允许通过复制现有对象来创建新对象，而不必通过标准构造函数创建。该模式需要实现一个克隆方法，该方法克隆原型对象并返回副本。这使得客户端能够生成新对象，同时保留原始对象的状态。</p><p>原型模式通常用于创建复杂的对象，这些对象的创建过程比简单的构造函数调用要复杂得多。通常，创建这些对象需要许多步骤和复杂的算法，这些算法需要大量的计算和资源。在这种情况下，使用原型模式可以更有效地生成新对象，因为不需要在每次创建对象时重新计算它们。</p><p>下面是一个使用原型模式的简单示例，其中我们将克隆现有汽车对象以创建新对象。首先，我们需要创建一个“Car”协议，并实现克隆方法：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Car</span>: <span class="hljs-title class_">AnyObject</span>, <span class="hljs-title class_">NSCopying</span> &#123;    <span class="hljs-keyword">var</span> model: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;    <span class="hljs-keyword">var</span> color: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span> &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;&#125;<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Car</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">copy</span>(<span class="hljs-params">with</span> <span class="hljs-params">zone</span>: <span class="hljs-type">NSZone</span>? <span class="hljs-operator">=</span> <span class="hljs-literal">nil</span>) -&gt; <span class="hljs-keyword">Any</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">CarPrototype</span>(model: model, color: color, price: price)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CarPrototype</span>: <span class="hljs-title class_">Car</span> &#123;    <span class="hljs-keyword">var</span> model: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> color: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">model</span>: <span class="hljs-type">String</span>, <span class="hljs-params">color</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.model <span class="hljs-operator">=</span> model        <span class="hljs-keyword">self</span>.color <span class="hljs-operator">=</span> color        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price    &#125;&#125;</code></pre></div><p>在上面的代码中，我们定义了“Car”协议，并使用“CarPrototype”类实现了该协议。我们还使用“NSCopying”协议为该类提供了克隆方法。</p><p>接下来，我们将创建一个“CarFactory”类，该类将提供一些现有汽车对象，供客户端使用克隆方法生成新对象：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CarFactory</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> prototypes <span class="hljs-operator">=</span> [<span class="hljs-type">String</span>: <span class="hljs-type">Car</span>]()    <span class="hljs-keyword">init</span>() &#123;        prototypes[<span class="hljs-string">&quot;SUV&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-type">CarPrototype</span>(model: <span class="hljs-string">&quot;SUV&quot;</span>, color: <span class="hljs-string">&quot;Red&quot;</span>, price: <span class="hljs-number">50000</span>)        prototypes[<span class="hljs-string">&quot;Coupe&quot;</span>] <span class="hljs-operator">=</span> <span class="hljs-type">CarPrototype</span>(model: <span class="hljs-string">&quot;Coupe&quot;</span>, color: <span class="hljs-string">&quot;Blue&quot;</span>, price: <span class="hljs-number">80000</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">createCar</span>(<span class="hljs-params">ofType</span> <span class="hljs-params">type</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Car</span>? &#123;        <span class="hljs-keyword">return</span> prototypes[type]<span class="hljs-operator">?</span>.copy() <span class="hljs-keyword">as?</span> <span class="hljs-type">Car</span>    &#125;&#125;</code></pre></div><p>在上面的代码中，我们使用“prototypes”字典来存储现有的汽车对象。客户端可以使用“createCar(ofType:)”方法来获取现有汽车对象的副本，并生成新对象。</p><p>下面是一个示例，演示如何使用“CarFactory”类生成新的汽车对象：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> factory <span class="hljs-operator">=</span> <span class="hljs-type">CarFactory</span>()<span class="hljs-keyword">let</span> suv1 <span class="hljs-operator">=</span> factory.createCar(ofType: <span class="hljs-string">&quot;SUV&quot;</span>)<span class="hljs-keyword">let</span> suv2 <span class="hljs-operator">=</span> factory.createCar(ofType: <span class="hljs-string">&quot;SUV&quot;</span>)suv1<span class="hljs-operator">?</span>.model <span class="hljs-comment">// SUV</span>suv1<span class="hljs-operator">?</span>.color <span class="hljs-comment">// Red</span>suv1<span class="hljs-operator">?</span>.price <span class="hljs-comment">// 50000</span>suv2<span class="hljs-operator">?</span>.model <span class="hljs-comment">// SUV</span>suv2<span class="hljs-operator">?</span>.color <span class="hljs-comment">// Red</span>suv2<span class="hljs-operator">?</span>.price <span class="hljs-comment">// 50000</span></code></pre></div><h3 id="6-单例模式（Singleton-Pattern）"><a href="#6-单例模式（Singleton-Pattern）" class="headerlink" title="6. 单例模式（Singleton Pattern）"></a>6. 单例模式（Singleton Pattern）</h3><p>单例模式（Singleton Pattern）是一种创建型模式，它保证一个类只有一个实例，并提供一个全局访问点。</p><p>单例模式的常见应用场景包括：</p><ul><li>对于某些类，我们只需要有一个实例，比如系统的日志管理器、线程池、数据库连接池等；</li><li>想要跨越多个模块访问某些数据，可以将数据存储在单例对象中，以便于跨模块访问。</li></ul><p>在 Swift 中，可以使用静态变量或全局变量来实现单例模式，也可以使用结构体来实现。</p><p>以下是一个使用静态变量实现单例模式的例子：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared <span class="hljs-operator">=</span> <span class="hljs-type">Singleton</span>()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">init</span>() &#123;        <span class="hljs-comment">// 私有化初始化方法，避免在外部创建实例</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">someMethod</span>() &#123;        <span class="hljs-comment">// 单例类的其他方法</span>    &#125;&#125;</code></pre></div><p>在上面的例子中，我们使用一个名为 <strong><code>shared</code></strong> 的静态变量来保存唯一的实例。**<code>shared</code>** 变量在第一次访问时会触发 <strong><code>Singleton</code></strong> 类的初始化方法，而由于该方法是私有的，因此无法从外部创建实例。其他的方法则可以通过 <strong><code>Singleton.shared</code></strong> 来访问。由于 Swift 的静态变量是线程安全的，因此该实现方式可以保证单例模式的正确性。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24 种设计模式-2 (Swift 5版)</title>
    <link href="/2023/02/25/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-Swift-5%E7%89%88/"/>
    <url>/2023/02/25/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-2-Swift-5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="结构型模式（Structural-Patterns）"><a href="#结构型模式（Structural-Patterns）" class="headerlink" title="结构型模式（Structural Patterns）"></a>结构型模式（Structural Patterns）</h2><h3 id="1-适配器模式（Adapter-Pattern）"><a href="#1-适配器模式（Adapter-Pattern）" class="headerlink" title="1. 适配器模式（Adapter Pattern）"></a>1. 适配器模式（Adapter Pattern）</h3><p>适配器模式（Adapter Pattern）是一种结构型设计模式，用于将一个类的接口转换成客户端所期望的另一种接口。它允许两个不兼容的接口能够一起工作。</p><p>适配器模式常用来解决以下问题：</p><ol><li>系统需要复用一个已存在的类，但是其接口与系统所需要的接口不兼容。</li><li>不想修改现有的接口，但是需要创建一个新的类能够调用现有类的接口。</li><li>两个不兼容的类需要协同工作，但是不能直接修改它们的接口。</li></ol><p>在适配器模式中，适配器充当中间人角色，它接收来自客户端的请求并将其转换为被适配对象的请求。适配器模式可以分为两种类型：对象适配器和类适配器。对象适配器使用组合的方式连接适配器和被适配对象，类适配器使用继承的方式连接适配器和被适配对象。</p><p>以下是一个使用对象适配器的 Swift 5 代码示例，用于将一个高级音乐播放器的接口适配成一个简单音乐播放器的接口：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 被适配的高级音乐播放器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdvancedMediaPlayer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">playVlc</span>(<span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Playing vlc file. Name: <span class="hljs-subst">\(fileName)</span>&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">playMp4</span>(<span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Playing mp4 file. Name: <span class="hljs-subst">\(fileName)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 简单音乐播放器的接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">MediaPlayer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>(<span class="hljs-params">audioType</span>: <span class="hljs-type">String</span>, <span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>)&#125;<span class="hljs-comment">// 对象适配器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MediaAdapter</span>: <span class="hljs-title class_">MediaPlayer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> advancedMediaPlayer: <span class="hljs-type">AdvancedMediaPlayer</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">advancedMediaPlayer</span>: <span class="hljs-type">AdvancedMediaPlayer</span>) &#123;        <span class="hljs-keyword">self</span>.advancedMediaPlayer <span class="hljs-operator">=</span> advancedMediaPlayer    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>(<span class="hljs-params">audioType</span>: <span class="hljs-type">String</span>, <span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">if</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;vlc&quot;</span> &#123;            advancedMediaPlayer.playVlc(fileName: fileName)        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;mp4&quot;</span> &#123;            advancedMediaPlayer.playMp4(fileName: fileName)        &#125;    &#125;&#125;<span class="hljs-comment">// 简单音乐播放器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AudioPlayer</span>: <span class="hljs-title class_">MediaPlayer</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mediaAdapter: <span class="hljs-type">MediaAdapter</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">play</span>(<span class="hljs-params">audioType</span>: <span class="hljs-type">String</span>, <span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">if</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;mp3&quot;</span> &#123;            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Playing mp3 file. Name: <span class="hljs-subst">\(fileName)</span>&quot;</span>)        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;vlc&quot;</span> <span class="hljs-operator">||</span> audioType <span class="hljs-operator">==</span> <span class="hljs-string">&quot;mp4&quot;</span> &#123;            mediaAdapter <span class="hljs-operator">=</span> <span class="hljs-type">MediaAdapter</span>(advancedMediaPlayer: <span class="hljs-type">AdvancedMediaPlayer</span>())            mediaAdapter<span class="hljs-operator">?</span>.play(audioType: audioType, fileName: fileName)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Invalid media. <span class="hljs-subst">\(audioType)</span> format not supported&quot;</span>)        &#125;    &#125;&#125;</code></pre></div></li></ul><p>在上面的示例中，**<code>AdvancedMediaPlayer</code>** 是被适配的类，它的接口与 <strong><code>MediaPlayer</code></strong> 接口不兼容。**<code>MediaAdapter</code>** 是适配器，它使用组合的方式连接 <strong><code>AdvancedMediaPlayer</code></strong> 和 **<code>MediaPlayer</code>**，并将 <strong><code>AdvancedMediaPlayer</code></strong> </p><h3 id="2-桥接模式（Bridge-Pattern）"><a href="#2-桥接模式（Bridge-Pattern）" class="headerlink" title="2. 桥接模式（Bridge Pattern）"></a>2. 桥接模式（Bridge Pattern）</h3><p>桥接模式（Bridge Pattern）是一种结构型设计模式，用于将抽象部分与实现部分分离，使它们可以独立地变化，从而降低它们之间的耦合度。</p><p>桥接模式常用于需要多个不同平台、不同类型的类之间协同工作的场景，它能够通过将这些类的不同维度分离来实现这个目的，从而使得这些类可以在系统中独立地变化。</p><p>具体实现上，桥接模式通过在抽象层和实现层之间增加一个桥接接口（Bridge），来将抽象层和实现层分离。这个桥接接口通常包含了一些基本操作，而抽象层和实现层分别继承这个桥接接口，从而能够相互协作。</p><p>以下是一个使用桥接模式的 Swift 5 代码示例，其中将一个图形对象的绘制行为和图形类型进行分离：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 实现层</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Drawer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>)&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleDrawer</span>: <span class="hljs-title class_">Drawer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Draw Circle at (<span class="hljs-subst">\(x)</span>, <span class="hljs-subst">\(y)</span>) with radius <span class="hljs-subst">\(radius)</span>&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareDrawer</span>: <span class="hljs-title class_">Drawer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Draw Square at (<span class="hljs-subst">\(x)</span>, <span class="hljs-subst">\(y)</span>) with radius <span class="hljs-subst">\(radius)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 抽象层</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">let</span> x: <span class="hljs-type">Double</span>    <span class="hljs-keyword">let</span> y: <span class="hljs-type">Double</span>    <span class="hljs-keyword">let</span> radius: <span class="hljs-type">Double</span>    <span class="hljs-keyword">let</span> drawer: <span class="hljs-type">Drawer</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">drawer</span>: <span class="hljs-type">Drawer</span>) &#123;        <span class="hljs-keyword">self</span>.x <span class="hljs-operator">=</span> x        <span class="hljs-keyword">self</span>.y <span class="hljs-operator">=</span> y        <span class="hljs-keyword">self</span>.radius <span class="hljs-operator">=</span> radius        <span class="hljs-keyword">self</span>.drawer <span class="hljs-operator">=</span> drawer    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() &#123;        drawer.draw(x: x, y: y, radius: radius)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(x: x, y: y, radius: radius, drawer: <span class="hljs-type">CircleDrawer</span>())    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">convenience</span> <span class="hljs-keyword">init</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(x: x, y: y, radius: radius, drawer: <span class="hljs-type">SquareDrawer</span>())    &#125;&#125;<span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(x: <span class="hljs-number">10</span>, y: <span class="hljs-number">20</span>, radius: <span class="hljs-number">5</span>)<span class="hljs-keyword">let</span> square <span class="hljs-operator">=</span> <span class="hljs-type">Square</span>(x: <span class="hljs-number">30</span>, y: <span class="hljs-number">40</span>, radius: <span class="hljs-number">5</span>)circle.draw()square.draw()</code></pre></div></li></ul><p>在上面的示例中，**<code>Drawer</code>** 接口定义了绘制图形的基本操作，**<code>CircleDrawer</code>** 和 <strong><code>SquareDrawer</code></strong> 则是具体的绘制实现。**<code>Shape</code>** 类则代表图形对象，它包含了一个 <strong><code>Drawer</code></strong> 类型的属性，用于绘制该图形对象。**<code>Circle</code>** 和 <strong><code>Square</code></strong> 类是具体的图形类型，它们继承自 <strong><code>Shape</code></strong> 类，并在初始化时传入不同的绘制实现。</p><p>最后当需要创建多个平行的类层次结构，其中一个是实现平台相关代码，另一个是提供跨平台的通用接口，而且这些类层次结构之间的联系需要在运行时建立时，就可以考虑使用桥接模式。</p><p>桥接模式的核心思想是将抽象部分与其实现部分分离，以便它们可以独立变化。它允许抽象部分与其实现部分独立扩展，从而提高了系统的可扩展性和灵活性。在桥接模式中，抽象部分通常是指一个抽象类或接口，实现部分通常是指一个具体类。</p><p>举个例子，假设我们要设计一个跨平台的绘图软件，支持在不同的操作系统上运行，并且支持不同的绘图形式。我们可以使用桥接模式来设计这个软件，将绘图形式和操作系统分别作为抽象和实现，从而允许在运行时动态地组合不同的抽象和实现。</p><p>以下是一个简单的使用桥接模式的 Swift 5 代码示例：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">DrawingAPI</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drawCircle</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>)&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DrawingAPI1</span>: <span class="hljs-title class_">DrawingAPI</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drawCircle</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;API1.circle at (<span class="hljs-subst">\(x)</span>:<span class="hljs-subst">\(y)</span>) radius <span class="hljs-subst">\(radius)</span>&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">DrawingAPI2</span>: <span class="hljs-title class_">DrawingAPI</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">drawCircle</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;API2.circle at (<span class="hljs-subst">\(x)</span>:<span class="hljs-subst">\(y)</span>) radius <span class="hljs-subst">\(radius)</span>&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">var</span> drawingAPI: <span class="hljs-type">DrawingAPI</span>?    <span class="hljs-keyword">init</span>(<span class="hljs-params">drawingAPI</span>: <span class="hljs-type">DrawingAPI</span>) &#123;        <span class="hljs-keyword">self</span>.drawingAPI <span class="hljs-operator">=</span> drawingAPI    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() &#123;        <span class="hljs-built_in">preconditionFailure</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleShape</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">var</span> x: <span class="hljs-type">Int</span>    <span class="hljs-keyword">var</span> y: <span class="hljs-type">Int</span>    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">x</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">y</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">radius</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">drawingAPI</span>: <span class="hljs-type">DrawingAPI</span>) &#123;        <span class="hljs-keyword">self</span>.x <span class="hljs-operator">=</span> x        <span class="hljs-keyword">self</span>.y <span class="hljs-operator">=</span> y        <span class="hljs-keyword">self</span>.radius <span class="hljs-operator">=</span> radius        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(drawingAPI: drawingAPI)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>() &#123;        drawingAPI<span class="hljs-operator">?</span>.drawCircle(x: x, y: y, radius: radius)    &#125;&#125;<span class="hljs-keyword">let</span> shapes <span class="hljs-operator">=</span> [    <span class="hljs-type">CircleShape</span>(x: <span class="hljs-number">1</span>, y: <span class="hljs-number">2</span>, radius: <span class="hljs-number">3</span>, drawingAPI: <span class="hljs-type">DrawingAPI1</span>()),    <span class="hljs-type">CircleShape</span>(x: <span class="hljs-number">5</span>, y: <span class="hljs-number">7</span>, radius: <span class="hljs-number">11</span>, drawingAPI: <span class="hljs-type">DrawingAPI2</span>()),]<span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes &#123;    shape.draw()&#125;</code></pre></div></li></ul><p>在上面的代码中，我们首先定义了一个名为 <strong><code>DrawingAPI</code></strong> 的抽象类或接口，该类包含了一个名为 <strong><code>drawCircle</code></strong> 的抽象方法。然后，我们分别实现了 <strong><code>DrawingAPI1</code></strong> 和 <strong><code>DrawingAPI2</code></strong> 这两个具体类，它们分别表示不同的绘图 API。</p><h3 id="3-组合模式（Composite-Pattern）"><a href="#3-组合模式（Composite-Pattern）" class="headerlink" title="3. 组合模式（Composite Pattern）"></a>3. 组合模式（Composite Pattern）</h3><p>组合模式（Composite Pattern）是一种结构型设计模式，它允许你将对象组合成树形结构，以表示”部分-整体”的层次关系。组合模式可以让客户端统一处理单个对象和组合对象，从而简化代码。</p><p>组合模式通常用于以下场景：</p><ul><li>需要表示对象的层次结构，且每个对象都具有相同的接口。</li><li>需要统一处理单个对象和组合对象，而不需要显式区分它们。</li><li>需要对对象进行递归组合，从而能够处理复杂的树形结构。</li></ul><p>下面是使用 Swift 5 实现组合模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">depth</span>: <span class="hljs-type">Int</span>)&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span>: <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> _name    &#125;    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;        _name <span class="hljs-operator">=</span> name    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>) &#123;        <span class="hljs-comment">// Leaf 类型不能添加子节点，因此不需要实现该方法</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>) &#123;        <span class="hljs-comment">// Leaf 类型不能删除子节点，因此不需要实现该方法</span>    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">depth</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(repeating: <span class="hljs-string">&quot;-&quot;</span>, count: depth) <span class="hljs-operator">+</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-operator">+</span> name)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Composite</span>: <span class="hljs-title class_">Component</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> _name: <span class="hljs-type">String</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _children <span class="hljs-operator">=</span> [<span class="hljs-type">Component</span>]()    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> _name    &#125;    <span class="hljs-keyword">init</span>(<span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;        _name <span class="hljs-operator">=</span> name    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>) &#123;        _children.append(component)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">component</span>: <span class="hljs-type">Component</span>) &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> _children.firstIndex(where: &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">===</span> component &#125;) &#123;            _children.remove(at: index)        &#125;    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">depth</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-type">String</span>(repeating: <span class="hljs-string">&quot;-&quot;</span>, count: depth) <span class="hljs-operator">+</span> <span class="hljs-string">&quot; &quot;</span> <span class="hljs-operator">+</span> name)        _children.forEach &#123; <span class="hljs-variable">$0</span>.display(depth: depth <span class="hljs-operator">+</span> <span class="hljs-number">2</span>) &#125;    &#125;&#125;<span class="hljs-comment">// 使用示例</span><span class="hljs-keyword">let</span> root <span class="hljs-operator">=</span> <span class="hljs-type">Composite</span>(name: <span class="hljs-string">&quot;root&quot;</span>)root.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf A&quot;</span>))root.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf B&quot;</span>))<span class="hljs-keyword">let</span> compositeX <span class="hljs-operator">=</span> <span class="hljs-type">Composite</span>(name: <span class="hljs-string">&quot;Composite X&quot;</span>)compositeX.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf XA&quot;</span>))compositeX.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf XB&quot;</span>))root.add(component: compositeX)<span class="hljs-keyword">let</span> compositeY <span class="hljs-operator">=</span> <span class="hljs-type">Composite</span>(name: <span class="hljs-string">&quot;Composite Y&quot;</span>)compositeY.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf YA&quot;</span>))compositeY.add(component: <span class="hljs-type">Leaf</span>(name: <span class="hljs-string">&quot;Leaf YB&quot;</span>))compositeX.add(component: compositeY)root.display(depth: <span class="hljs-number">1</span>)</code></pre></div></li></ul><p>在这个示例中，**<code>Component</code>** 是组合模式的抽象基类，包含了所有叶子节点和组合节点都具有的方法和属性。**<code>Leaf</code>** 是叶子节点的具体实现，它不能添加子节点。**<code>Composite</code>** 是组合节点的具体实现，它可以添加和删除子节点，并递归调用子节点的 <strong><code>display</code></strong> 方法。</p><h3 id="4-装饰模式（Decorator-Pattern）"><a href="#4-装饰模式（Decorator-Pattern）" class="headerlink" title="4. 装饰模式（Decorator Pattern）"></a>4. 装饰模式（Decorator Pattern）</h3><p>装饰模式（Decorator Pattern）是一种结构型设计模式，它允许你在不改变对象自身的基础上动态地给对象添加新的行为。它通常被用来解决在不改变现有代码的情况下，动态地给对象添加新的功能或行为。</p><p>装饰模式的核心思想是在运行时通过一系列的装饰器包裹原始对象来实现功能的添加。每个装饰器都与被包裹的对象实现相同的接口，因此可以在不修改原始对象的情况下添加新的行为。</p><p>下面是一个使用 Swift 5 实现装饰模式的例子，假设我们有一个 <strong><code>Beverage</code></strong> 协议表示饮料，我们想要给饮料添加调料的功能，我们可以使用装饰模式来实现：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 饮料协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123; <span class="hljs-keyword">get</span> &#125;    <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123; <span class="hljs-keyword">get</span> &#125;&#125;<span class="hljs-comment">// 浓缩咖啡类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Espresso</span>: <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Espresso&quot;</span>    &#125;    <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1.99</span>    &#125;&#125;<span class="hljs-comment">// 调料装饰器基类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">CondimentDecorator</span>: <span class="hljs-title class_">Beverage</span> &#123;    <span class="hljs-keyword">let</span> beverage: <span class="hljs-type">Beverage</span>    <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> beverage.description    &#125;    <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> beverage.cost    &#125;    <span class="hljs-keyword">init</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">beverage</span>: <span class="hljs-type">Beverage</span>) &#123;        <span class="hljs-keyword">self</span>.beverage <span class="hljs-operator">=</span> beverage    &#125;&#125;<span class="hljs-comment">// 摩卡调料装饰器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mocha</span>: <span class="hljs-title class_">CondimentDecorator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">\(beverage.description)</span>, Mocha&quot;</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0.20</span> <span class="hljs-operator">+</span> beverage.cost    &#125;&#125;<span class="hljs-comment">// 奶泡调料装饰器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Whip</span>: <span class="hljs-title class_">CondimentDecorator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> description: <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;<span class="hljs-subst">\(beverage.description)</span>, Whip&quot;</span>    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">var</span> cost: <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">0.10</span> <span class="hljs-operator">+</span> beverage.cost    &#125;&#125;</code></pre></div></li></ul><p>在上面的例子中，**<code>Beverage</code>** 协议定义了一个饮料的接口，其中包含一个 <strong><code>description</code></strong> 属性表示饮料的描述和一个 <strong><code>cost</code></strong> 属性表示饮料的价格。**<code>Espresso</code>** 类是一种饮料，实现了 <strong><code>Beverage</code></strong> 协议。</p><p><strong><code>CondimentDecorator</code></strong> 类是装饰器的基类，实现了 <strong><code>Beverage</code></strong> 协议，它包含一个指向被装饰的饮料的引用，并且提供了默认的 <strong><code>description</code></strong> 和 <strong><code>cost</code></strong> 实现。**<code>Mocha</code>** 和 <strong><code>Whip</code></strong> 类是具体的装饰器类，它们继承自 <strong><code>CondimentDecorator</code></strong> 并且实现了自己的 <strong><code>description</code></strong> 和 <strong><code>cost</code></strong> 方法来添加新的行为。</p><p>使用装饰模式，我们可以像下面这样使用装饰器来装饰原始的饮料对象：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> beverage: <span class="hljs-type">Beverage</span> <span class="hljs-operator">=</span> <span class="hljs-type">Espresso</span>()<span class="hljs-comment">//现在我们已经创建了一个 Espresso 饮料对象，接下来我们可以使用 Mocha 和 Whip 装饰器来添加新的行为：</span><span class="hljs-keyword">let</span> mocha: <span class="hljs-type">Beverage</span> <span class="hljs-operator">=</span> <span class="hljs-type">Mocha</span>(beverage)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(mocha.description)</span> $<span class="hljs-subst">\(mocha.cost)</span>&quot;</span>)<span class="hljs-keyword">let</span> whip: <span class="hljs-type">Beverage</span> <span class="hljs-operator">=</span> <span class="hljs-type">Whip</span>(mocha)<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(whip.description)</span> $<span class="hljs-subst">\(whip.cost)</span>&quot;</span>)</code></pre></div><p>在上面的代码中，我们先用 <strong><code>Mocha</code></strong> 装饰器包裹了原始的 <strong><code>Espresso</code></strong> 对象，然后使用 <strong><code>Whip</code></strong> 装饰器包裹了 <strong><code>Mocha</code></strong> 对象。最终，我们得到了一个包含 <strong><code>Espresso</code><strong>、</strong><code>Mocha</code></strong> 和 <strong><code>Whip</code></strong> 的新的饮料对象，并且可以输出其描述和价格。</p><p>装饰器模式的优点在于它允许你在不改变原始对象的情况下，动态地添加新的行为。这使得代码更加灵活，因为你可以通过组合不同的装饰器来创建各种不同的对象。另外，装饰器模式还遵循开闭原则，因为你可以添加新的装饰器而不必修改现有的代码。</p><p>当然，装饰器模式并不适用于所有情况。如果你需要对对象进行大量的装饰操作，可能会导致代码变得难以维护。此外，在某些情况下，可能更好的解决方案是使用继承来扩展对象的功能，而不是使用装饰器模式。</p><h3 id="5-外观模式（Facade-Pattern）"><a href="#5-外观模式（Facade-Pattern）" class="headerlink" title="5. 外观模式（Facade Pattern）"></a>5. 外观模式（Facade Pattern）</h3><p>外观模式（Facade Pattern）是一种设计模式，它提供了一个简单的接口，用于隐藏复杂系统的复杂性。它的主要目的是为客户端代码提供一个简单的接口，使其可以访问复杂系统的功能，而不需要了解系统的内部实现细节。</p><p>外观模式通常用于以下情况：</p><ul><li>当一个系统的复杂性使得它的实现变得困难时，可以使用外观模式来简化接口。</li><li>当需要将一个复杂系统划分为更小的子系统时，可以使用外观模式来创建更简单的接口。</li></ul><p>以下是一个使用 Swift 5 实现外观模式的示例：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 复杂系统的子系统</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsystemA</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationA</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Subsystem A operation&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsystemB</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationB</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Subsystem B operation&quot;</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SubsystemC</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationC</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Subsystem C operation&quot;</span>    &#125;&#125;<span class="hljs-comment">// 定义外观接口</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Facade</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> subsystemA <span class="hljs-operator">=</span> <span class="hljs-type">SubsystemA</span>()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> subsystemB <span class="hljs-operator">=</span> <span class="hljs-type">SubsystemB</span>()    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> subsystemC <span class="hljs-operator">=</span> <span class="hljs-type">SubsystemC</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operation</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">var</span> result <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Facade initializes subsystems:<span class="hljs-subst">\n</span>&quot;</span>        result <span class="hljs-operator">+=</span> subsystemA.operationA()        result <span class="hljs-operator">+=</span> subsystemB.operationB()        result <span class="hljs-operator">+=</span> subsystemC.operationC()        <span class="hljs-keyword">return</span> result    &#125;&#125;<span class="hljs-comment">// 客户端代码使用外观接口</span><span class="hljs-keyword">let</span> facade <span class="hljs-operator">=</span> <span class="hljs-type">Facade</span>()<span class="hljs-built_in">print</span>(facade.operation())</code></pre></div><p>在这个示例中，**<code>SubsystemA</code><strong>、</strong><code>SubsystemB</code>** 和 <strong><code>SubsystemC</code></strong> 是一个复杂系统的三个子系统。**<code>Facade</code>** 提供了一个简单的接口来初始化这些子系统，并在客户端代码中使用。客户端代码只需要使用 <strong><code>Facade</code></strong> 对象的 <strong><code>operation()</code></strong> 方法来调用子系统的操作，而不需要了解每个子系统的内部实现细节。</p><h3 id="6-享元模式（Flyweight-Pattern）"><a href="#6-享元模式（Flyweight-Pattern）" class="headerlink" title="6. 享元模式（Flyweight Pattern）"></a>6. 享元模式（Flyweight Pattern）</h3><p>享元模式（Flyweight Pattern）是一种设计模式，它通过共享相似对象来最小化内存使用和提高性能。这个模式适用于需要创建大量对象的情况，但又不想消耗过多内存的场景。</p><p>具体来说，享元模式的核心思想是将对象分为两部分：内部状态（Intrinsic State）和外部状态（Extrinsic State）。其中，内部状态是可以共享的，外部状态是根据需要变化的。这样，在创建对象时，只需创建一部分对象并将其共享，可以显著减少内存消耗。</p><p>在实际应用中，享元模式经常用于优化大规模数据处理、图形渲染等领域。</p><p>下面是使用 Swift 5 实现享元模式的示例代码：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义享元协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Flyweight</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operation</span>(<span class="hljs-params">extrinsicState</span>: <span class="hljs-type">Int</span>)&#125;<span class="hljs-comment">// 具体享元类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteFlyweight</span>: <span class="hljs-title class_">Flyweight</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> intrinsicState: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">intrinsicState</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.intrinsicState <span class="hljs-operator">=</span> intrinsicState    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operation</span>(<span class="hljs-params">extrinsicState</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Intrinsic state: <span class="hljs-subst">\(intrinsicState)</span>, Extrinsic state: <span class="hljs-subst">\(extrinsicState)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 享元工厂</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">FlyweightFactory</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> flyweights <span class="hljs-operator">=</span> [<span class="hljs-type">String</span>: <span class="hljs-type">Flyweight</span>]()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getFlyweight</span>(<span class="hljs-params">intrinsicState</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Flyweight</span> &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> flyweight <span class="hljs-operator">=</span> flyweights[intrinsicState] &#123;            <span class="hljs-keyword">return</span> flyweight        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">let</span> flyweight <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteFlyweight</span>(intrinsicState: intrinsicState)            flyweights[intrinsicState] <span class="hljs-operator">=</span> flyweight            <span class="hljs-keyword">return</span> flyweight        &#125;    &#125;&#125;<span class="hljs-comment">// 使用享元模式</span><span class="hljs-keyword">let</span> factory <span class="hljs-operator">=</span> <span class="hljs-type">FlyweightFactory</span>()<span class="hljs-keyword">let</span> flyweight1 <span class="hljs-operator">=</span> factory.getFlyweight(intrinsicState: <span class="hljs-string">&quot;A&quot;</span>)flyweight1.operation(extrinsicState: <span class="hljs-number">1</span>) <span class="hljs-comment">// Intrinsic state: A, Extrinsic state: 1</span><span class="hljs-keyword">let</span> flyweight2 <span class="hljs-operator">=</span> factory.getFlyweight(intrinsicState: <span class="hljs-string">&quot;B&quot;</span>)flyweight2.operation(extrinsicState: <span class="hljs-number">2</span>) <span class="hljs-comment">// Intrinsic state: B, Extrinsic state: 2</span><span class="hljs-keyword">let</span> flyweight3 <span class="hljs-operator">=</span> factory.getFlyweight(intrinsicState: <span class="hljs-string">&quot;A&quot;</span>)flyweight3.operation(extrinsicState: <span class="hljs-number">3</span>) <span class="hljs-comment">// Intrinsic state: A, Extrinsic state: 3</span></code></pre></div></li></ul><p>在上面的示例中，我们定义了一个 <strong><code>Flyweight</code></strong> 协议，具体享元类 <strong><code>ConcreteFlyweight</code></strong> 实现了这个协议。**<code>FlyweightFactory</code>** 是享元工厂类，用于创建和管理享元对象。在使用时，我们可以通过工厂类获取享元对象，并在其中设置外部状态。由于相同的内部状态只会被创建一次，因此 <strong><code>flyweight1</code></strong> 和 <strong><code>flyweight3</code></strong> 实际上是同一个对象，可以共享使用。</p><h3 id="7-代理模式（Proxy-Pattern）"><a href="#7-代理模式（Proxy-Pattern）" class="headerlink" title="7. 代理模式（Proxy Pattern）"></a>7. 代理模式（Proxy Pattern）</h3><p>代理模式是一种结构型设计模式，它允许你提供一个代理对象来控制对另一个对象的访问。</p><p>代理对象充当原始对象的接口，它可以处理客户端的请求并在必要时将请求传递给原始对象。代理模式常用于以下场景：</p><ul><li>远程代理：允许客户端通过网络访问远程对象，例如远程服务API。</li><li>虚拟代理：在需要时创建开销很大的对象，例如一个大型图片或者视频对象。</li><li>保护代理：控制对敏感对象的访问，例如在用户没有权限的情况下禁止修改数据。</li></ul><p>下面是一个使用 Swift 5 代码实现虚拟代理的示例：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Image</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>()&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RealImage</span>: <span class="hljs-title class_">Image</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> fileName: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.fileName <span class="hljs-operator">=</span> fileName        loadFromDisk()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Displaying <span class="hljs-subst">\(fileName)</span>&quot;</span>)    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">loadFromDisk</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Loading <span class="hljs-subst">\(fileName)</span> from disk&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageProxy</span>: <span class="hljs-title class_">Image</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> realImage: <span class="hljs-type">RealImage</span>?    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> fileName: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">fileName</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.fileName <span class="hljs-operator">=</span> fileName    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">display</span>() &#123;        <span class="hljs-keyword">if</span> realImage <span class="hljs-operator">==</span> <span class="hljs-literal">nil</span> &#123;            realImage <span class="hljs-operator">=</span> <span class="hljs-type">RealImage</span>(fileName: fileName)        &#125;        realImage<span class="hljs-operator">?</span>.display()    &#125;&#125;<span class="hljs-comment">// Usage</span><span class="hljs-keyword">let</span> image <span class="hljs-operator">=</span> <span class="hljs-type">ImageProxy</span>(fileName: <span class="hljs-string">&quot;test.jpg&quot;</span>)image.display()</code></pre></div></li></ul><p>在这个示例中，**<code>RealImage</code>** 类表示一个真实的图片对象，它负责加载和显示图片。**<code>ImageProxy</code>** 类则是一个代理，它代表了一个 <strong><code>RealImage</code></strong> 对象并控制了对它的访问。当 <strong><code>ImageProxy</code></strong> 对象的 <strong><code>display</code></strong> 方法被调用时，它会先检查 <strong><code>realImage</code></strong> 是否已经存在。如果 <strong><code>realImage</code></strong> 不存在，那么它会创建一个 <strong><code>RealImage</code></strong> 对象并将其存储在 <strong><code>realImage</code></strong> 中，然后调用 <strong><code>display</code></strong> 方法。如果 <strong><code>realImage</code></strong> 已经存在，那么它将直接调用 <strong><code>realImage</code></strong> 的 <strong><code>display</code></strong> 方法。</p><p>这个示例展示了代理模式如何允许你使用代理对象来控制对另一个对象的访问。在这个示例中，**<code>ImageProxy</code>** 充当了 <strong><code>RealImage</code></strong> 的接口，并在必要时创建了一个 <strong><code>RealImage</code></strong> 对象。这使得客户端无需知道 <strong><code>RealImage</code></strong> 的实际细节，从而简化了系统的设计。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24 种设计模式-3 (Swift 5版)</title>
    <link href="/2023/02/25/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-Swift-5%E7%89%88/"/>
    <url>/2023/02/25/24-%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-3-Swift-5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<h2 id="行为型模式（Behavioral-Patterns）"><a href="#行为型模式（Behavioral-Patterns）" class="headerlink" title="行为型模式（Behavioral Patterns）"></a>行为型模式（Behavioral Patterns）</h2><h3 id="1-模板方法模式（Template-Method-Pattern）"><a href="#1-模板方法模式（Template-Method-Pattern）" class="headerlink" title="1. 模板方法模式（Template Method Pattern）"></a>1. 模板方法模式（Template Method Pattern）</h3><p>模板方法模式是一种行为设计模式，其目的是定义一个算法的骨架，而将一些步骤延迟到子类中实现。在模板方法模式中，一个抽象类公开定义了执行它的方法的方式&#x2F;步骤，但是没有实现这些步骤，这些步骤由子类实现。</p><p>常用来解决的问题是在一个算法中保持不变的部分在父类中实现，而可变的部分在子类中实现，这样可以避免重复的代码，并且方便扩展。</p><p>下面是一个使用 Swift 5 实现模板方法模式的示例：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">prepareRecipe</span>() &#123;        boilWater()        brew()        pourInCup()        addCondiments()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">boilWater</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Boiling water&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pourInCup</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Pouring into cup&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">brew</span>() &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCondiments</span>() &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeWithSugar</span>: <span class="hljs-title class_">Coffee</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">brew</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Brewing coffee&quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCondiments</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Adding sugar&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeWithMilk</span>: <span class="hljs-title class_">Coffee</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">brew</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Brewing coffee&quot;</span>)    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">addCondiments</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Adding milk&quot;</span>)    &#125;&#125;</code></pre></div><p>在上面的示例中，Coffee 是抽象类，定义了 prepareRecipe() 方法的骨架，以及 boilWater() 和 pourInCup() 这两个步骤的具体实现。其中，brew() 和 addCondiments() 方法都是抽象的，需要在子类中实现。</p><p>CoffeeWithSugar 和 CoffeeWithMilk 是两个具体的子类，分别实现了 brew() 和 addCondiments() 方法。这样，通过调用 CoffeeWithSugar 和 CoffeeWithMilk 的 prepareRecipe() 方法，就可以制作出带糖和带牛奶的咖啡了。</p><p>下面是示例代码的运行结果：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> coffeeWithSugar <span class="hljs-operator">=</span> <span class="hljs-type">CoffeeWithSugar</span>()coffeeWithSugar.prepareRecipe()<span class="hljs-keyword">let</span> coffeeWithMilk <span class="hljs-operator">=</span> <span class="hljs-type">CoffeeWithMilk</span>()coffeeWithMilk.prepareRecipe()</code></pre></div><p>输出结果：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-type">Boiling</span> water<span class="hljs-type">Brewing</span> coffee<span class="hljs-type">Pouring</span> into cup<span class="hljs-type">Adding</span> sugar<span class="hljs-type">Boiling</span> water<span class="hljs-type">Brewing</span> coffee<span class="hljs-type">Pouring</span> into cup<span class="hljs-type">Adding</span> milk</code></pre></div><h3 id="2-策略模式（Strategy-Pattern）"><a href="#2-策略模式（Strategy-Pattern）" class="headerlink" title="2. 策略模式（Strategy Pattern）"></a>2. 策略模式（Strategy Pattern）</h3><p>策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时动态地选择算法或行为，以解决相似问题的多种解决方案。</p><p>通常，当我们需要实现某种算法或行为，但可能有多种实现方式时，策略模式就非常有用了。使用该模式可以在运行时根据需求选择不同的算法或行为，而不必在代码中硬编码。</p><p>下面是一个使用 Swift 5 实现策略模式的示例，假设我们有一个飞行器接口 **<code>Flyable</code>**，我们需要实现不同的飞行策略，包括直升飞机、固定翼飞机和火箭。</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 飞行器接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Flyable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>()&#125;<span class="hljs-comment">// 直升飞机策略</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelicopterStrategy</span>: <span class="hljs-title class_">Flyable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;直升飞机在空中盘旋。&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 固定翼飞机策略</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirplaneStrategy</span>: <span class="hljs-title class_">Flyable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;固定翼飞机在天空中飞行。&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 火箭策略</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">RocketStrategy</span>: <span class="hljs-title class_">Flyable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;火箭在太空中飞行。&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 飞行器类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Aircraft</span> &#123;    <span class="hljs-keyword">var</span> flyStrategy: <span class="hljs-type">Flyable</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">strategy</span>: <span class="hljs-type">Flyable</span>) &#123;        <span class="hljs-keyword">self</span>.flyStrategy <span class="hljs-operator">=</span> strategy    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">fly</span>() &#123;        <span class="hljs-keyword">self</span>.flyStrategy.fly()    &#125;&#125;<span class="hljs-comment">// 使用示例</span><span class="hljs-keyword">let</span> helicopter <span class="hljs-operator">=</span> <span class="hljs-type">Aircraft</span>(strategy: <span class="hljs-type">HelicopterStrategy</span>())helicopter.fly()  <span class="hljs-comment">// 输出: 直升飞机在空中盘旋。</span><span class="hljs-keyword">let</span> airplane <span class="hljs-operator">=</span> <span class="hljs-type">Aircraft</span>(strategy: <span class="hljs-type">AirplaneStrategy</span>())airplane.fly()  <span class="hljs-comment">// 输出: 固定翼飞机在天空中飞行。</span><span class="hljs-keyword">let</span> rocket <span class="hljs-operator">=</span> <span class="hljs-type">Aircraft</span>(strategy: <span class="hljs-type">RocketStrategy</span>())rocket.fly()  <span class="hljs-comment">// 输出: 火箭在太空中飞行。</span></code></pre></div></li></ul><p>在上面的代码中，我们定义了一个 <strong><code>Flyable</code></strong> 接口，表示飞行器的行为。然后，我们创建了三个不同的飞行策略类 <strong><code>HelicopterStrategy</code><strong>、</strong><code>AirplaneStrategy</code></strong> 和 **<code>RocketStrategy</code>**，它们分别实现了 <strong><code>Flyable</code></strong> 接口。</p><p>接着，我们创建了 <strong><code>Aircraft</code></strong> 类，其中包含一个 <strong><code>flyStrategy</code></strong> 属性，该属性用于存储具体的飞行策略对象。**<code>Aircraft</code>** 类的 <strong><code>fly()</code></strong> 方法使用 <strong><code>flyStrategy</code></strong> 属性来调用相应的飞行行为。</p><p>最后，我们创建了三个不同的 <strong><code>Aircraft</code></strong> 实例，并分别传入不同的飞行策略对象，以达到动态选择飞行策略的效果。</p><h3 id="3-观察者模式（Observer-Pattern）"><a href="#3-观察者模式（Observer-Pattern）" class="headerlink" title="3. 观察者模式（Observer Pattern）"></a>3. 观察者模式（Observer Pattern）</h3><p>观察者模式（Observer Pattern）是一种行为型设计模式，它允许一个对象（主题）维护一系列依赖于它的对象（观察者），当主题发生变化时，自动通知观察者进行相应的更新操作。</p><p>通常，当我们需要实现对象之间的松耦合时，观察者模式就非常有用了。使用该模式可以使得主题对象和观察者对象相互独立，只需要定义好接口，就可以在运行时动态地添加或删除观察者。</p><p>下面是一个使用 Swift 5 实现观察者模式的示例，假设我们有一个主题 **<code>Subject</code>**，需要通知多个观察者 **<code>Observer</code>**，以实现一个简单的文本编辑器，当用户输入文本时，通知所有观察者进行相应的更新。</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 主题协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">registerObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">notifyObservers</span>()&#125;<span class="hljs-comment">// 观察者协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>()&#125;<span class="hljs-comment">// 文本编辑器主题</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span>: <span class="hljs-title class_">Subject</span> &#123;    <span class="hljs-keyword">var</span> text: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">var</span> observers: [<span class="hljs-type">Observer</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">func</span> <span class="hljs-title function_">registerObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>) &#123;        <span class="hljs-keyword">self</span>.observers.append(observer)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">removeObserver</span>(<span class="hljs-params">observer</span>: <span class="hljs-type">Observer</span>) &#123;        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> index <span class="hljs-operator">=</span> <span class="hljs-keyword">self</span>.observers.firstIndex(where: &#123; <span class="hljs-variable">$0</span> <span class="hljs-operator">===</span> observer &#125;) &#123;            <span class="hljs-keyword">self</span>.observers.remove(at: index)        &#125;    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">notifyObservers</span>() &#123;        <span class="hljs-keyword">for</span> observer <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.observers &#123;            observer.update()        &#125;    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setText</span>(<span class="hljs-params">text</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.text <span class="hljs-operator">=</span> text        <span class="hljs-keyword">self</span>.notifyObservers()    &#125;&#125;<span class="hljs-comment">// 文本长度观察者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextLengthObserver</span>: <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">var</span> textEditor: <span class="hljs-type">TextEditor</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">textEditor</span>: <span class="hljs-type">TextEditor</span>) &#123;        <span class="hljs-keyword">self</span>.textEditor <span class="hljs-operator">=</span> textEditor    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文本长度为：<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.textEditor.text.count)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 大写字母观察者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">UppercaseObserver</span>: <span class="hljs-title class_">Observer</span> &#123;    <span class="hljs-keyword">var</span> textEditor: <span class="hljs-type">TextEditor</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">textEditor</span>: <span class="hljs-type">TextEditor</span>) &#123;        <span class="hljs-keyword">self</span>.textEditor <span class="hljs-operator">=</span> textEditor    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">update</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;大写字母为：<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.textEditor.text.filter &#123; <span class="hljs-variable">$0</span>.isUppercase &#125;)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 使用示例</span><span class="hljs-keyword">let</span> textEditor <span class="hljs-operator">=</span> <span class="hljs-type">TextEditor</span>()<span class="hljs-keyword">let</span> lengthObserver <span class="hljs-operator">=</span> <span class="hljs-type">TextLengthObserver</span>(textEditor: textEditor)<span class="hljs-keyword">let</span> uppercaseObserver <span class="hljs-operator">=</span> <span class="hljs-type">UppercaseObserver</span>(textEditor: textEditor)textEditor.registerObserver(observer: lengthObserver)textEditor.registerObserver(observer: uppercaseObserver)textEditor.setText(text: <span class="hljs-string">&quot;Hello, World!&quot;</span>)<span class="hljs-comment">// 输出：文本长度为：13</span><span class="hljs-comment">//      大写字母为：HW</span>textEditor.removeObserver(observer: uppercaseObserver)textEditor.setText(text: <span class="hljs-string">&quot;Welcome to the world of programming!&quot;</span>)<span class="hljs-comment">// 输出：文本长度为：35</span></code></pre></div></li></ul><p>在上面的代码中，我们定义了一个 <strong><code>Subject</code></strong> 协议，表示主题对象的行为。主题对象可以注册、移除和通知观察者，这些行为在协议中被定义</p><p>我们还定义了一个 <strong><code>Observer</code></strong> 协议，表示观察者对象的行为。观察者需要实现 <strong><code>update()</code></strong> 方法，在被通知时执行相应的更新操作。</p><p>接下来，我们定义了一个文本编辑器主题 **<code>TextEditor</code>**，它实现了 <strong><code>Subject</code></strong> 协议中定义的行为。主题对象维护了一个观察者数组，用于保存所有的观察者，当主题对象状态发生变化时，会遍历观察者数组并调用每个观察者的 <strong><code>update()</code></strong> 方法进行相应的更新操作。</p><p>我们还定义了两个观察者 <strong><code>TextLengthObserver</code></strong> 和 <strong><code>UppercaseObserver</code><strong>，它们都实现了 <strong><code>Observer</code></strong> 协议中定义的行为。</strong><code>TextLengthObserver</code></strong> 用于在主题对象的文本发生变化时打印文本长度，**<code>UppercaseObserver</code>** 用于在主题对象的文本发生变化时打印大写字母。</p><p>在最后的使用示例中，我们创建了一个文本编辑器主题对象 **<code>textEditor</code>**，并创建了两个观察者对象 <strong><code>lengthObserver</code></strong> 和 **<code>uppercaseObserver</code>**，并将它们注册到主题对象中。随后，我们通过 <strong><code>textEditor.setText(text:)</code></strong> 方法改变了主题对象的状态，从而触发了两个观察者的更新操作，最终输出了相应的结果。</p><p>总的来说，观察者模式使得主题对象和观察者对象之间的耦合度更低，主题对象只需要维护一个观察者列表，并通知观察者对象即可。这种方式可以方便地添加、删除或修改观察者对象，而无需修改主题对象的代码。</p><h3 id="4-迭代器模式（Iterator-Pattern）"><a href="#4-迭代器模式（Iterator-Pattern）" class="headerlink" title="4. 迭代器模式（Iterator Pattern）"></a>4. 迭代器模式（Iterator Pattern）</h3><p>迭代器模式是一种行为型设计模式，它允许我们按照特定的顺序遍历集合中的每个元素，而无需暴露集合的内部表示。该模式定义了一种迭代器接口，该接口提供了遍历集合的方法，而不需要了解集合的内部结构。</p><p>迭代器模式的核心在于将集合和遍历分离开来。这样，我们就可以遍历一个聚合对象，而无需了解聚合对象的内部结构。这种分离有助于提高代码的可重用性，并使代码更易于维护。</p><p>在 Swift 中，标准库已经提供了 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 两个协议，用于实现迭代器模式。如果需要遍历自定义类型的对象，我们可以让该类型实现 <strong><code>Sequence</code></strong> 协议，并在该协议中实现 <strong><code>makeIterator()</code></strong> 方法，返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象。</p><p>下面是一个使用 Swift 标准库提供的协议实现迭代器模式的例子：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MySequence</span>: <span class="hljs-title class_">Sequence</span> &#123;    <span class="hljs-keyword">let</span> values: [<span class="hljs-type">Int</span>]    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">IndexingIterator</span>&lt;[<span class="hljs-type">Int</span>]&gt; &#123;        <span class="hljs-keyword">return</span> values.makeIterator()    &#125;&#125;<span class="hljs-keyword">let</span> sequence <span class="hljs-operator">=</span> <span class="hljs-type">MySequence</span>(values: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> sequence &#123;    <span class="hljs-built_in">print</span>(value)&#125;</code></pre></div><p>在上面的代码中，我们定义了一个名为 <strong><code>MySequence</code></strong> 的结构体，实现了 <strong><code>Sequence</code></strong> 协议，并在其中实现了 <strong><code>makeIterator()</code></strong> 方法，返回了一个 <strong><code>IndexingIterator&lt;[Int]&gt;</code></strong> 类型的迭代器对象。</p><p>接着，我们创建了一个 <strong><code>MySequence</code></strong> 对象，并使用 <strong><code>for...in</code></strong> 循环遍历了该对象中的所有元素，并输出了每个元素的值。</p><p>需要注意的是，Swift 标准库中提供的 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议已经实现了很多迭代器模式的细节，因此在实现自定义类型的迭代器时，可以直接使用标准库提供的协议。</p><p>Swift 标准库中实现 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的原理是利用了 Swift 的生成器和闭包特性。</p><p>在 Swift 中，生成器是一种特殊的函数，可以在需要时逐个返回值，而不是一次性返回所有值。生成器函数使用 <strong><code>yield</code></strong> 关键字来返回值，并且每次返回值时，函数的状态会被保存下来，以便下一次调用该函数时可以从上次离开的地方继续执行。</p><p><strong><code>IteratorProtocol</code></strong> 协议定义了一个 <strong><code>next()</code></strong> 方法，用于返回序列中的下一个元素。在 Swift 标准库中，**<code>IteratorProtocol</code>** 协议通常由生成器函数来实现，也就是说，**<code>next()</code>** 方法的实现使用了生成器函数的特性，可以在需要时逐个返回序列中的元素，并且在返回元素时保存状态，以便下一次调用 <strong><code>next()</code></strong> 方法时可以从上次离开的地方继续执行。</p><p><strong><code>Sequence</code></strong> 协议定义了一个 <strong><code>makeIterator()</code></strong> 方法，用于返回符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象。在 Swift 标准库中，**<code>Sequence</code>** 协议通常由数组、字典、集合等数据结构来实现。当一个序列对象调用 <strong><code>makeIterator()</code></strong> 方法时，该方法会返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象，该迭代器对象实际上就是由序列对象中的生成器函数来实现的。</p><p>以下是 Swift 标准库中 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的部分实现代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">IteratorProtocol</span> &#123;    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Element</span>    <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">Element</span>?&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Sequence</span> &#123;    <span class="hljs-keyword">associatedtype</span> <span class="hljs-type">Iterator</span>: <span class="hljs-type">IteratorProtocol</span>    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">Iterator</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IndexingIterator</span>&lt;<span class="hljs-title class_">C</span>: <span class="hljs-title class_">Collection</span>&gt;: <span class="hljs-title class_">IteratorProtocol</span> &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">mutating</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">next</span>() -&gt; <span class="hljs-type">C</span>.<span class="hljs-type">Element</span>? &#123;        <span class="hljs-keyword">if</span> _position <span class="hljs-operator">==</span> _elements.endIndex &#123;            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>        &#125;        _elements.formIndex(after: <span class="hljs-operator">&amp;</span>_position)        <span class="hljs-keyword">return</span> _elements[_position]    &#125;    <span class="hljs-keyword">var</span> _elements: <span class="hljs-type">C</span>    <span class="hljs-keyword">var</span> _position: <span class="hljs-type">C</span>.<span class="hljs-type">Index</span>&#125;<span class="hljs-keyword">extension</span> <span class="hljs-title class_">Collection</span> &#123;    <span class="hljs-keyword">public</span> __consuming <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeIterator</span>() -&gt; <span class="hljs-type">IndexingIterator</span>&lt;<span class="hljs-keyword">Self</span>&gt; &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">IndexingIterator</span>(_elements: <span class="hljs-keyword">self</span>, _position: startIndex)    &#125;&#125;</code></pre></div><p>在上面的代码中，**<code>IteratorProtocol</code>** 协议定义了一个 <strong><code>next()</code></strong> 方法，返回一个关联类型 <strong><code>Element</code><strong>。</strong><code>Sequence</code></strong> 协议定义了一个关联类型 <strong><code>Iterator</code><strong>，并且定义了一个 <strong><code>makeIterator()</code></strong> 方法，返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象。</strong><code>IndexingIterator</code></strong> 结构体实现了 <strong><code>IteratorProtocol</code></strong> 协议，并使用泛型参数 <strong><code>C</code></strong> 限定了 <strong><code>next()</code></strong> 方法返回值的类型。在 <strong><code>IndexingIterator</code></strong> 结构体中，**<code>next()</code>** 方法的实现使用了 Swift 的集合（Collection）特性，可以逐个返回集合中的元素。在 <strong><code>Collection</code></strong> 扩展中，**<code>makeIterator()</code>** 方法的实现返回了一个 <strong><code>IndexingIterator</code></strong> 类型的迭代器对象。</p><p>总的来说，Swift 标准库中实现 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的原理是利用了 Swift 的生成器和闭包特性。生成器函数可以逐个返回序列中的元素，并在返回元素时保存状态，以便下一次调用 <strong><code>next()</code></strong> 方法时可以从上次离开的地方继续执行。序列对象调用 <strong><code>makeIterator()</code></strong> 方法时，该方法会返回一个符合 <strong><code>IteratorProtocol</code></strong> 协议的迭代器对象，该迭代器对象实际上就是由序列对象中的生成器函数来实现的。</p><p>由于 Swift 的生成器函数和闭包特性，实现迭代器非常简单，而且非常灵活。开发者可以根据自己的需求来编写生成器函数，实现自定义的迭代器。同时，Swift 标准库中提供了很多符合 <strong><code>IteratorProtocol</code></strong> 和 <strong><code>Sequence</code></strong> 协议的数据结构，如数组、字典、集合等，可以直接使用这些数据结构提供的迭代器，方便开发者的编程工作。</p><h3 id="5-职责链模式（Chain-of-Responsibility-Pattern）"><a href="#5-职责链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="5. 职责链模式（Chain of Responsibility Pattern）"></a>5. 职责链模式（Chain of Responsibility Pattern）</h3><p>职责链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它将多个对象组成一条链，依次处理某个请求，直到请求被处理完成为止。</p><p>职责链模式常用于处理多个对象之间的协作关系，例如在一个复杂的系统中，需要处理多种请求，每种请求都需要经过多个处理步骤才能最终得到处理结果。这时候，可以将这些处理步骤封装到不同的对象中，组成一条职责链，每个对象只负责处理自己能够处理的请求，并将请求传递给下一个对象，直到请求被处理完成为止。</p><p>下面是一个使用 Swift 5 实现职责链模式的例子。假设有一个购买请求需要经过三个处理步骤才能最终得到处理结果，其中第一个处理步骤可以处理最低价格的购买请求，第二个处理步骤可以处理大于 100 元的购买请求，第三个处理步骤可以处理任意购买请求。</p><p>首先，我们定义一个请求类型 **<code>PurchaseRequest</code>**，用于表示购买请求：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PurchaseRequest</span> &#123;    <span class="hljs-keyword">let</span> amount: <span class="hljs-type">Double</span>&#125;</code></pre></div><p>然后，我们定义一个抽象处理器 **<code>PurchaseHandler</code>**，用于表示购买请求处理器，该处理器包含一个指向下一个处理器的引用，并且提供一个处理请求的方法：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">PurchaseHandler</span> &#123;    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>? &#123; <span class="hljs-keyword">get</span> <span class="hljs-keyword">set</span> &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>)&#125;</code></pre></div><p>接下来，我们实现具体的处理器。首先是第一个处理步骤的处理器，用于处理最低价格的购买请求：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LowestPriceHandler</span>: <span class="hljs-title class_">PurchaseHandler</span> &#123;    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>) &#123;        <span class="hljs-keyword">if</span> request.amount <span class="hljs-operator">&lt;=</span> <span class="hljs-number">10</span> &#123;            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;LowestPriceHandler: Purchase request for $<span class="hljs-subst">\(request.amount)</span> approved&quot;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            nextHandler<span class="hljs-operator">?</span>.handle(request: request)        &#125;    &#125;&#125;</code></pre></div><p>然后是第二个处理步骤的处理器，用于处理大于 100 元的购买请求：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HighPriceHandler</span>: <span class="hljs-title class_">PurchaseHandler</span> &#123;    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>) &#123;        <span class="hljs-keyword">if</span> request.amount <span class="hljs-operator">&gt;</span> <span class="hljs-number">100</span> &#123;            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;HighPriceHandler: Purchase request for $<span class="hljs-subst">\(request.amount)</span> approved&quot;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            nextHandler<span class="hljs-operator">?</span>.handle(request: request)        &#125;    &#125;&#125;</code></pre></div><p>最后是第三个处理步骤的处理器，用于处理任意购买请求：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneralPriceHandler</span>: <span class="hljs-title class_">PurchaseHandler</span> &#123;    <span class="hljs-keyword">var</span> nextHandler: <span class="hljs-type">PurchaseHandler</span>?    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">request</span>: <span class="hljs-type">PurchaseRequest</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;GeneralPriceHandler: Purchase request for $<span class="hljs-subst">\(request.amount)</span> approved&quot;</span>)    &#125;&#125;</code></pre></div><p>现在，我们可以将这三个处理器组成一条职责链：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> lowestPriceHandler <span class="hljs-operator">=</span> <span class="hljs-type">LowestPriceHandler</span>()<span class="hljs-keyword">let</span> highPriceHandler <span class="hljs-operator">=</span> <span class="hljs-type">HighPriceHandler</span>()<span class="hljs-keyword">let</span> generalPriceHandler <span class="hljs-operator">=</span> <span class="hljs-type">GeneralPriceHandler</span>()lowestPriceHandler.nextHandler <span class="hljs-operator">=</span> highPriceHandlerhighPriceHandler.nextHandler <span class="hljs-operator">=</span> generalPriceHandler</code></pre></div><p>这样，当有一个购买请求时，我们只需要将其传递给第一个处理器即可：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> purchaseRequest <span class="hljs-operator">=</span> <span class="hljs-type">PurchaseRequest</span>(amount: <span class="hljs-number">5</span>)lowestPriceHandler.handle(request: purchaseRequest)<span class="hljs-keyword">let</span> purchaseRequest2 <span class="hljs-operator">=</span> <span class="hljs-type">PurchaseRequest</span>(amount: <span class="hljs-number">50</span>)lowestPriceHandler.handle(request: purchaseRequest2)<span class="hljs-keyword">let</span> purchaseRequest3 <span class="hljs-operator">=</span> <span class="hljs-type">PurchaseRequest</span>(amount: <span class="hljs-number">200</span>)lowestPriceHandler.handle(request: purchaseRequest3)</code></pre></div><p>输出结果如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-type">LowestPriceHandler</span>: <span class="hljs-type">Purchase</span> request <span class="hljs-keyword">for</span> <span class="hljs-variable">$5</span>.<span class="hljs-number">0</span> approved<span class="hljs-type">LowestPriceHandler</span>: <span class="hljs-type">Purchase</span> request <span class="hljs-keyword">for</span> <span class="hljs-variable">$50</span>.<span class="hljs-number">0</span> approved<span class="hljs-type">HighPriceHandler</span>: <span class="hljs-type">Purchase</span> request <span class="hljs-keyword">for</span> <span class="hljs-variable">$200</span>.<span class="hljs-number">0</span> approved</code></pre></div><p>可以看到，购买请求被依次传递给了职责链中的处理器，并且最终得到了处理结果。</p><p>在这个例子中，职责链模式将多个处理步骤组合成一条链，使得每个处理步骤只需要关注自己能够处理的请求，而不需要关注整个处理过程，从而提高了代码的可扩展性和可维护性。</p><h3 id="6-命令模式（Command-Pattern）"><a href="#6-命令模式（Command-Pattern）" class="headerlink" title="6. 命令模式（Command Pattern）"></a>6. 命令模式（Command Pattern）</h3><p>命令模式是一种行为设计模式，它将请求和接收者封装在独立的对象中，从而使你能够将请求参数化、将请求放入队列或记录请求日志，以及支持可撤销的操作。</p><p>命令模式常用来解决在软件开发中，需要对一些对象进行一系列复杂的操作，或者需要在不同的时间对对象进行不同的操作。此时，我们可以将这些操作封装成不同的命令对象，使得操作可以灵活组合，易于扩展和维护。</p><p>下面是一个使用 Swift 5 实现命令模式的简单示例，假设有一个家庭影院，我们需要对其进行一系列操作，包括打开灯光、打开投影仪、打开音响、调整音量等等：</p><ul><li><p>Swift Code</p>  <div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 接收者（Receiver）：家庭影院</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">HomeTheater</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOnLights</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Lights are on&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOffLights</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Lights are off&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOnProjector</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Projector is on&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOffProjector</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Projector is off&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOnStereo</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stereo is on&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">turnOffStereo</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Stereo is off&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setVolume</span>(<span class="hljs-params">volume</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Volume is set to <span class="hljs-subst">\(volume)</span>&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 命令（Command）：抽象类</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>()&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：打开灯光</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnLightsCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        homeTheater.turnOnLights()    &#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：关闭灯光</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOffLightsCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        homeTheater.turnOffLights()    &#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：打开投影仪</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnProjectorCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        homeTheater.turnOnProjector()    &#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：关闭投影仪</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOffProjectorCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        homeTheater.turnOffProjector()    &#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：打开音响</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOnStereoCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;homeTheater.turnOnStereo()&#125;&#125;<span class="hljs-comment">// 具体命令（ConcreteCommand）：关闭音响</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TurnOffStereoCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> homeTheater: <span class="hljs-type">HomeTheater</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">homeTheater</span>: <span class="hljs-type">HomeTheater</span>) &#123;        <span class="hljs-keyword">self</span>.homeTheater <span class="hljs-operator">=</span> homeTheater&#125;<span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;homeTheater.turnOffStereo()&#125;&#125;</code></pre></div></li></ul><p>当我们使用命令模式时，我们通常会实现一个命令接口来封装每个具体的命令，这个命令接口通常至少包括一个 <strong><code>execute()</code></strong> 方法来执行命令。</p><p>下面是一个使用命令模式的示例，假设我们有一个简单的文本编辑器，用户可以执行一些基本的操作，例如打开文件、保存文件、撤销操作、重做操作等。我们可以使用命令模式来实现这些操作：</p><p>首先，我们定义一个 <strong><code>Command</code></strong> 接口，用于封装所有的命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>()&#125;</code></pre></div><p>然后，我们定义几个具体的命令，例如 <strong><code>OpenFileCommand</code><strong>、</strong><code>SaveFileCommand</code><strong>、</strong><code>UndoCommand</code></strong> 和 **<code>RedoCommand</code>**：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenFileCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行打开文件操作&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveFileCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行保存文件操作&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">UndoCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行撤销操作&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">RedoCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;执行重做操作&quot;</span>)    &#125;&#125;</code></pre></div><p>现在我们可以将这些命令封装到一个文本编辑器中：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextEditor</span> &#123;    <span class="hljs-keyword">var</span> openFileCommand: <span class="hljs-type">Command</span>    <span class="hljs-keyword">var</span> saveFileCommand: <span class="hljs-type">Command</span>    <span class="hljs-keyword">var</span> undoCommand: <span class="hljs-type">Command</span>    <span class="hljs-keyword">var</span> redoCommand: <span class="hljs-type">Command</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">openFileCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">saveFileCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">undoCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">redoCommand</span>: <span class="hljs-type">Command</span>) &#123;        <span class="hljs-keyword">self</span>.openFileCommand <span class="hljs-operator">=</span> openFileCommand        <span class="hljs-keyword">self</span>.saveFileCommand <span class="hljs-operator">=</span> saveFileCommand        <span class="hljs-keyword">self</span>.undoCommand <span class="hljs-operator">=</span> undoCommand        <span class="hljs-keyword">self</span>.redoCommand <span class="hljs-operator">=</span> redoCommand    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">openFile</span>() &#123;        openFileCommand.execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveFile</span>() &#123;        saveFileCommand.execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>() &#123;        undoCommand.execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">redo</span>() &#123;        redoCommand.execute()    &#125;&#125;</code></pre></div><p>现在我们可以使用命令模式来执行这些操作。首先，我们实例化每个具体的命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> openFileCommand <span class="hljs-operator">=</span> <span class="hljs-type">OpenFileCommand</span>()<span class="hljs-keyword">let</span> saveFileCommand <span class="hljs-operator">=</span> <span class="hljs-type">SaveFileCommand</span>()<span class="hljs-keyword">let</span> undoCommand <span class="hljs-operator">=</span> <span class="hljs-type">UndoCommand</span>()<span class="hljs-keyword">let</span> redoCommand <span class="hljs-operator">=</span> <span class="hljs-type">RedoCommand</span>()</code></pre></div><p>然后，我们可以将这些命令传递给一个文本编辑器实例：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> textEditor <span class="hljs-operator">=</span> <span class="hljs-type">TextEditor</span>(openFileCommand: openFileCommand, saveFileCommand: saveFileCommand, undoCommand: undoCommand, redoCommand: redoCommand)</code></pre></div><p>现在，我们可以调用文本编辑器的方法来执行这些操作：</p><div class="code-wrapper"><pre><code class="hljs swift">textEditor.openFile()  <span class="hljs-comment">// 输出：执行打开文件操作</span>textEditor.saveFile()  <span class="hljs-comment">// 输出：执行保存文件操作</span>textEditor.undo()      <span class="hljs-comment">// 输出：执行撤销操作</span>textEditor.redo()      <span class="hljs-comment">// 输出：执行重做操作</span></code></pre></div><p>在上面的示例中，我们使用命令模式来封装每个操作，并将它们传递给一个文本编辑器实例。这样，我们可以轻松地添加、修改或删除命令，而不需要修改文本编辑</p><p>当调用 <strong><code>execute()</code></strong> 方法时，会调用 <strong><code>receiver</code></strong> 对象的相应方法完成具体的操作。同时，可以通过 <strong><code>undo()</code></strong> 方法实现撤销操作，即撤销 <strong><code>receiver</code></strong> 对象的相应方法的操作。</p><p>下面是一个简单的示例，使用命令模式来实现一个遥控器控制灯的开关。首先，我们定义一个 <strong><code>Light</code></strong> 类来表示灯，并提供开灯和关灯的方法：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Light</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">on</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Light is on&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">off</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Light is off&quot;</span>)    &#125;&#125;</code></pre></div><p>然后，我们定义一个 <strong><code>Command</code></strong> 协议来表示命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>()&#125;</code></pre></div><p>接下来，我们实现具体的命令类，这里有开灯命令和关灯命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOnCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> light: <span class="hljs-type">Light</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">light</span>: <span class="hljs-type">Light</span>) &#123;        <span class="hljs-keyword">self</span>.light <span class="hljs-operator">=</span> light    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        light.on()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>() &#123;        light.off()    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">LightOffCommand</span>: <span class="hljs-title class_">Command</span> &#123;    <span class="hljs-keyword">let</span> light: <span class="hljs-type">Light</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">light</span>: <span class="hljs-type">Light</span>) &#123;        <span class="hljs-keyword">self</span>.light <span class="hljs-operator">=</span> light    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">execute</span>() &#123;        light.off()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">undo</span>() &#123;        light.on()    &#125;&#125;</code></pre></div><p>在这里，**<code>LightOnCommand</code>** 和 <strong><code>LightOffCommand</code></strong> 分别实现了 <strong><code>Command</code></strong> 协议，并在 <strong><code>execute()</code></strong> 和 <strong><code>undo()</code></strong> 方法中分别调用了 <strong><code>Light</code></strong> 对象的开灯和关灯方法。</p><p>接下来，我们定义遥控器类，它有四个插槽，每个插槽都可以存放一个命令：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RemoteControl</span> &#123;    <span class="hljs-keyword">var</span> onCommands: [<span class="hljs-type">Command</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">var</span> offCommands: [<span class="hljs-type">Command</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">init</span>() &#123;        <span class="hljs-keyword">let</span> noCommand <span class="hljs-operator">=</span> <span class="hljs-type">NoCommand</span>()        <span class="hljs-keyword">for</span> <span class="hljs-keyword">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span><span class="hljs-operator">..&lt;</span><span class="hljs-number">4</span> &#123;            onCommands.append(noCommand)            offCommands.append(noCommand)        &#125;    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setCommand</span>(<span class="hljs-params">slot</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">onCommand</span>: <span class="hljs-type">Command</span>, <span class="hljs-params">offCommand</span>: <span class="hljs-type">Command</span>) &#123;        onCommands[slot] <span class="hljs-operator">=</span> onCommand        offCommands[slot] <span class="hljs-operator">=</span> offCommand    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pressOnButton</span>(<span class="hljs-params">slot</span>: <span class="hljs-type">Int</span>) &#123;        onCommands[slot].execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pressOffButton</span>(<span class="hljs-params">slot</span>: <span class="hljs-type">Int</span>) &#123;        offCommands[slot].execute()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pressUndoButton</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Undo button pressed&quot;</span>)    &#125;&#125;</code></pre></div><p>在这里，我们使用 <strong><code>NoCommand</code></strong> 类来初始化所有插槽。**<code>setCommand()</code>** 方法用于设置插槽中的命令，**<code>pressOnButton()</code>** 和 <strong><code>pressOffButton()</code></strong> 方法分别用于按下开灯和关灯按钮，**<code>pressUndoButton()</code>** 方法用于实现撤销操作，这里先简单地输出一个信息。</p><p>最后，我们可以测试遥控器了：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> remoteControl <span class="hljs-operator">=</span> <span class="hljs-type">RemoteControl</span>()<span class="hljs-keyword">let</span> livingRoomLight <span class="hljs-operator">=</span> <span class="hljs-type">Light</span>()<span class="hljs-keyword">let</span> livingRoomLightOnCommand <span class="hljs-operator">=</span> <span class="hljs-type">LightOnCommand</span>(light: livingRoomLight)<span class="hljs-keyword">let</span> livingRoomLightOffCommand <span class="hljs-operator">=</span> <span class="hljs-type">LightOffCommand</span>(light: livingRoomLight)remoteControl.setCommand(slot: <span class="hljs-number">0</span>, onCommand: livingRoomLightOnCommand, offCommand:livingRoomLightOffCommand)remoteControl.pressOnButton(slot:<span class="hljs-number">0</span>)remoteControl.pressOffButton(slot:<span class="hljs-number">0</span>)</code></pre></div><p>在上面的实现中，我们创建了三个具体命令 <strong><code>LightOnCommand</code><strong>、</strong><code>LightOffCommand</code></strong> 和 **<code>StereoOnWithCDCommand</code>**。每个命令对象都持有了一个接收者对象，并实现了 <strong><code>Command</code></strong> 协议的 <strong><code>execute</code></strong> 方法。这个 <strong><code>execute</code></strong> 方法会调用接收者的相关方法来实现具体的命令操作。</p><p>我们还创建了一个遥控器对象 **<code>RemoteControl</code>**，这个遥控器对象持有了一系列的命令对象。通过 <strong><code>setCommand</code></strong> 方法，我们可以给遥控器设置不同的命令，同时通过 <strong><code>buttonWasPressed</code></strong> 方法，我们可以执行遥控器当前所持有的命令对象。</p><p>这样，在实际的应用场景中，我们可以通过遥控器对象将具体的命令对象和执行命令的对象进行解耦，从而实现更加灵活的命令操作。</p><h3 id="7-备忘录模式（Memento-Pattern）"><a href="#7-备忘录模式（Memento-Pattern）" class="headerlink" title="7. 备忘录模式（Memento Pattern）"></a>7. 备忘录模式（Memento Pattern）</h3><p>备忘录模式（Memento Pattern）是一种行为设计模式，它允许将对象的状态保存到备忘录中，并在需要时将其还原到先前的状态。备忘录模式的核心思想是提供一个快照对象，用于保存一个对象的内部状态，并将该对象恢复到该状态。</p><p>备忘录模式通常用于以下两种情况中：</p><ol><li>当需要保存和恢复对象状态以进行撤销、重做或历史记录时。</li><li>当直接访问对象的成员变量可能违反封装原则时，备忘录模式可以提供一个间接的访问方式。</li></ol><p>下面是使用 Swift 5 实现备忘录模式的一个例子：</p><p>首先，我们定义一个备忘录类，用于保存需要恢复的对象的状态。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> &#123;    <span class="hljs-keyword">let</span> state: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">state</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getState</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> state    &#125;&#125;</code></pre></div><p>接下来，我们定义一个原始对象类，该类拥有一个状态变量，并且可以将其状态保存到备忘录中。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">state</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">saveStateToMemento</span>() -&gt; <span class="hljs-type">Memento</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">Memento</span>(state: state)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getStateFromMemento</span>(<span class="hljs-params">memento</span>: <span class="hljs-type">Memento</span>) &#123;        state <span class="hljs-operator">=</span> memento.getState()    &#125;&#125;</code></pre></div><p>最后，我们定义一个管理器类，该类用于保存备忘录列表并提供对它们的访问。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CareTaker</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mementoList: [<span class="hljs-type">Memento</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addMemento</span>(<span class="hljs-params">memento</span>: <span class="hljs-type">Memento</span>) &#123;        mementoList.append(memento)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getMemento</span>(<span class="hljs-params">index</span>: <span class="hljs-type">Int</span>) -&gt; <span class="hljs-type">Memento</span> &#123;        <span class="hljs-keyword">return</span> mementoList[index]    &#125;&#125;</code></pre></div><p>下面是一个简单的使用备忘录模式的示例，其中我们将对象状态保存到备忘录中，并在需要时将其还原。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 创建一个原始对象</span><span class="hljs-keyword">var</span> originator <span class="hljs-operator">=</span> <span class="hljs-type">Originator</span>(state: <span class="hljs-string">&quot;State1&quot;</span>)<span class="hljs-comment">// 创建一个管理器对象</span><span class="hljs-keyword">var</span> careTaker <span class="hljs-operator">=</span> <span class="hljs-type">CareTaker</span>()<span class="hljs-comment">// 将原始对象的状态保存到备忘录中</span>careTaker.addMemento(memento: originator.saveStateToMemento())<span class="hljs-comment">// 修改原始对象的状态</span>originator.setState(state: <span class="hljs-string">&quot;State2&quot;</span>)<span class="hljs-comment">// 从备忘录中恢复原始对象的状态</span>originator.getStateFromMemento(memento: careTaker.getMemento(index: <span class="hljs-number">0</span>))<span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Current State: <span class="hljs-subst">\(originator.getState())</span>&quot;</span>) <span class="hljs-comment">// 输出 &quot;Current State: State1&quot;</span></code></pre></div><p>在这个例子中，我们使用备忘录模式将原始对象的状态保存到备忘录中，并在需要时将其还原。这样，我们就可以轻松地实现撤销、重做或历史记录等功能。</p><h3 id="8-状态模式（State-Pattern）"><a href="#8-状态模式（State-Pattern）" class="headerlink" title="8. 状态模式（State Pattern）"></a>8. 状态模式（State Pattern）</h3><p>状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在其内部状态改变时改变其行为。该模式主要解决对象状态转换的问题，使得在状态发生改变时，对象可以自动改变行为。</p><p>状态模式包含三个主要角色：上下文（Context）、抽象状态（State）和具体状态（Concrete State）。上下文负责维护状态，并将请求转发给当前状态对象，而抽象状态定义一个接口，用于表示状态，并在状态发生改变时通知上下文，具体状态则实现抽象状态定义的接口，并处理上下文发来的请求。</p><p>使用状态模式可以使代码更加可维护和可扩展，因为状态转换的逻辑被封装在状态类中，而不是分散在上下文中，从而使得状态类可以独立变化而不会影响到上下文。</p><p>下面是一个使用 Swift 5 实现状态模式的示例代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义抽象状态</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">State</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>)&#125;<span class="hljs-comment">// 定义具体状态 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateA</span>: <span class="hljs-title class_">State</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前状态是 A&quot;</span>)        context.setState(state: <span class="hljs-type">ConcreteStateB</span>())    &#125;&#125;<span class="hljs-comment">// 定义具体状态 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteStateB</span>: <span class="hljs-title class_">State</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">handle</span>(<span class="hljs-params">context</span>: <span class="hljs-type">Context</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;当前状态是 B&quot;</span>)        context.setState(state: <span class="hljs-type">ConcreteStateA</span>())    &#125;&#125;<span class="hljs-comment">// 定义上下文</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Context</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> state: <span class="hljs-type">State</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">state</span>: <span class="hljs-type">State</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">state</span>: <span class="hljs-type">State</span>) &#123;        <span class="hljs-keyword">self</span>.state <span class="hljs-operator">=</span> state    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">request</span>() &#123;        state.handle(context: <span class="hljs-keyword">self</span>)    &#125;&#125;<span class="hljs-comment">// 测试代码</span><span class="hljs-keyword">let</span> context <span class="hljs-operator">=</span> <span class="hljs-type">Context</span>(state: <span class="hljs-type">ConcreteStateA</span>())context.request()context.request()context.request()</code></pre></div><p>在上面的代码中，抽象状态被定义为 <strong><code>State</code></strong> 协议，其中包含一个 <strong><code>handle</code></strong> 方法用于处理请求并改变上下文状态。具体状态 <strong><code>ConcreteStateA</code></strong> 和 <strong><code>ConcreteStateB</code></strong> 实现了 <strong><code>State</code></strong> 协议，并分别处理不同的请求，并将上下文状态设置为另一个具体状态。上下文类 <strong><code>Context</code></strong> 维护当前状态并将请求转发给当前状态来处理。最后，在测试代码中，上下文被初始化为 **<code>ConcreteStateA</code>**，并连续进行了三次请求，每次请求后状态都会发生改变。</p><h3 id="9-访问者模式（Visitor-Pattern）"><a href="#9-访问者模式（Visitor-Pattern）" class="headerlink" title="9. 访问者模式（Visitor Pattern）"></a>9. 访问者模式（Visitor Pattern）</h3><p>访问者模式（Visitor Pattern）是一种行为型设计模式，用于将算法与对象结构分离。该模式将算法定义在访问者中，让访问者能够访问并处理对象结构中的各个元素，而不需要修改这些元素的类定义。因此，该模式可以使得算法与对象结构相互独立，并且可以轻松添加新的算法而不会影响对象结构。</p><p>访问者模式包含四个主要角色：访问者（Visitor）、具体访问者（Concrete Visitor）、元素（Element）和具体元素（Concrete Element）。访问者定义了访问元素的方法，具体访问者实现了访问方法，并包含了针对不同元素的具体算法，元素定义了接受访问者访问的方法，具体元素实现了元素的特定行为，并在接受访问者访问时调用访问者的方法。</p><p>使用访问者模式可以将算法与对象结构分离，从而使得算法可以更容易地扩展和变化，并且可以方便地添加新的算法，而不需要修改对象结构。访问者模式通常用于解决对象结构比较稳定，但是需要频繁变化的算法的问题。</p><p>下面是一个使用 Swift 5 实现访问者模式的示例代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义元素接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>: <span class="hljs-type">Visitor</span>)&#125;<span class="hljs-comment">// 定义具体元素 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementA</span>: <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>: <span class="hljs-type">Visitor</span>) &#123;        visitor.visit(element: <span class="hljs-keyword">self</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationA</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteElementA operationA&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 定义具体元素 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteElementB</span>: <span class="hljs-title class_">Element</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">accept</span>(<span class="hljs-params">visitor</span>: <span class="hljs-type">Visitor</span>) &#123;        visitor.visit(element: <span class="hljs-keyword">self</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">operationB</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteElementB operationB&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 定义访问者接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementA</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementB</span>)&#125;<span class="hljs-comment">// 定义具体访问者 A</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitorA</span>: <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementA</span>) &#123;        element.operationA()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementB</span>) &#123;        element.operationB()    &#125;&#125;<span class="hljs-comment">// 定义具体访问者 B</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteVisitorB</span>: <span class="hljs-title class_">Visitor</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementA</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteVisitorB visit ConcreteElementA&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">visit</span>(<span class="hljs-params">element</span>: <span class="hljs-type">ConcreteElementB</span>) &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ConcreteVisitorB visit ConcreteElementB&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 测试代码</span><span class="hljs-keyword">let</span> elements: [<span class="hljs-type">Element</span>] <span class="hljs-operator">=</span> [<span class="hljs-type">ConcreteElementA</span>(), <span class="hljs-type">ConcreteElementB</span>()]<span class="hljs-keyword">let</span> visitorA <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteVisitorA</span>()<span class="hljs-keyword">let</span> visitorB <span class="hljs-operator">=</span> <span class="hljs-type">ConcreteVisitorB</span>()<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> elements &#123;    element.accept(visitor: visitorA)    element.accept(visitor: visitorB)&#125;</code></pre></div><p>在上面的代码中，元素被定义为 <strong><code>Element</code></strong> 协议，其中包含一个接受访问者访问方法。具体元素 <strong><code>ConcreteElementA</code></strong> 和 <strong><code>ConcreteElementB</code></strong> 实现了 <strong><code>Element</code></strong> 接口，并在接受访问者访问时调用访问者的访问方法。</p><p>访问者被定义为 <strong><code>Visitor</code></strong> 接口，其中包含针对具体元素的访问方法。具体访问者 <strong><code>ConcreteVisitorA</code></strong> 和 <strong><code>ConcreteVisitorB</code></strong> 实现了 <strong><code>Visitor</code></strong> 接口，并分别实现了访问具体元素的具体算法。</p><p>在测试代码中，创建了两个具体访问者 <strong><code>visitorA</code></strong> 和 **<code>visitorB</code>**，以及两个元素 <strong><code>ConcreteElementA</code></strong> 和 **<code>ConcreteElementB</code>**。遍历元素数组，分别调用元素的 <strong><code>accept</code></strong> 方法，接受访问者的访问。在访问过程中，具体元素会调用访问者的访问方法，从而实现了算法与对象结构的分离。</p><p>总的来说，访问者模式可以让算法与对象结构相互独立，并且可以轻松添加新的算法而不会影响对象结构。该模式通常用于解决对象结构比较稳定，但是需要频繁变化的算法的问题。</p><h3 id="10-中介者模式（Mediator-Pattern）"><a href="#10-中介者模式（Mediator-Pattern）" class="headerlink" title="10. 中介者模式（Mediator Pattern）"></a>10. 中介者模式（Mediator Pattern）</h3><p>中介者模式是一种行为型设计模式，它可以通过将对象之间的通信转移给一个中介者对象来降低对象之间的耦合度。中介者模式有时也被称为调停者模式，因为中介者在协调对象之间的交互时，就像一个调停者一样。</p><p>中介者模式通常用于以下场景：</p><ul><li>当一个对象需要与许多其他对象进行通信时，如果这些对象之间的交互非常复杂，那么每个对象都需要了解所有其他对象的细节，这会导致非常复杂和难以维护的代码。使用中介者模式可以将这些交互转移到中介者对象中，从而简化每个对象的职责。</li><li>当多个对象之间的交互会导致复杂的循环依赖关系时，使用中介者模式可以打破这些循环依赖，从而使代码更加可维护和可扩展。</li><li>当一个对象的改变需要通知其他对象时，如果每个对象都需要了解其他对象的细节，那么这种通知机制也会变得非常复杂。使用中介者模式可以将这种通知机制转移到中介者对象中，从而简化代码。</li></ul><p>下面是一个简单的 Swift 5 代码示例，演示了如何使用中介者模式协调多个组件之间的交互。假设我们有一个窗口组件（Window）、一个按钮组件（Button）和一个文本框组件（TextBox），它们都需要与彼此交互。我们可以创建一个中介者对象（Mediator）来协调它们之间的交互，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 中介者</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> window: <span class="hljs-type">Window</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> button: <span class="hljs-type">Button</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> textBox: <span class="hljs-type">TextBox</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">window</span>: <span class="hljs-type">Window</span>, <span class="hljs-params">button</span>: <span class="hljs-type">Button</span>, <span class="hljs-params">textBox</span>: <span class="hljs-type">TextBox</span>) &#123;        <span class="hljs-keyword">self</span>.window <span class="hljs-operator">=</span> window        <span class="hljs-keyword">self</span>.button <span class="hljs-operator">=</span> button        <span class="hljs-keyword">self</span>.textBox <span class="hljs-operator">=</span> textBox    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">buttonClicked</span>() &#123;        textBox.setText(<span class="hljs-string">&quot;Button clicked&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">textBoxChanged</span>() &#123;        <span class="hljs-keyword">if</span> textBox.getText() <span class="hljs-operator">==</span> <span class="hljs-string">&quot;open&quot;</span> &#123;            window.open()        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> textBox.getText() <span class="hljs-operator">==</span> <span class="hljs-string">&quot;close&quot;</span> &#123;            window.close()        &#125;    &#125;&#125;<span class="hljs-comment">// 窗口组件</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Window</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">open</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Window opened&quot;</span>)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">close</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Window closed&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 按钮组件</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Button</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mediator: <span class="hljs-type">Mediator</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">mediator</span>: <span class="hljs-type">Mediator</span>) &#123;        <span class="hljs-keyword">self</span>.mediator <span class="hljs-operator">=</span> mediator    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">click</span>() &#123;        mediator.buttonClicked()    &#125;&#125;<span class="hljs-comment">// 文本框组件</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBox</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> mediator: <span class="hljs-type">Mediator</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> text: <span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">mediator</span>: <span class="hljs-type">Mediator</span>) &#123;        <span class="hljs-keyword">self</span>.mediator <span class="hljs-operator">=</span> mediator    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">setText</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">text</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.text <span class="hljs-operator">=</span> text        mediator.textBoxChanged()    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getText</span>() -&gt; <span class="hljs-type">String</span> &#123;        <span class="hljs-keyword">return</span> text    &#125;&#125;</code></pre></div><p>在这个例子中，中介者对象包含对窗口、按钮和文本框对象的引用。当按钮被点击时，它会调用中介者对象的 <strong><code>buttonClicked()</code></strong> 方法，中介者对象在收到这个消息后会将文本框的文本设置为“Button clicked”。当文本框的文本改变时，它会调用中介者对象的 <strong><code>textBoxChanged()</code></strong> 方法，中介者对象根据文本框的内容来打开或关闭窗口。</p><p>按钮和文本框对象都包含对中介者对象的引用。当按钮被点击时，它会调用中介者对象的 <strong><code>buttonClicked()</code></strong> 方法，从而触发文本框的文本改变。当文本框的文本改变时，它会调用中介者对象的 <strong><code>textBoxChanged()</code></strong> 方法，从而打开或关闭窗口。</p><p>这个例子演示了如何使用中介者模式来协调多个组件之间的交互，从而降低它们之间的耦合度。中介者模式可以帮助我们编写更加模块化、可维护和可扩展的代码。</p><h3 id="11-解释器模式（Interpreter-Pattern）"><a href="#11-解释器模式（Interpreter-Pattern）" class="headerlink" title="11. 解释器模式（Interpreter Pattern）"></a>11. 解释器模式（Interpreter Pattern）</h3><p>解释器模式是一种行为型设计模式，它定义了一种语言，用于表示特定问题领域的语法规则，并提供了一种方式来解释这种语言中的语句。通过使用解释器模式，我们可以将一个问题转换为一个表达式，然后使用这个表达式来解决问题。</p><p>解释器模式通常用于以下场景：</p><ul><li>当我们需要解决某个特定领域的问题时，比如数学、逻辑、日期等，可以使用解释器模式来定义这个领域的语法规则，并提供一种方式来解释这些规则。</li><li>当我们需要实现一种简单的语言解释器时，可以使用解释器模式来定义这个语言的语法规则，并提供一种方式来解释这些规则。</li><li>当我们需要根据特定的规则生成表达式时，可以使用解释器模式来实现这个功能。</li></ul><p>下面是一个简单的 Swift 5 代码示例，演示了如何使用解释器模式来解释简单的数学表达式。假设我们有一些简单的数学表达式，比如“1 + 2 + 3”，“1 - 2 + 3”等，我们可以定义一个解释器对象（Interpreter），来解释这些表达式，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 解释器</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Interpreter</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> expression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">expression</span>: <span class="hljs-type">Expression</span>) &#123;        <span class="hljs-keyword">self</span>.expression <span class="hljs-operator">=</span> expression    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">return</span> expression.interpret()    &#125;&#125;<span class="hljs-comment">// 表达式</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span>&#125;<span class="hljs-comment">// 数字表达式</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumberExpression</span>: <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">value</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.value <span class="hljs-operator">=</span> value    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">return</span> value    &#125;&#125;<span class="hljs-comment">// 加法表达式</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddExpression</span>: <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> leftExpression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> rightExpression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">leftExpression</span>: <span class="hljs-type">Expression</span>, <span class="hljs-params">rightExpression</span>: <span class="hljs-type">Expression</span>) &#123;        <span class="hljs-keyword">self</span>.leftExpression <span class="hljs-operator">=</span> leftExpression        <span class="hljs-keyword">self</span>.rightExpression <span class="hljs-operator">=</span> rightExpression    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">return</span> leftExpression.interpret() <span class="hljs-operator">+</span> rightExpression.interpret()    &#125;&#125;<span class="hljs-comment">// 减法表达式</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubtractExpression</span>: <span class="hljs-title class_">Expression</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> leftExpression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> rightExpression: <span class="hljs-type">Expression</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">leftExpression</span>: <span class="hljs-type">Expression</span>, <span class="hljs-params">rightExpression</span>: <span class="hljs-type">Expression</span>) &#123;        <span class="hljs-keyword">self</span>.leftExpression <span class="hljs-operator">=</span> leftExpression        <span class="hljs-keyword">self</span>.rightExpression <span class="hljs-operator">=</span> rightExpression    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">interpret</span>() -&gt; <span class="hljs-type">Int</span> &#123;        <span class="hljs-keyword">return</span> leftExpression.interpret() <span class="hljs-operator">-</span> rightExpression.interpret()    &#125;&#125;</code></pre></div><p>在这个例子中，我们定义了一个解释器对象（Interpreter），它包含一个表达式对象（Expression）。我们还定义了三个不同的表达式类型：数字表达式（NumberExpression）、加法表达式（AddExpression）和减法表达式（SubtractExpression）。</p><p>数字表达式表示一个简单的数字，例如“1”或“2”。加法表达式和减法表达式分别表示加法和减法运算。它们都包含左表达式和右表达式，这些表达式都可以是数字表达式或其他的加法&#x2F;减法表达式。这些表达式实现了一个 <strong><code>interpret()</code></strong> 方法，用于解释表达式，并返回表达式的计算结果。</p><p>现在我们可以使用这些表达式和解释器来解释数学表达式了。例如，我们可以解释一个简单的数学表达式“1 + 2 + 3”，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> expression <span class="hljs-operator">=</span> <span class="hljs-type">AddExpression</span>(    leftExpression: <span class="hljs-type">AddExpression</span>(        leftExpression: <span class="hljs-type">NumberExpression</span>(value: <span class="hljs-number">1</span>),        rightExpression: <span class="hljs-type">NumberExpression</span>(value: <span class="hljs-number">2</span>)    ),    rightExpression: <span class="hljs-type">NumberExpression</span>(value: <span class="hljs-number">3</span>))<span class="hljs-keyword">let</span> interpreter <span class="hljs-operator">=</span> <span class="hljs-type">Interpreter</span>(expression: expression)<span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> interpreter.interpret()<span class="hljs-built_in">print</span>(result) <span class="hljs-comment">// Output: 6</span></code></pre></div><p>在这个例子中，我们首先创建了一个加法表达式对象，它由三个数字表达式组成，表示一个简单的加法表达式“1 + 2 + 3”。然后我们创建了一个解释器对象，并传入这个加法表达式对象。最后，我们调用解释器对象的 <strong><code>interpret()</code></strong> 方法，得到这个表达式的计算结果，并将其打印出来。</p><p>解释器模式虽然能够解决一些特定问题领域的语法解析问题，但是在实际开发中使用较少，因为其实现和使用比较复杂。通常情况下，我们可以使用其他的方式来解决类似的问题，比如使用正则表达式或特定的库来解析文本。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用开发原则</title>
    <link href="/2023/02/25/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/"/>
    <url>/2023/02/25/%E5%B8%B8%E7%94%A8%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="常用开发原则"><a href="#常用开发原则" class="headerlink" title="常用开发原则"></a>常用开发原则</h2><h3 id="1-单一职责原则（Single-Responsibility-Principle，SRP）"><a href="#1-单一职责原则（Single-Responsibility-Principle，SRP）" class="headerlink" title="1. 单一职责原则（Single Responsibility Principle，SRP）"></a>1. 单一职责原则（Single Responsibility Principle，SRP）</h3><p>单一职责原则（Single Responsibility Principle，SRP）是面向对象设计中的一项基本原则，它指出一个类或模块应该只有一个职责或责任，即一个类或模块应该只负责一种功能或行为。</p><p>单一职责原则的目的是将复杂的系统分解为多个简单的组件，每个组件都只关注一个特定的功能或职责，从而使系统更加灵活、可扩展和易于维护。当一个类或模块承担了多种职责时，它就变得复杂、难以维护和扩展，因为修改其中一个职责可能会影响到其他职责。</p><p>单一职责原则常用来解决以下问题：</p><ul><li>类或模块过于庞大，难以维护和理解；</li><li>类或模块承担了过多的职责，难以扩展和重用；</li><li>修改一个职责会影响到其他职责，导致系统出现不稳定的行为。</li></ul><p>下面是一个使用 Swift 5 实现单一职责原则的示例。我们有一个 <strong><code>Order</code></strong> 类，用于表示客户订单，其中包含了订单的详细信息以及订单的处理方法。我们可以将 <strong><code>Order</code></strong> 类拆分成两个类，一个用于表示订单信息，另一个用于处理订单，从而使其符合单一职责原则。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 订单信息类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderInfo</span> &#123;    <span class="hljs-keyword">let</span> orderId: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> customerName: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> orderDate: <span class="hljs-type">Date</span>    <span class="hljs-keyword">let</span> orderItems: [<span class="hljs-type">OrderItem</span>]    <span class="hljs-keyword">init</span>(<span class="hljs-params">orderId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">customerName</span>: <span class="hljs-type">String</span>, <span class="hljs-params">orderDate</span>: <span class="hljs-type">Date</span>, <span class="hljs-params">orderItems</span>: [<span class="hljs-type">OrderItem</span>]) &#123;        <span class="hljs-keyword">self</span>.orderId <span class="hljs-operator">=</span> orderId        <span class="hljs-keyword">self</span>.customerName <span class="hljs-operator">=</span> customerName        <span class="hljs-keyword">self</span>.orderDate <span class="hljs-operator">=</span> orderDate        <span class="hljs-keyword">self</span>.orderItems <span class="hljs-operator">=</span> orderItems    &#125;&#125;<span class="hljs-comment">// 订单处理类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">order</span>: <span class="hljs-type">OrderInfo</span>) &#123;        <span class="hljs-comment">// 处理订单逻辑</span>    &#125;&#125;</code></pre></div><p>在上面的示例中，我们将 <strong><code>Order</code></strong> 类拆分成了 <strong><code>OrderInfo</code></strong> 和 <strong><code>OrderProcessor</code></strong> 两个类。**<code>OrderInfo</code>** 类用于表示订单的详细信息，包括订单编号、客户名称、下单日期和订单项；**<code>OrderProcessor</code>** 类用于处理订单，包括处理订单的逻辑和实现。</p><p>通过将 <strong><code>Order</code></strong> 类拆分成多个类，我们遵守了单一职责原则，使每个类只关注一种特定的功能或职责。这样，如果我们需要修改订单处理逻辑，就不会影响到订单信息的表示和存储，从而使系统更加稳定和易于维护。</p><h3 id="2-开放封闭原则（Open-x2F-Closed-Principle，OCP）"><a href="#2-开放封闭原则（Open-x2F-Closed-Principle，OCP）" class="headerlink" title="2. 开放封闭原则（Open&#x2F;Closed Principle，OCP）"></a>2. 开放封闭原则（Open&#x2F;Closed Principle，OCP）</h3><p>开放封闭原则（Open&#x2F;Closed Principle，OCP）是面向对象设计中的一项基本原则，它指出一个软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。这意味着在不修改原有代码的情况下，可以通过扩展代码的行为来实现新的功能。</p><p>开放封闭原则的目的是保持系统的稳定性和可维护性。当系统需要修改现有代码来添加新的功能时，可能会导致系统出现不稳定的行为和意外的副作用。通过遵守开放封闭原则，我们可以避免这些问题，同时使系统更加灵活和易于扩展。</p><p>开放封闭原则常用来解决以下问题：</p><ul><li>当需要添加新的功能时，不希望修改现有的代码；</li><li>当需要修改现有的代码时，不希望影响到系统的稳定性和可维护性。</li></ul><p>下面是一个使用 Swift 5 实现开放封闭原则的示例。我们有一个 <strong><code>OrderProcessor</code></strong> 类，用于处理客户订单，其中包含了订单的详细信息以及订单的处理方法。我们希望能够通过添加新的支付方式来扩展订单处理逻辑，同时不影响现有的代码。为了实现这个目标，我们可以将支付逻辑封装到一个单独的类中，从而使其可以独立扩展和修改。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 订单信息类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderInfo</span> &#123;    <span class="hljs-keyword">let</span> orderId: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> customerName: <span class="hljs-type">String</span>    <span class="hljs-keyword">let</span> orderDate: <span class="hljs-type">Date</span>    <span class="hljs-keyword">let</span> orderItems: [<span class="hljs-type">OrderItem</span>]    <span class="hljs-keyword">init</span>(<span class="hljs-params">orderId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">customerName</span>: <span class="hljs-type">String</span>, <span class="hljs-params">orderDate</span>: <span class="hljs-type">Date</span>, <span class="hljs-params">orderItems</span>: [<span class="hljs-type">OrderItem</span>]) &#123;        <span class="hljs-keyword">self</span>.orderId <span class="hljs-operator">=</span> orderId        <span class="hljs-keyword">self</span>.customerName <span class="hljs-operator">=</span> customerName        <span class="hljs-keyword">self</span>.orderDate <span class="hljs-operator">=</span> orderDate        <span class="hljs-keyword">self</span>.orderItems <span class="hljs-operator">=</span> orderItems    &#125;&#125;<span class="hljs-comment">// 支付接口</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Payment</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>)&#125;<span class="hljs-comment">// 现金支付类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">CashPayment</span>: <span class="hljs-title class_">Payment</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-comment">// 现金支付逻辑</span>    &#125;&#125;<span class="hljs-comment">// 支付宝支付类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlipayPayment</span>: <span class="hljs-title class_">Payment</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">pay</span>(<span class="hljs-params">amount</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-comment">// 支付宝支付逻辑</span>    &#125;&#125;<span class="hljs-comment">// 订单处理类</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderProcessor</span> &#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> payment: <span class="hljs-type">Payment</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">payment</span>: <span class="hljs-type">Payment</span>) &#123;        <span class="hljs-keyword">self</span>.payment <span class="hljs-operator">=</span> payment    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">order</span>: <span class="hljs-type">OrderInfo</span>) &#123;        <span class="hljs-comment">// 处理订单逻辑</span>        <span class="hljs-comment">// 支付订单</span>        payment.pay(amount: order.totalAmount)    &#125;&#125;</code></pre></div><p>在上面的示例中，我们将支付逻辑封装到了 <strong><code>Payment</code></strong> 接口中，并实现了两个具体的支付类 <strong><code>CashPayment</code></strong> 和 **<code>AlipayPayment</code>**。我们还将支付逻辑注入到了 <strong><code>OrderProcessor</code></strong> 类中，通过传递不同的支付类实现订单处理的扩展和修改。</p><p>通过将支付逻辑封装到一个单独的类中，我们可以在不影响现有代码的情况下，添加新的支付方式和修改支付逻辑，从而实现了开放封闭原则。当需要添加新的支付方式时，我们只需要实现一个新的支付类并注入到 <strong><code>OrderProcessor</code></strong> 中即可，不需要修改现有的代码。</p><p>下面是一个示例代码，用于创建一个现金支付订单：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> order <span class="hljs-operator">=</span> <span class="hljs-type">OrderInfo</span>(orderId: <span class="hljs-string">&quot;123456&quot;</span>, customerName: <span class="hljs-string">&quot;张三&quot;</span>, orderDate: <span class="hljs-type">Date</span>(), orderItems: [item1, item2])<span class="hljs-keyword">let</span> cashPayment <span class="hljs-operator">=</span> <span class="hljs-type">CashPayment</span>()<span class="hljs-keyword">let</span> orderProcessor <span class="hljs-operator">=</span> <span class="hljs-type">OrderProcessor</span>(payment: cashPayment)orderProcessor.process(order: order)</code></pre></div><p>我们还可以创建一个支付宝支付订单：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> order <span class="hljs-operator">=</span> <span class="hljs-type">OrderInfo</span>(orderId: <span class="hljs-string">&quot;123456&quot;</span>, customerName: <span class="hljs-string">&quot;张三&quot;</span>, orderDate: <span class="hljs-type">Date</span>(), orderItems: [item1, item2])<span class="hljs-keyword">let</span> alipayPayment <span class="hljs-operator">=</span> <span class="hljs-type">AlipayPayment</span>()<span class="hljs-keyword">let</span> orderProcessor <span class="hljs-operator">=</span> <span class="hljs-type">OrderProcessor</span>(payment: alipayPayment)orderProcessor.process(order: order)</code></pre></div><p>通过实现开放封闭原则，我们使系统更加灵活和易于扩展，同时保持了系统的稳定性和可维护性。</p><h3 id="3-里式替换原则（Liskov-Substitution-Principle，LSP）"><a href="#3-里式替换原则（Liskov-Substitution-Principle，LSP）" class="headerlink" title="3. 里式替换原则（Liskov Substitution Principle，LSP）"></a>3. 里式替换原则（Liskov Substitution Principle，LSP）</h3><p>里式替换原则（Liskov Substitution Principle，LSP）是面向对象设计中的一个重要原则，它指出：子类对象应该能够替换掉父类对象并且仍能保持程序的正确性。</p><p>这个原则的核心思想是：子类不应该破坏父类的封装和抽象，即子类中新增的方法和属性不应该影响到父类的行为。LSP可以帮助我们确保代码的正确性和可扩展性，同时也可以避免出现一些难以调试的问题。</p><p>下面，我们以一个简单的 Swift 示例来说明 LSP 的应用。假设我们有一个图形库，其中包含 <strong><code>Shape</code></strong> 基类和两个子类 <strong><code>Rectangle</code></strong> 和 <strong><code>Circle</code><strong>。</strong><code>Shape</code></strong> 类有一个计算面积的方法 <strong><code>calculateArea()</code><strong>，</strong><code>Rectangle</code></strong> 和 <strong><code>Circle</code></strong> 分别实现了这个方法。我们可以使用这些类来创建不同的图形，并计算它们的面积。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">var</span> width: <span class="hljs-type">Double</span>    <span class="hljs-keyword">var</span> height: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">width</span>: <span class="hljs-type">Double</span>, <span class="hljs-params">height</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.width <span class="hljs-operator">=</span> width        <span class="hljs-keyword">self</span>.height <span class="hljs-operator">=</span> height    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> width <span class="hljs-operator">*</span> height    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span>: <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">var</span> radius: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">radius</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.radius <span class="hljs-operator">=</span> radius    &#125;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateArea</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">Double</span>.pi <span class="hljs-operator">*</span> radius <span class="hljs-operator">*</span> radius    &#125;&#125;</code></pre></div><p>现在，我们希望在图形库中添加一个新的图形类 **<code>Square</code>**，它是 <strong><code>Rectangle</code></strong> 的一个特例，即它的宽和高相等。按照 LSP 的原则，我们应该可以将 <strong><code>Square</code></strong> 对象替换为 <strong><code>Rectangle</code></strong> 对象而不会影响程序的正确性。</p><p>我们可以创建一个 <strong><code>Square</code></strong> 类继承自 **<code>Rectangle</code>**，并重写父类的初始化方法，确保 <strong><code>width</code></strong> 和 <strong><code>height</code></strong> 始终相等：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span>: <span class="hljs-title class_">Rectangle</span> &#123;    <span class="hljs-keyword">init</span>(<span class="hljs-params">side</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">super</span>.<span class="hljs-keyword">init</span>(width: side, height: side)    &#125;&#125;</code></pre></div><p>现在，我们可以在创建图形时使用 <strong><code>Square</code></strong> 替换 <strong><code>Rectangle</code></strong> 对象，并调用 <strong><code>calculateArea()</code></strong> 方法计算面积：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> rectangle <span class="hljs-operator">=</span> <span class="hljs-type">Rectangle</span>(width: <span class="hljs-number">4</span>, height: <span class="hljs-number">5</span>)<span class="hljs-keyword">let</span> circle <span class="hljs-operator">=</span> <span class="hljs-type">Circle</span>(radius: <span class="hljs-number">3</span>)<span class="hljs-keyword">let</span> square <span class="hljs-operator">=</span> <span class="hljs-type">Square</span>(side: <span class="hljs-number">4</span>)<span class="hljs-keyword">let</span> shapes: [<span class="hljs-type">Shape</span>] <span class="hljs-operator">=</span> [rectangle, circle, square]<span class="hljs-keyword">for</span> shape <span class="hljs-keyword">in</span> shapes &#123;    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Area of <span class="hljs-subst">\(<span class="hljs-built_in">type</span>(of: shape))</span> is <span class="hljs-subst">\(shape.calculateArea())</span>&quot;</span>)&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs">输出结果如下：</code></pre></div><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-type">Area</span> of <span class="hljs-type">Rectangle</span> <span class="hljs-keyword">is</span> <span class="hljs-number">20.0</span><span class="hljs-type">Area</span> of <span class="hljs-type">Circle</span> <span class="hljs-keyword">is</span> <span class="hljs-number">28.274333882308138</span><span class="hljs-type">Area</span> of <span class="hljs-type">Square</span> <span class="hljs-keyword">is</span> <span class="hljs-number">16.0</span></code></pre></div><p>由于 <strong><code>Square</code></strong> 对象是 <strong><code>Rectangle</code></strong> 的特例，我们可以使用 <strong><code>Square</code></strong> 对象替换 <strong><code>Rectangle</code></strong> 对象而不影响程序的正确性。这就是 LSP 的应用途，通过使用 LSP，我们可以创建更加灵活的代码，可以轻松地添加新的子类，并在不破坏现有代码的情况下进行修改和扩展。</p><p>在实际开发中，为了遵循 LSP 原则，我们需要遵循以下几个准则：</p><ul><li>子类必须实现父类的所有方法，并且方法的输入输出参数类型与父类一致或者更加宽松。</li><li>子类新增的方法和属性不应该影响到父类的行为。</li><li>子类的前置条件（输入参数）不能强于父类的前置条件。</li><li>子类的后置条件（输出参数）不能弱于父类的后置条件。</li></ul><p>下面，我们再以一个 Swift 示例来说明 LSP 的应用。假设我们有一个计算器应用，其中包含一个 <strong><code>Calculator</code></strong> 基类和两个子类 <strong><code>SimpleCalculator</code></strong> 和 <strong><code>ScientificCalculator</code><strong>。</strong><code>Calculator</code></strong> 类有一个计算方法 <strong><code>calculate(_:)</code><strong>，</strong><code>SimpleCalculator</code></strong> 和 <strong><code>ScientificCalculator</code></strong> 分别实现了这个方法。我们可以使用这些类来进行简单的数学计算。</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">&quot;This method must be overridden&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-comment">// 简单计算逻辑</span>    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ScientificCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-comment">// 科学计算逻辑</span>    &#125;&#125;</code></pre></div><p>现在，我们希望添加一个新的子类 **<code>GraphingCalculator</code>**，它可以将计算结果以图表的形式展示出来。按照 LSP 的原则，我们应该可以将 <strong><code>GraphingCalculator</code></strong> 对象替换为 <strong><code>SimpleCalculator</code></strong> 或 <strong><code>ScientificCalculator</code></strong> 对象而不会影响程序的正确性。</p><p>我们可以创建一个 <strong><code>GraphingCalculator</code></strong> 类，它继承自 **<code>Calculator</code>**，并实现 <strong><code>calculate(_:)</code></strong> 方法：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphingCalculator</span>: <span class="hljs-title class_">Calculator</span> &#123;    <span class="hljs-keyword">override</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-keyword">_</span> <span class="hljs-params">expression</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">let</span> result <span class="hljs-operator">=</span> <span class="hljs-keyword">super</span>.calculate(expression)        <span class="hljs-comment">// 将计算结果以图表的形式展示出来</span>        <span class="hljs-keyword">return</span> result    &#125;&#125;</code></pre></div><p>现在，我们可以使用 <strong><code>GraphingCalculator</code></strong> 对象来进行数学计算，并将计算结果以图表的形式展示出来：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">let</span> simpleCalculator <span class="hljs-operator">=</span> <span class="hljs-type">SimpleCalculator</span>()<span class="hljs-keyword">let</span> scientificCalculator <span class="hljs-operator">=</span> <span class="hljs-type">ScientificCalculator</span>()<span class="hljs-keyword">let</span> graphingCalculator <span class="hljs-operator">=</span> <span class="hljs-type">GraphingCalculator</span>()<span class="hljs-keyword">let</span> expressions <span class="hljs-operator">=</span> [<span class="hljs-string">&quot;2 + 2&quot;</span>, <span class="hljs-string">&quot;sin(45)&quot;</span>, <span class="hljs-string">&quot;log(10)&quot;</span>]<span class="hljs-keyword">for</span> expression <span class="hljs-keyword">in</span> expressions &#123;    <span class="hljs-keyword">let</span> simpleResult <span class="hljs-operator">=</span> simpleCalculator.calculate(expression)    <span class="hljs-keyword">let</span> scientificResult <span class="hljs-operator">=</span> scientificCalculator.calculate(expression)    <span class="hljs-keyword">let</span> graphingResult <span class="hljs-operator">=</span> graphingCalculator.calculate(expression)    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Simple: <span class="hljs-subst">\(simpleResult)</span>, Scientific: <span class="hljs-subst">\(scientificResult)</span>, Graphing: <span class="hljs-subst">\(graphingResult)</span>&quot;</span>)&#125;</code></pre></div><p>输出结果如下：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-type">Simple</span>: <span class="hljs-number">4.0</span>, <span class="hljs-type">Scientific</span>: <span class="hljs-number">0.8509035245341184</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">4.0</span><span class="hljs-type">Simple</span>: <span class="hljs-number">0.8509035245341184</span>,<span class="hljs-type">Scientific</span>: <span class="hljs-number">0.8509035245341184</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">0.8509035245341184</span><span class="hljs-type">Simple</span>: <span class="hljs-number">2.302585092994046</span>, <span class="hljs-type">Scientific</span>: <span class="hljs-number">2.302585092994046</span>, <span class="hljs-type">Graphing</span>: <span class="hljs-number">2.302585092994046</span></code></pre></div><p>可以看到，我们成功地将 <code>GraphingCalculator</code> 对象替换为 <code>SimpleCalculator</code> 和 <code>ScientificCalculator</code> 对象，而不会影响程序的正确性。这就是 LSP 的优势。</p><p>总之，LSP 是一个非常重要的面向对象编程原则，它可以帮助我们创建灵活、可扩展、易于维护的代码。为了遵循 LSP，我们需要在设计类的时候遵循一些基本的规则，并保证子类可以完全替换父类，而不会影响程序的正确性。</p><h3 id="4-接口隔离原则（Interface-Segregation-Principle，ISP）"><a href="#4-接口隔离原则（Interface-Segregation-Principle，ISP）" class="headerlink" title="4. 接口隔离原则（Interface Segregation Principle，ISP）"></a>4. 接口隔离原则（Interface Segregation Principle，ISP）</h3><p>接口隔离原则（Interface Segregation Principle，ISP）是面向对象编程中的一条原则，它指出“客户端不应该被迫依赖于它不使用的方法”。换句话说，如果一个接口的方法过于冗杂，一个类可能不得不实现一些它并不需要的方法。这不仅浪费了时间和资源，而且会导致代码的复杂性和脆弱性。</p><p>ISP 的主要目的是分离接口，将大型、复杂的接口分解为更小、更简单的接口，以便客户端只需知道与其相关的方法。这样，客户端就不必担心不需要的方法，而只需要专注于与其相关的方法。</p><p>为了遵循 ISP，我们需要在设计接口时考虑到客户端的需要，并将其分解为更小、更简单的接口。这样，客户端只需要依赖它们需要的接口，而不必依赖于整个接口。</p><p>下面是一个使用 ISP 的例子。假设我们正在设计一个图形编辑器，其中有多种形状（如矩形、圆形、三角形等）。每个形状都可以绘制、移动、调整大小等。我们可以将这些操作定义在一个大型的 <strong><code>Shape</code></strong> 接口中，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Shape</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>()    <span class="hljs-keyword">func</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">to</span> <span class="hljs-params">point</span>: <span class="hljs-type">CGPoint</span>)    <span class="hljs-keyword">func</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">to</span> <span class="hljs-params">size</span>: <span class="hljs-type">CGSize</span>)&#125;</code></pre></div><p>然而，如果我们这样设计，那么所有的形状都必须实现所有的方法，即使它们并不需要某些方法。这显然不符合 ISP。为了解决这个问题，我们可以将这个大型接口拆分为多个更小、更专业的接口，如下所示：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Drawable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">draw</span>()&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Movable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">move</span>(<span class="hljs-params">to</span> <span class="hljs-params">point</span>: <span class="hljs-type">CGPoint</span>)&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Resizable</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">resize</span>(<span class="hljs-params">to</span> <span class="hljs-params">size</span>: <span class="hljs-type">CGSize</span>)&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Shape</span>: <span class="hljs-title class_">Drawable</span>, <span class="hljs-title class_">Movable</span>, <span class="hljs-title class_">Resizable</span> &#123;&#125;</code></pre></div><p>现在，我们的每个形状只需要实现与其相关的方法。例如，圆形只需要实现 <strong><code>Drawable</code></strong> 和 <strong><code>Resizable</code></strong> 接口，而不需要实现 <strong><code>Movable</code></strong> 接口。这样，我们的代码就更加灵活，易于扩展和维护了。</p><p>总之，ISP 是一个非常重要的面向对象编程原则，它可以帮助我们创建灵活、可扩展、易于维护的代码。为了遵循 ISP，我们需要在设计接口时考虑客户端的需要，并将其拆分为更小、更简单的接口。</p><h3 id="5-迪米特法则（Law-of-Demeter，LoD）"><a href="#5-迪米特法则（Law-of-Demeter，LoD）" class="headerlink" title="5. 迪米特法则（Law of Demeter，LoD）"></a>5. 迪米特法则（Law of Demeter，LoD）</h3><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Principle of Least Knowledge），是面向对象编程中的一条设计原则，它强调一个对象应该尽可能少地了解其他对象，并且只和它们的直接朋友（成员变量、方法参数等）通信，而不与非直接朋友进行通信。</p><p>迪米特法则的目的是减少类之间的耦合度，提高系统的稳定性、可维护性和可扩展性。当一个类依赖的其他类太多时，如果这些依赖的类发生了改变，就会对该类产生较大的影响，从而导致代码的复杂度增加。因此，遵循迪米特法则可以使得类之间的耦合度降低，从而使得代码更加模块化、易于维护和重构。</p><p>下面以 Swift 5 代码举例，展示如何使用迪米特法则来减少类之间的耦合度。假设我们有一个订单类，它需要依赖客户类和商品类来进行处理：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;    <span class="hljs-keyword">var</span> customerId: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> productId: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> quantity: <span class="hljs-type">Int</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">productId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">quantity</span>: <span class="hljs-type">Int</span>) &#123;        <span class="hljs-keyword">self</span>.customerId <span class="hljs-operator">=</span> customerId        <span class="hljs-keyword">self</span>.productId <span class="hljs-operator">=</span> productId        <span class="hljs-keyword">self</span>.quantity <span class="hljs-operator">=</span> quantity    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateTotal</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">let</span> customer <span class="hljs-operator">=</span> <span class="hljs-type">Customer</span>.getCustomerById(customerId: customerId)        <span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> <span class="hljs-type">Product</span>.getProductById(productId: productId)        <span class="hljs-keyword">let</span> totalPrice <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(quantity) <span class="hljs-operator">*</span> product.price        <span class="hljs-keyword">return</span> totalPrice    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span> &#123;        <span class="hljs-comment">// 模拟获取客户对象的过程</span>        <span class="hljs-keyword">return</span> <span class="hljs-type">Customer</span>(id: customerId, name: <span class="hljs-string">&quot;&quot;</span>)    &#125;    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">static</span> <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-comment">// 模拟获取商品对象的过程</span>        <span class="hljs-keyword">return</span> <span class="hljs-type">Product</span>(id: productId, name: <span class="hljs-string">&quot;&quot;</span>, price: <span class="hljs-number">0.0</span>)    &#125;    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price    &#125;&#125;</code></pre></div><p>在上述代码中，订单类依赖了客户类和商品类的静态方法，通过这些静态方法获取了客户对象和商品对象。这种方式违反了迪米特法则，因为订单类不仅需要了解客户类和商品类的接口，还需要了解它们的具体实现细节。</p><p>为了遵循迪米特法则，我们可以通过依赖注入的方式，来减少订单类对客户类和商品类的依赖。下面是修改后的代码：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">CustomerProtocol</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomerService</span>: <span class="hljs-title class_">CustomerProtocol</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getCustomerById</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Customer</span> &#123;        <span class="hljs-comment">// 模拟获取客户对象的过程</span>        <span class="hljs-keyword">return</span> <span class="hljs-type">Customer</span>(id: customerId, name: <span class="hljs-string">&quot;&quot;</span>)    &#125;&#125;<span class="hljs-keyword">protocol</span> <span class="hljs-title class_">ProductProtocol</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span>&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span>: <span class="hljs-title class_">ProductProtocol</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">getProductById</span>(<span class="hljs-params">productId</span>: <span class="hljs-type">String</span>) -&gt; <span class="hljs-type">Product</span> &#123;        <span class="hljs-comment">// 模拟获取商品对象的过程</span>        <span class="hljs-keyword">return</span> <span class="hljs-type">Product</span>(id: productId, name: <span class="hljs-string">&quot;&quot;</span>, price: <span class="hljs-number">0.0</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> &#123;    <span class="hljs-keyword">var</span> customerId: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> productId: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> quantity: <span class="hljs-type">Int</span>    <span class="hljs-keyword">var</span> customerService: <span class="hljs-type">CustomerProtocol</span>    <span class="hljs-keyword">var</span> productService: <span class="hljs-type">ProductProtocol</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">customerId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">productId</span>: <span class="hljs-type">String</span>, <span class="hljs-params">quantity</span>: <span class="hljs-type">Int</span>, <span class="hljs-params">customerService</span>: <span class="hljs-type">CustomerProtocol</span>, <span class="hljs-params">productService</span>: <span class="hljs-type">ProductProtocol</span>) &#123;        <span class="hljs-keyword">self</span>.customerId <span class="hljs-operator">=</span> customerId        <span class="hljs-keyword">self</span>.productId <span class="hljs-operator">=</span> productId        <span class="hljs-keyword">self</span>.quantity <span class="hljs-operator">=</span> quantity        <span class="hljs-keyword">self</span>.customerService <span class="hljs-operator">=</span> customerService        <span class="hljs-keyword">self</span>.productService <span class="hljs-operator">=</span> productService    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">calculateTotal</span>() -&gt; <span class="hljs-type">Double</span> &#123;        <span class="hljs-keyword">let</span> customer <span class="hljs-operator">=</span> customerService.getCustomerById(customerId: customerId)        <span class="hljs-keyword">let</span> product <span class="hljs-operator">=</span> productService.getProductById(productId: productId)        <span class="hljs-keyword">let</span> totalPrice <span class="hljs-operator">=</span> <span class="hljs-type">Double</span>(quantity) <span class="hljs-operator">*</span> product.price        <span class="hljs-keyword">return</span> totalPrice    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Customer</span> &#123;    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>) &#123;        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;    <span class="hljs-keyword">var</span> id: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> name: <span class="hljs-type">String</span>    <span class="hljs-keyword">var</span> price: <span class="hljs-type">Double</span>    <span class="hljs-keyword">init</span>(<span class="hljs-params">id</span>: <span class="hljs-type">String</span>, <span class="hljs-params">name</span>: <span class="hljs-type">String</span>, <span class="hljs-params">price</span>: <span class="hljs-type">Double</span>) &#123;        <span class="hljs-keyword">self</span>.id <span class="hljs-operator">=</span> id        <span class="hljs-keyword">self</span>.name <span class="hljs-operator">=</span> name        <span class="hljs-keyword">self</span>.price <span class="hljs-operator">=</span> price    &#125;&#125;</code></pre></div><p>在上述代码中，我们使用协议和依赖注入的方式来降低订单类对客户类和商品类的耦合度。具体来说，我们定义了两个协议 <code>CustomerProtocol</code> 和 <code>ProductProtocol</code>，分别包含了获取客户对象和商品对象的方法。然后我们实现了两个具体的服务类 <code>CustomerService</code> 和 <code>ProductService</code>，它们分别实现了上述协议中定义的方法，用于提供客户对象和商品对象的获取功能。</p><p>接下来，我们修改了订单类的构造函数，将客户服务对象和商品服务对象作为参数传入。在 calculateTotal 方法中，我们不再直接调用客户类和商品类的静态方法，而是通过客户服务对象和商品服务对象来获取客户对象和商品对象。这样一来，订单类只依赖了客户服务类和商品服务类的接口，而不再依赖它们的具体实现细节，这就遵循了迪米特法则。</p><p>总之，迪米特法则是一条重要的设计原则，它可以帮助我们减少类之间的耦合度，提高系统的稳定性、可维护性和可扩展性。在编写代码时，我们应该尽可能地遵循这个原则，尽量减少类之间的交互，使得每个类的职责更加清晰，代码结构更加简单易懂，从而使得代码更加健壮和可维护。</p><p>需要注意的是，在实际开发中，迪米特法则并不是一个银弹，它并不能解决所有的问题，也不能被简单地应用到所有的场景中。在某些情况下，迪米特法则可能会导致类之间的通信变得复杂，从而降低系统的效率和性能。因此，在应用迪米特法则时，我们需要根据具体的情况来灵活运用，综合考虑各种因素，找到最合适的设计方案。</p><p>“银弹”是一个编程界中的术语，指的是一种能够解决所有问题的神奇解决方案。因此，“迪米特法则并不是一个银弹”意味着迪米特法则并不能解决所有问题，我们需要根据具体情况进行灵活应用和综合考虑。</p><h3 id="6-依赖倒置原则（Dependency-Inversion-Principle，DIP）"><a href="#6-依赖倒置原则（Dependency-Inversion-Principle，DIP）" class="headerlink" title="6. 依赖倒置原则（Dependency Inversion Principle，DIP）"></a>6. 依赖倒置原则（Dependency Inversion Principle，DIP）</h3><p>依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计中的一个重要原则，它强调高层模块不应该依赖低层模块，它们都应该依赖于抽象；而抽象不应该依赖于细节，细节应该依赖于抽象。简单来说，就是要面向接口编程，而不是面向实现编程。</p><p>依赖倒置原则的作用是降低模块之间的耦合度，提高代码的灵活性、可扩展性和可维护性。它可以避免在修改一个模块时，对其他模块造成影响，同时也能够方便地进行单元测试和模块重用。</p><p>下面是使用 Swift 5 实现依赖倒置原则的一个示例：</p><div class="code-wrapper"><pre><code class="hljs swift"><span class="hljs-comment">// 定义一个协议</span><span class="hljs-keyword">protocol</span> <span class="hljs-title class_">Animal</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>()&#125;<span class="hljs-comment">// 实现两个类，它们都遵循了 Animal 协议</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>: <span class="hljs-title class_">Animal</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Meow&quot;</span>)    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <span class="hljs-title class_">Animal</span> &#123;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeSound</span>() &#123;        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Woof&quot;</span>)    &#125;&#125;<span class="hljs-comment">// 定义一个高层模块，它依赖于 Animal 协议</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalShelter</span> &#123;    <span class="hljs-keyword">var</span> animals: [<span class="hljs-type">Animal</span>] <span class="hljs-operator">=</span> []    <span class="hljs-keyword">func</span> <span class="hljs-title function_">addAnimal</span>(<span class="hljs-params">animal</span>: <span class="hljs-type">Animal</span>) &#123;        animals.append(animal)    &#125;    <span class="hljs-keyword">func</span> <span class="hljs-title function_">makeAllAnimalsSound</span>() &#123;        <span class="hljs-keyword">for</span> animal <span class="hljs-keyword">in</span> animals &#123;            animal.makeSound()        &#125;    &#125;&#125;<span class="hljs-comment">// 在客户端代码中，可以通过向 AnimalShelter 添加不同的 Animal 来实现不同的行为</span><span class="hljs-keyword">let</span> animalShelter <span class="hljs-operator">=</span> <span class="hljs-type">AnimalShelter</span>()animalShelter.addAnimal(animal: <span class="hljs-type">Cat</span>())animalShelter.addAnimal(animal: <span class="hljs-type">Dog</span>())animalShelter.makeAllAnimalsSound()</code></pre></div><p>在上面的示例中，Animal 是一个抽象的概念，Cat 和 Dog 是具体的实现类。AnimalShelter 是一个高层模块，它不依赖于具体的实现类，而是依赖于 Animal 协议。在客户端代码中，可以通过向 AnimalShelter 添加不同的 Animal 来实现不同的行为，而不需要修改 AnimalShelter 类的代码。</p><p>这就是依赖倒置原则的一个实现，它通过引入抽象的概念，降低了 AnimalShelter 和具体实现类之间的耦合度，提高了代码的可扩展性和可维护性。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swift</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo</title>
    <link href="/2023/02/25/hello-world/"/>
    <url>/2023/02/25/hello-world/</url>
    
    <content type="html"><![CDATA[<p>自从认识 notion 以来，一直都只使用 notion 写东西就再也没玩博客也了。notion 虽然也能分享页面链接，但用作于博客还是不太方便。今天有时间空下来，专门研究了一下 github.io 如何搭建个人博客网站，发现 Hexo &amp; Fluid 原来是这么的方便、这么的好用。<br>写 blog 只需简单的执行几句命令行：</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一篇博客文章</span>hexo new <span class="hljs-string">&quot;title&quot;</span><span class="hljs-comment"># 清理缓存 -&gt; 本地测试（就可以直接预览）</span>hexo clean &amp; hexo s<span class="hljs-comment"># 清理缓存 -&gt; 生存静态页 -&gt; 部署到github (等 10 分钟就可发布成功，因为github缓存)</span>hexo clean &amp; hexo g &amp; hexo d</code></pre></div><p>只需要上面的几句命令，就可以发布一篇 blog，简直爱❤️了。</p><p>hexo 同样也支持 markdown 格式，这样就可以把 notion 里的文章，搬到 github.io 上来当 blog 页使用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
